import { IGroupByRecord } from '../../data-operations/groupby-record.interface';
import { IGroupingState } from '../../data-operations/groupby-state.interface';
import { IGroupByResult } from '../../data-operations/grouping-result.interface';
import { ISortingExpression } from '../../data-operations/sorting-strategy';
import { GridType } from './grid.interface';
/**
 * Represents a sorting strategy for the grid data
 * Contains a single method sort that sorts the provided data based on the given sorting expressions
 */
export interface IGridSortingStrategy {
    /**
    * `data`: The array of data to be sorted. Could be of any type.
    * `expressions`: An array of sorting expressions that define the sorting rules. The expression contains information like file name, whether the letter case should be taken into account, etc.
    * `grid`: (Optional) The instance of the grid where the sorting is applied.
    * Returns a new array with the data sorted according to the sorting expressions.
    */
    sort(data: any[], expressions: ISortingExpression[], grid?: GridType): any[];
}
/**
 * Represents a grouping strategy for the grid data, extending the Sorting Strategy interface (contains a sorting method).
 */
export interface IGridGroupingStrategy extends IGridSortingStrategy {
    /**
     * The method groups the provided data based on the given grouping state and returns the result.
     * `data`: The array of data to be grouped. Could be of any type.
     * `state`: The grouping state that defines the grouping settings and expressions.
     * `grid`: (Optional) The instance of the grid where the grouping is applied.
     * `groupsRecords`: (Optional) An array that holds the records for each group.
     * `fullResult`: (Optional) The complete result of grouping including groups and summary data.
     * Returns an object containing the result of the grouping operation.
     */
    groupBy(data: any[], state: IGroupingState, grid?: any, groupsRecords?: any[], fullResult?: IGroupByResult): IGroupByResult;
}
/**
 * Represents a class implementing the IGridSortingStrategy interface.
 * It provides sorting functionality for grid data based on sorting expressions.
 */
export declare class IgxSorting implements IGridSortingStrategy {
    /**
   * Sorts the provided data based on the given sorting expressions.
   * `data`: The array of data to be sorted.
   * `expressions`: An array of sorting expressions that define the sorting rules. The expression contains information like file name, whether the letter case should be taken into account, etc.
   * `grid`: (Optional) The instance of the grid where the sorting is applied.
   * Returns a new array with the data sorted according to the sorting expressions.
   */
    sort(data: any[], expressions: ISortingExpression[], grid?: GridType): any[];
    /**
   * Recursively groups the provided data based on the given grouping state and returns the grouped result.
   * Returns an array containing the grouped result.
   * @internal
   */
    protected groupDataRecursive(data: any[], state: IGroupingState, level: number, parent: IGroupByRecord, metadata: IGroupByRecord[], grid?: GridType, groupsRecords?: any[], fullResult?: IGroupByResult): any[];
    /**
   * Retrieves the value of the specified field from the given object, considering date and time data types.
   * `key`: The key of the field to retrieve.
   * `isDate`: (Optional) Indicates if the field is of type Date.
   * `isTime`: (Optional) Indicates if the field is of type Time.
   * Returns the value of the specified field in the data object.
   * @internal
   */
    protected getFieldValue<T>(obj: T, key: string, isDate?: boolean, isTime?: boolean): any;
    /**
   * Groups the records in the provided data array based on the given grouping expression.
   * `groupingComparer`: (Optional) A custom grouping comparator to determine the members of the group.
   * Returns an array containing the records that belong to the group.
   * @internal
   */
    private groupedRecordsByExpression;
    /**
   * Sorts the provided data array based on the given sorting expressions.
   * The method can be used when multiple sorting is performed, going through each one
   * Returns a new array with the data sorted according to the sorting expressions.
   * @internal
   */
    private sortDataRecursive;
}
/**
 * Represents a class implementing the IGridGroupingStrategy interface and extending the IgxSorting class.
 * It provides a method to group data based on the given grouping state.
 */
export declare class IgxGrouping extends IgxSorting implements IGridGroupingStrategy {
    /**
     * Groups the provided data based on the given grouping state.
     * Returns an object containing the result of the grouping operation.
     */
    groupBy(data: any[], state: IGroupingState, grid?: any, groupsRecords?: any[], fullResult?: IGroupByResult): IGroupByResult;
}
/**
 * Represents a class implementing the IGridSortingStrategy interface with a no-operation sorting strategy.
 * It performs no sorting and returns the data as it is.
 */
export declare class NoopSortingStrategy implements IGridSortingStrategy {
    private static _instance;
    private constructor();
    static instance(): NoopSortingStrategy;
    sort(data: any[]): any[];
}
/**
 * Represents a class extending the IgxSorting class
 * Provids custom data record sorting.
 */
export declare class IgxDataRecordSorting extends IgxSorting {
    /**
    * Overrides the base method to retrieve the field value from the data object instead of the record object.
    * Returns the value of the specified field in the data object.
    */
    protected getFieldValue(obj: any, key: string, isDate?: boolean, isTime?: boolean): any;
}
