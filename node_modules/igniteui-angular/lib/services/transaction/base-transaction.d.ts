import { TransactionService, Transaction, State, StateUpdateEvent } from './transaction';
import { EventEmitter } from '@angular/core';
import { IDataCloneStrategy } from '../../data-operations/data-clone-strategy';
export declare class IgxBaseTransactionService<T extends Transaction, S extends State> implements TransactionService<T, S> {
    /**
     * Gets/Sets the data clone strategy used to clone data
     */
    get cloneStrategy(): IDataCloneStrategy;
    set cloneStrategy(strategy: IDataCloneStrategy);
    /**
     * @returns if there are any transactions in the Redo stack
     */
    get canRedo(): boolean;
    /**
     * @returns if there are any transactions in the Undo stack
     */
    get canUndo(): boolean;
    /**
     * Returns whether transaction is enabled for this service
     */
    get enabled(): boolean;
    /**
     * Event fired when transaction state has changed - add transaction, commit all transactions, undo and redo
     */
    onStateUpdate: EventEmitter<StateUpdateEvent>;
    protected _isPending: boolean;
    protected _pendingTransactions: T[];
    protected _pendingStates: Map<any, S>;
    private _cloneStrategy;
    /**
     * Adds provided  transaction with recordRef if any
     *
     * @param transaction Transaction to be added
     * @param recordRef Reference to the value of the record in the data source related to the changed item
     */
    add(transaction: T, recordRef?: any): void;
    /**
     * Returns all recorded transactions in chronological order
     *
     * @param id Optional record id to get transactions for
     * @returns All transaction in the service or for the specified record
     */
    getTransactionLog(_id?: any): T[];
    /**
     * Remove the last transaction if any
     */
    undo(): void;
    /**
     * Applies the last undone transaction if any
     */
    redo(): void;
    /**
     * Returns aggregated changes from all transactions
     *
     * @param mergeChanges If set to true will merge each state's value over relate recordRef
     * and will record resulting value in the related transaction
     * @returns Collection of aggregated transactions for each changed record
     */
    getAggregatedChanges(mergeChanges: boolean): T[];
    /**
     * Returns the state of the record with provided id
     *
     * @param id The id of the record
     * @param pending Should get pending state
     * @returns State of the record if any
     */
    getState(id: any): S;
    /**
     * Returns value of the required id including all uncommitted changes
     *
     * @param id The id of the record to return value for
     * @param mergeChanges If set to true will merge state's value over relate recordRef
     * and will return merged value
     * @returns Value with changes or **null**
     */
    getAggregatedValue(id: any, mergeChanges: boolean): any;
    /**
     * Applies all transactions over the provided data
     *
     * @param data Data source to update
     * @param id Optional record id to commit transactions for
     */
    commit(_data: any[], _id?: any): void;
    /**
     * Clears all transactions
     *
     * @param id Optional record id to clear transactions for
     */
    clear(_id?: any): void;
    /**
     * Starts pending transactions. All transactions passed after call to startPending
     * will not be added to transaction log
     */
    startPending(): void;
    /**
     * Clears all pending transactions and aggregated pending state. If commit is set to true
     * commits pending states as single transaction
     *
     * @param commit Should commit the pending states
     */
    endPending(_commit: boolean): void;
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     *
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    protected updateState(states: Map<any, S>, transaction: T, recordRef?: any): void;
    /**
     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
     *
     * @param state State to update value for
     * @returns updated value including all the changes in provided state
     */
    protected updateValue(state: S): any;
    /**
     * Merges second values in first value and the result in empty object. If values are primitive type
     * returns second value if exists, or first value.
     *
     * @param first Value to merge into
     * @param second Value to merge
     */
    protected mergeValues<U>(first: U, second: U): U;
    /**
     * Compares the state with recordRef and clears all duplicated values. If any state ends as
     * empty object removes it from states.
     *
     * @param state State to clean
     */
    protected cleanState(id: any, states: Map<any, S>): void;
}
