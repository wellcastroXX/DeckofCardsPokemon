import { NgClass, NgTemplateOutlet, NgIf } from '@angular/common';
import { Component, EventEmitter, HostBinding, Input, Output, ViewChild, ContentChild, Directive, booleanAttribute } from '@angular/core';
import { IgxProgressBarTextTemplateDirective, IgxProgressBarGradientDirective, } from './progressbar.common';
import { mkenum } from '../core/utils';
import * as i0 from "@angular/core";
import * as i1 from "../services/direction/directionality";
const ONE_PERCENT = 0.01;
const MIN_VALUE = 0;
export const IgxTextAlign = /*@__PURE__*/ mkenum({
    START: 'start',
    CENTER: 'center',
    END: 'end'
});
export const IgxProgressType = /*@__PURE__*/ mkenum({
    ERROR: 'error',
    INFO: 'info',
    WARNING: 'warning',
    SUCCESS: 'success'
});
/**
 * @hidden
 */
export class BaseProgressDirective {
    constructor() {
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *     alert("Progress made!");
         * }
         *  //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (progressChanged)="progressChange($event)"></igx-circular-bar>
         * <igx-linear-bar [value]="currentValue" (progressChanged)="progressChange($event)"></igx-linear-bar>
         * ```
         */
        this.progressChanged = new EventEmitter();
        /**
         * Sets/Gets progressbar in indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets/Gets progressbar animation duration. By default it is 2000ms.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        this.animationDuration = 2000;
        this._initValue = 0;
        this._contentInit = false;
        this._max = 100;
        this._value = MIN_VALUE;
        this._newVal = MIN_VALUE;
        this._animate = true;
        this._internalState = {
            oldVal: 0,
            newVal: 0
        };
    }
    /**
     * Returns the value which update the progress indicator of the `progress bar`.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public stepValue(event) {
     *     let step = this.progressBar.step;
     *     alert(step);
     * }
     * ```
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     * ```
     */
    set step(val) {
        const step = Number(val);
        if (step > this.max) {
            return;
        }
        this._step = step;
    }
    /**
     * Animating the progress. By default it is set to true.
     * ```html
     * <igx-linear-bar [animate]="false" [max]="200" [value]="50"></igx-linear-bar>
     * <igx-circular-bar [animate]="false" [max]="200" [value]="50"></igx-circular-bar>
     * ```
     */
    set animate(animate) {
        this._animate = animate;
        if (animate) {
            this.animationDuration = 2000;
        }
        else {
            this.animationDuration = 0;
        }
    }
    /**
     * Returns whether the `progress bar` has animation true/false.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public animationStatus(event) {
     *     let animationStatus = this.progressBar.animate;
     *     alert(animationStatus);
     * }
     * ```
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     * ```
     */
    set max(maxNum) {
        if (maxNum < MIN_VALUE || this._max === maxNum ||
            (this._animation && this._animation.playState !== 'finished')) {
            return;
        }
        this._internalState.newVal = Math.round(toValue(toPercent(this.value, maxNum), maxNum));
        this._value = this._internalState.oldVal = Math.round(toValue(this.valueInPercent, maxNum));
        this._max = maxNum;
        this.triggerProgressTransition(this._internalState.oldVal, this._internalState.newVal, true);
    }
    /**
     * Returns the the maximum progress value of the `progress bar`.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public maxValue(event) {
     *     let max = this.progressBar.max;
     *     alert(max);
     * }
     * ```
     */
    get max() {
        return this._max;
    }
    /**
     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     * public valuePercent(event){
     *     let percentValue = this.progressBar.valueInPercent;
     *     alert(percentValue);
     * }
     * ```
     */
    get valueInPercent() {
        const val = toPercent(this._value, this._max);
        return val;
    }
    /**
     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     */
    set value(val) {
        if (this._animation && this._animation.playState !== 'finished' || val < 0) {
            return;
        }
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    triggerProgressTransition(oldVal, newVal, maxUpdate = false) {
        if (oldVal === newVal) {
            return;
        }
        const changedValues = {
            currentValue: newVal,
            previousValue: oldVal
        };
        const stepDirection = this.directionFlow(oldVal, newVal);
        if (this._animate) {
            const newToPercent = toPercent(newVal, this.max);
            const oldToPercent = toPercent(oldVal, this.max);
            const duration = this.animationDuration / Math.abs(newToPercent - oldToPercent) / (this._step ? this._step : 1);
            this.runAnimation(newVal);
            this._interval = setInterval(() => this.increase(newVal, stepDirection), duration);
        }
        else {
            this.updateProgress(newVal);
        }
        if (maxUpdate) {
            return;
        }
        this.progressChanged.emit(changedValues);
    }
    /**
     * @hidden
     */
    increase(newValue, step) {
        const targetValue = toPercent(newValue, this._max);
        this._value = valueInRange(this._value, this._max) + step;
        if ((step > 0 && this.valueInPercent >= targetValue) || (step < 0 && this.valueInPercent <= targetValue)) {
            if (this._value !== newValue) {
                this._value = newValue;
            }
            return clearInterval(this._interval);
        }
    }
    /**
     * @hidden
     */
    directionFlow(currentValue, prevValue) {
        return currentValue < prevValue ? this.step : -this.step;
    }
    /**
     * @hidden
     * @param step
     */
    updateProgress(val) {
        this._value = valueInRange(val, this._max);
        // this.valueInPercent = toPercent(val, this._max);
        this.runAnimation(val);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: BaseProgressDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.2.4", type: BaseProgressDirective, inputs: { indeterminate: ["indeterminate", "indeterminate", booleanAttribute], animationDuration: "animationDuration", step: "step", animate: ["animate", "animate", booleanAttribute], max: "max", value: "value" }, outputs: { progressChanged: "progressChanged" }, host: { properties: { "attr.aria-valuemax": "this.max", "attr.aria-valuenow": "this.value" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: BaseProgressDirective, decorators: [{
            type: Directive
        }], ctorParameters: () => [], propDecorators: { progressChanged: [{
                type: Output
            }], indeterminate: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], animationDuration: [{
                type: Input
            }], step: [{
                type: Input
            }], animate: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], max: [{
                type: HostBinding,
                args: ['attr.aria-valuemax']
            }, {
                type: Input
            }], value: [{
                type: HostBinding,
                args: ['attr.aria-valuenow']
            }, {
                type: Input
            }] } });
let NEXT_LINEAR_ID = 0;
let NEXT_CIRCULAR_ID = 0;
let NEXT_GRADIENT_ID = 0;
export class IgxLinearProgressBarComponent extends BaseProgressDirective {
    constructor() {
        super(...arguments);
        this.valueMin = 0;
        this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.striped = false;
        /**
         * Sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        this.role = 'progressbar';
        /**
         * Sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *     this.positionCenter = IgxTextAlign.CENTER;
         * }
         *  //...
         * ```
         *  ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         *  <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         *  <igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
         * ```
         */
        this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
         * ```
         */
        this.type = 'default';
        this.animationState = {
            width: '0%'
        };
    }
    /**
     * @hidden
     * ```
     */
    get isIndeterminate() {
        return this.indeterminate;
    }
    /**
     * @hidden
     */
    get error() {
        return this.type === IgxProgressType.ERROR;
    }
    /**
     * @hidden
     */
    get info() {
        return this.type === IgxProgressType.INFO;
    }
    /**
     * @hidden
     */
    get warning() {
        return this.type === IgxProgressType.WARNING;
    }
    /**
     * @hidden
     */
    get success() {
        return this.type === IgxProgressType.SUCCESS;
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
    runAnimation(value) {
        if (this._animation && this._animation.playState !== 'finished') {
            return;
        }
        const valueInPercent = this.max <= 0 ? 0 : toPercent(value, this.max);
        const FRAMES = [];
        FRAMES[0] = {
            ...this.animationState
        };
        this.animationState.width = valueInPercent + '%';
        FRAMES[1] = {
            ...this.animationState
        };
        this._animation = this._progressIndicator.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards',
            duration: this.animationDuration
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxLinearProgressBarComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.2.4", type: IgxLinearProgressBarComponent, isStandalone: true, selector: "igx-linear-bar", inputs: { striped: ["striped", "striped", booleanAttribute], role: "role", id: "id", textAlign: "textAlign", textVisibility: ["textVisibility", "textVisibility", booleanAttribute], textTop: ["textTop", "textTop", booleanAttribute], text: "text", type: "type" }, host: { properties: { "attr.aria-valuemin": "this.valueMin", "class.igx-linear-bar": "this.cssClass", "class.igx-linear-bar--striped": "this.striped", "class.igx-linear-bar--indeterminate": "this.isIndeterminate", "attr.role": "this.role", "attr.id": "this.id", "class.igx-linear-bar--danger": "this.error", "class.igx-linear-bar--info": "this.info", "class.igx-linear-bar--warning": "this.warning", "class.igx-linear-bar--success": "this.success" } }, viewQueries: [{ propertyName: "_progressIndicator", first: true, predicate: ["indicator"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<div class=\"igx-linear-bar__base\">\n    <div #indicator class=\"igx-linear-bar__indicator\" [style.width]=\"0\"></div>\n    <div class=\"igx-linear-bar__indicator-secondary\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxLinearProgressBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-linear-bar', standalone: true, imports: [NgClass], template: "<div class=\"igx-linear-bar__base\">\n    <div #indicator class=\"igx-linear-bar__indicator\" [style.width]=\"0\"></div>\n    <div class=\"igx-linear-bar__indicator-secondary\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n" }]
        }], propDecorators: { valueMin: [{
                type: HostBinding,
                args: ['attr.aria-valuemin']
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-linear-bar']
            }], striped: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--striped']
            }, {
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], isIndeterminate: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--indeterminate']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }, {
                type: Input
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], textAlign: [{
                type: Input
            }], textVisibility: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], textTop: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], text: [{
                type: Input
            }], type: [{
                type: Input
            }], _progressIndicator: [{
                type: ViewChild,
                args: ['indicator', { static: true }]
            }], error: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--danger']
            }], info: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--info']
            }], warning: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--warning']
            }], success: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--success']
            }] } });
export class IgxCircularProgressBarComponent extends BaseProgressDirective {
    /**
     * @hidden
     */
    get isIndeterminate() {
        return this.indeterminate;
    }
    /**
     * @hidden
     */
    get context() {
        return {
            $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
        };
    }
    constructor(renderer, _directionality) {
        super();
        this.renderer = renderer;
        this._directionality = _directionality;
        /** @hidden */
        this.cssClass = 'igx-circular-bar';
        /**
         * Sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * @hidden
         */
        this.gradientId = `igx-circular-gradient-${NEXT_GRADIENT_ID++}`;
        this._circleRadius = 46;
        this._circumference = 2 * Math.PI * this._circleRadius;
        this.STROKE_OPACITY_DVIDER = 100;
        this.STROKE_OPACITY_ADDITION = .2;
        this.animationState = {
            strokeDashoffset: 289,
            strokeOpacity: 1
        };
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
    ngAfterViewInit() {
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', `url(#${this.gradientId})`);
    }
    /**
     * @hidden
     */
    get textContent() {
        return this.text;
    }
    runAnimation(value) {
        if (this._animation && this._animation.playState !== 'finished') {
            return;
        }
        const valueInPercent = this.max <= 0 ? 0 : toPercent(value, this.max);
        const FRAMES = [];
        FRAMES[0] = { ...this.animationState };
        this.animationState.strokeDashoffset = this.getProgress(valueInPercent);
        this.animationState.strokeOpacity = toPercent(value, this.max) / this.STROKE_OPACITY_DVIDER + this.STROKE_OPACITY_ADDITION;
        FRAMES[1] = {
            ...this.animationState
        };
        this._animation = this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards',
            duration: this.animationDuration
        });
    }
    getProgress(percentage) {
        return this._directionality.rtl ?
            this._circumference + (percentage * this._circumference / 100) :
            this._circumference - (percentage * this._circumference / 100);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxCircularProgressBarComponent, deps: [{ token: i0.Renderer2 }, { token: i1.IgxDirectionality }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.2.4", type: IgxCircularProgressBarComponent, isStandalone: true, selector: "igx-circular-bar", inputs: { id: "id", isIndeterminate: "isIndeterminate", textVisibility: ["textVisibility", "textVisibility", booleanAttribute], text: "text" }, host: { properties: { "class.igx-circular-bar": "this.cssClass", "attr.id": "this.id", "class.igx-circular-bar--indeterminate": "this.isIndeterminate" } }, queries: [{ propertyName: "textTemplate", first: true, predicate: IgxProgressBarTextTemplateDirective, descendants: true, read: IgxProgressBarTextTemplateDirective }, { propertyName: "gradientTemplate", first: true, predicate: IgxProgressBarGradientDirective, descendants: true, read: IgxProgressBarGradientDirective }], viewQueries: [{ propertyName: "_svgCircle", first: true, predicate: ["circle"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n<span class=\"igx-circular-bar__text\" *ngIf=\"textVisibility\">\n    <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n    </ng-container>\n</span>\n\n<ng-template #defaultTextTemplate>\n    {{textContent ? textContent: valueInPercent + '%'}}\n</ng-template>\n\n", dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxCircularProgressBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-circular-bar', standalone: true, imports: [NgTemplateOutlet, NgIf], template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n<span class=\"igx-circular-bar__text\" *ngIf=\"textVisibility\">\n    <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n    </ng-container>\n</span>\n\n<ng-template #defaultTextTemplate>\n    {{textContent ? textContent: valueInPercent + '%'}}\n</ng-template>\n\n" }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i1.IgxDirectionality }], propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.igx-circular-bar']
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], isIndeterminate: [{
                type: HostBinding,
                args: ['class.igx-circular-bar--indeterminate']
            }, {
                type: Input
            }], textVisibility: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], text: [{
                type: Input
            }], textTemplate: [{
                type: ContentChild,
                args: [IgxProgressBarTextTemplateDirective, { read: IgxProgressBarTextTemplateDirective }]
            }], gradientTemplate: [{
                type: ContentChild,
                args: [IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective }]
            }], _svgCircle: [{
                type: ViewChild,
                args: ['circle', { static: true }]
            }] } });
export const valueInRange = (value, max, min = 0) => Math.max(Math.min(value, max), min);
export const toPercent = (value, max) => !max ? 0 : Math.floor(100 * value / max);
export const toValue = (value, max) => max * value / 100;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9wcm9ncmVzc2Jhci90ZW1wbGF0ZXMvbGluZWFyLWJhci5jb21wb25lbnQuaHRtbCIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9wcm9ncmVzc2Jhci90ZW1wbGF0ZXMvY2lyY3VsYXItYmFyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbEUsT0FBTyxFQUNILFNBQVMsRUFFVCxZQUFZLEVBQ1osV0FBVyxFQUNYLEtBQUssRUFDTCxNQUFNLEVBRU4sU0FBUyxFQUNULFlBQVksRUFHWixTQUFTLEVBQ1QsZ0JBQWdCLEVBQ25CLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDSCxtQ0FBbUMsRUFDbkMsK0JBQStCLEdBQ2xDLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFrQixNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7OztBQUV2RCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDekIsTUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDO0FBRXBCLE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxhQUFhLENBQUEsTUFBTSxDQUFDO0lBQzVDLEtBQUssRUFBRSxPQUFPO0lBQ2QsTUFBTSxFQUFFLFFBQVE7SUFDaEIsR0FBRyxFQUFFLEtBQUs7Q0FDYixDQUFDLENBQUM7QUFHSCxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsYUFB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QUMsTUFBTSxZQUFZLEdBQUcsQ0FBQyxLQUFhLEVBQUUsR0FBVyxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQVUsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFFakgsTUFBTSxDQUFDLE1BQU0sU0FBUyxHQUFHLENBQUMsS0FBYSxFQUFFLEdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBRWxHLE1BQU0sQ0FBQyxNQUFNLE9BQU8sR0FBRyxDQUFDLEtBQWEsRUFBRSxHQUFXLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdDbGFzcywgTmdUZW1wbGF0ZU91dGxldCwgTmdJZiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgUmVuZGVyZXIyLFxuICAgIFZpZXdDaGlsZCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIERpcmVjdGl2ZSxcbiAgICBib29sZWFuQXR0cmlidXRlXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBJZ3hQcm9ncmVzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlLFxufSBmcm9tICcuL3Byb2dyZXNzYmFyLmNvbW1vbic7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncywgbWtlbnVtIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJZ3hEaXJlY3Rpb25hbGl0eSB9IGZyb20gJy4uL3NlcnZpY2VzL2RpcmVjdGlvbi9kaXJlY3Rpb25hbGl0eSc7XG5jb25zdCBPTkVfUEVSQ0VOVCA9IDAuMDE7XG5jb25zdCBNSU5fVkFMVUUgPSAwO1xuXG5leHBvcnQgY29uc3QgSWd4VGV4dEFsaWduID0gLypAX19QVVJFX18qL21rZW51bSh7XG4gICAgU1RBUlQ6ICdzdGFydCcsXG4gICAgQ0VOVEVSOiAnY2VudGVyJyxcbiAgICBFTkQ6ICdlbmQnXG59KTtcbmV4cG9ydCB0eXBlIElneFRleHRBbGlnbiA9ICh0eXBlb2YgSWd4VGV4dEFsaWduKVtrZXlvZiB0eXBlb2YgSWd4VGV4dEFsaWduXTtcblxuZXhwb3J0IGNvbnN0IElneFByb2dyZXNzVHlwZSA9IC8qQF9fUFVSRV9fKi9ta2VudW0oe1xuICAgIEVSUk9SOiAnZXJyb3InLFxuICAgIElORk86ICdpbmZvJyxcbiAgICBXQVJOSU5HOiAnd2FybmluZycsXG4gICAgU1VDQ0VTUzogJ3N1Y2Nlc3MnXG59KTtcbmV4cG9ydCB0eXBlIElneFByb2dyZXNzVHlwZSA9ICh0eXBlb2YgSWd4UHJvZ3Jlc3NUeXBlKVtrZXlvZiB0eXBlb2YgSWd4UHJvZ3Jlc3NUeXBlXTtcblxuZXhwb3J0IGludGVyZmFjZSBJQ2hhbmdlUHJvZ3Jlc3NFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgcHJldmlvdXNWYWx1ZTogbnVtYmVyO1xuICAgIGN1cnJlbnRWYWx1ZTogbnVtYmVyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQERpcmVjdGl2ZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVByb2dyZXNzRGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBBbiBldmVudCwgd2hpY2ggaXMgdHJpZ2dlcmVkIGFmdGVyIGEgcHJvZ3Jlc3MgaXMgY2hhbmdlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIHByb2dyZXNzQ2hhbmdlKGV2ZW50KSB7XG4gICAgICogICAgIGFsZXJ0KFwiUHJvZ3Jlc3MgbWFkZSFcIik7XG4gICAgICogfVxuICAgICAqICAvLy4uLlxuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbdmFsdWVdPVwiY3VycmVudFZhbHVlXCIgKHByb2dyZXNzQ2hhbmdlZCk9XCJwcm9ncmVzc0NoYW5nZSgkZXZlbnQpXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbdmFsdWVdPVwiY3VycmVudFZhbHVlXCIgKHByb2dyZXNzQ2hhbmdlZCk9XCJwcm9ncmVzc0NoYW5nZSgkZXZlbnQpXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcHJvZ3Jlc3NDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxJQ2hhbmdlUHJvZ3Jlc3NFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL0dldHMgcHJvZ3Jlc3NiYXIgaW4gaW5kZXRlcm1pbmF0ZS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbaW5kZXRlcm1pbmF0ZV09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbaW5kZXRlcm1pbmF0ZV09XCJ0cnVlXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBpbmRldGVybWluYXRlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL0dldHMgcHJvZ3Jlc3NiYXIgYW5pbWF0aW9uIGR1cmF0aW9uLiBCeSBkZWZhdWx0IGl0IGlzIDIwMDBtcy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGFuaW1hdGlvbkR1cmF0aW9uID0gMjAwMDtcbiAgICBwdWJsaWMgX2ludGVydmFsO1xuXG4gICAgcHJvdGVjdGVkIF9pbml0VmFsdWUgPSAwO1xuICAgIHByb3RlY3RlZCBfY29udGVudEluaXQgPSBmYWxzZTtcbiAgICBwcm90ZWN0ZWQgX21heCA9IDEwMDtcbiAgICBwcm90ZWN0ZWQgX3ZhbHVlID0gTUlOX1ZBTFVFO1xuICAgIHByb3RlY3RlZCBfbmV3VmFsID0gTUlOX1ZBTFVFO1xuICAgIHByb3RlY3RlZCBfYW5pbWF0ZSA9IHRydWU7XG4gICAgcHJvdGVjdGVkIF9zdGVwO1xuICAgIHByb3RlY3RlZCBfYW5pbWF0aW9uO1xuICAgIHByb3RlY3RlZCBfdmFsdWVJblBlcmNlbnQ7XG4gICAgcHJvdGVjdGVkIF9pbnRlcm5hbFN0YXRlID0ge1xuICAgICAgICBvbGRWYWw6IDAsXG4gICAgICAgIG5ld1ZhbDogMFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgd2hpY2ggdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3Igb2YgdGhlIGBwcm9ncmVzcyBiYXJgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgfCBJZ3hDaXJjdWxhckJhckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgc3RlcFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgIGxldCBzdGVwID0gdGhpcy5wcm9ncmVzc0Jhci5zdGVwO1xuICAgICAqICAgICBhbGVydChzdGVwKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHN0ZXAoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXggKiBPTkVfUEVSQ0VOVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBieSB3aGljaCBwcm9ncmVzcyBpbmRpY2F0b3IgaXMgdXBkYXRlZC4gQnkgZGVmYXVsdCBpdCBpcyAxLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiMFwiIFtzdGVwXT1cIjFcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIiBbc3RlcF09XCIxXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc3RlcCh2YWw6IG51bWJlcikge1xuICAgICAgICBjb25zdCBzdGVwID0gTnVtYmVyKHZhbCk7XG4gICAgICAgIGlmIChzdGVwID4gdGhpcy5tYXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGluZyB0aGUgcHJvZ3Jlc3MuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBzZXQgYW5pbWF0ZShhbmltYXRlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGUgPSBhbmltYXRlO1xuICAgICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25EdXJhdGlvbiA9IDIwMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgYHByb2dyZXNzIGJhcmAgaGFzIGFuaW1hdGlvbiB0cnVlL2ZhbHNlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgfCBJZ3hDaXJjdWxhckJhckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgYW5pbWF0aW9uU3RhdHVzKGV2ZW50KSB7XG4gICAgICogICAgIGxldCBhbmltYXRpb25TdGF0dXMgPSB0aGlzLnByb2dyZXNzQmFyLmFuaW1hdGU7XG4gICAgICogICAgIGFsZXJ0KGFuaW1hdGlvblN0YXR1cyk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYW5pbWF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byAxMDAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXZhbHVlbWF4JylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgbWF4KG1heE51bTogbnVtYmVyKSB7XG4gICAgICAgIGlmIChtYXhOdW0gPCBNSU5fVkFMVUUgfHwgdGhpcy5fbWF4ID09PSBtYXhOdW0gfHxcbiAgICAgICAgICAgICh0aGlzLl9hbmltYXRpb24gJiYgdGhpcy5fYW5pbWF0aW9uLnBsYXlTdGF0ZSAhPT0gJ2ZpbmlzaGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ludGVybmFsU3RhdGUubmV3VmFsID0gTWF0aC5yb3VuZCh0b1ZhbHVlKHRvUGVyY2VudCh0aGlzLnZhbHVlLCBtYXhOdW0pLCBtYXhOdW0pKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9pbnRlcm5hbFN0YXRlLm9sZFZhbCA9IE1hdGgucm91bmQodG9WYWx1ZSh0aGlzLnZhbHVlSW5QZXJjZW50LCBtYXhOdW0pKTtcbiAgICAgICAgdGhpcy5fbWF4ID0gbWF4TnVtO1xuICAgICAgICB0aGlzLnRyaWdnZXJQcm9ncmVzc1RyYW5zaXRpb24odGhpcy5faW50ZXJuYWxTdGF0ZS5vbGRWYWwsIHRoaXMuX2ludGVybmFsU3RhdGUubmV3VmFsLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0aGUgbWF4aW11bSBwcm9ncmVzcyB2YWx1ZSBvZiB0aGUgYHByb2dyZXNzIGJhcmAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCB8IElneENpcmN1bGFyQmFyQ29tcG9uZW50O1xuICAgICAqIHB1YmxpYyBtYXhWYWx1ZShldmVudCkge1xuICAgICAqICAgICBsZXQgbWF4ID0gdGhpcy5wcm9ncmVzc0Jhci5tYXg7XG4gICAgICogICAgIGFsZXJ0KG1heCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAvYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHZhbHVlIGluIHBlcmNlbnRhZ2UuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDsgLy8gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudFxuICAgICAqIHB1YmxpYyB2YWx1ZVBlcmNlbnQoZXZlbnQpe1xuICAgICAqICAgICBsZXQgcGVyY2VudFZhbHVlID0gdGhpcy5wcm9ncmVzc0Jhci52YWx1ZUluUGVyY2VudDtcbiAgICAgKiAgICAgYWxlcnQocGVyY2VudFZhbHVlKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB2YWx1ZUluUGVyY2VudCgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCB2YWwgPSB0b1BlcmNlbnQodGhpcy5fdmFsdWUsIHRoaXMuX21heCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHBvc2l0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICogcHVibGljIGdldFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgIGxldCB2YWx1ZSA9IHRoaXMucHJvZ3Jlc3NCYXIudmFsdWU7XG4gICAgICogICAgIGFsZXJ0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVub3cnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCB2YWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbc3RyaXBlZF09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHZhbHVlKHZhbCkge1xuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uICYmIHRoaXMuX2FuaW1hdGlvbi5wbGF5U3RhdGUgIT09ICdmaW5pc2hlZCcgfHwgdmFsIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsSW5SYW5nZSA9IHZhbHVlSW5SYW5nZSh2YWwsIHRoaXMubWF4KTtcblxuICAgICAgICBpZiAoaXNOYU4odmFsSW5SYW5nZSkgfHwgdGhpcy5fdmFsdWUgPT09IHZhbCB8fCB0aGlzLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50SW5pdCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyUHJvZ3Jlc3NUcmFuc2l0aW9uKHRoaXMuX3ZhbHVlLCB2YWxJblJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRWYWx1ZSA9IHZhbEluUmFuZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgdHJpZ2dlclByb2dyZXNzVHJhbnNpdGlvbihvbGRWYWwsIG5ld1ZhbCwgbWF4VXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG9sZFZhbCA9PT0gbmV3VmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGFuZ2VkVmFsdWVzID0ge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlOiBuZXdWYWwsXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiBvbGRWYWxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzdGVwRGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb25GbG93KG9sZFZhbCwgbmV3VmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RvUGVyY2VudCA9IHRvUGVyY2VudChuZXdWYWwsIHRoaXMubWF4KTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFRvUGVyY2VudCA9IHRvUGVyY2VudChvbGRWYWwsIHRoaXMubWF4KTtcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5hbmltYXRpb25EdXJhdGlvbiAvIE1hdGguYWJzKG5ld1RvUGVyY2VudCAtIG9sZFRvUGVyY2VudCkgLyAodGhpcy5fc3RlcCA/IHRoaXMuX3N0ZXAgOiAxKTtcbiAgICAgICAgICAgIHRoaXMucnVuQW5pbWF0aW9uKG5ld1ZhbCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuaW5jcmVhc2UobmV3VmFsLCBzdGVwRGlyZWN0aW9uKSwgZHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcyhuZXdWYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heFVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDaGFuZ2VkLmVtaXQoY2hhbmdlZFZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbmNyZWFzZShuZXdWYWx1ZTogbnVtYmVyLCBzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSB0b1BlcmNlbnQobmV3VmFsdWUsIHRoaXMuX21heCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVJblJhbmdlKHRoaXMuX3ZhbHVlLCB0aGlzLl9tYXgpICsgc3RlcDtcbiAgICAgICAgaWYgKChzdGVwID4gMCAmJiB0aGlzLnZhbHVlSW5QZXJjZW50ID49IHRhcmdldFZhbHVlKSB8fCAoc3RlcCA8IDAgJiYgdGhpcy52YWx1ZUluUGVyY2VudCA8PSB0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXJlY3Rpb25GbG93KGN1cnJlbnRWYWx1ZTogbnVtYmVyLCBwcmV2VmFsdWU6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUgPCBwcmV2VmFsdWUgPyB0aGlzLnN0ZXAgOiAtdGhpcy5zdGVwO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBydW5BbmltYXRpb24odmFsdWU6IG51bWJlcik7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHBhcmFtIHN0ZXBcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZVByb2dyZXNzKHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVJblJhbmdlKHZhbCwgdGhpcy5fbWF4KTtcbiAgICAgICAgLy8gdGhpcy52YWx1ZUluUGVyY2VudCA9IHRvUGVyY2VudCh2YWwsIHRoaXMuX21heCk7XG4gICAgICAgIHRoaXMucnVuQW5pbWF0aW9uKHZhbCk7XG4gICAgfVxufVxubGV0IE5FWFRfTElORUFSX0lEID0gMDtcbmxldCBORVhUX0NJUkNVTEFSX0lEID0gMDtcbmxldCBORVhUX0dSQURJRU5UX0lEID0gMDtcbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LWxpbmVhci1iYXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGVzL2xpbmVhci1iYXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW05nQ2xhc3NdXG59KVxuZXhwb3J0IGNsYXNzIElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50IGV4dGVuZHMgQmFzZVByb2dyZXNzRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVtaW4nKVxuICAgIHB1YmxpYyB2YWx1ZU1pbiA9IDA7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyJylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSAnaWd4LWxpbmVhci1iYXInO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgdG8gaGF2ZSBzdHJpcGVkIHN0eWxlLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cInRydWVcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0tc3RyaXBlZCcpXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIHN0cmlwZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1pbmRldGVybWluYXRlJylcbiAgICBwdWJsaWMgZ2V0IGlzSW5kZXRlcm1pbmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXRlcm1pbmF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYHJvbGVgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gYHByb2dyZXNzYmFyYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIHJvbGU9XCJwcm9ncmVzc2JhclwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvbGUgPSAncHJvZ3Jlc3NiYXInO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYGlkYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW2lkXT1cIidpZ3gtbGluZWFyLWJhci01NSdcIiBbc3RyaXBlZF09XCJ0cnVlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LWxpbmVhci1iYXItJHtORVhUX0xJTkVBUl9JRCsrfWA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBvc2l0aW9uIHRoYXQgZGVmaW5lcyB3aGVyZSB0aGUgdGV4dCBpcyBhbGlnbmVkLlxuICAgICAqIFBvc3NpYmxlIG9wdGlvbnMgLSBgSWd4VGV4dEFsaWduLlNUQVJUYCAoZGVmYXVsdCksIGBJZ3hUZXh0QWxpZ24uQ0VOVEVSYCwgYElneFRleHRBbGlnbi5FTkRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgcG9zaXRpb25DZW50ZXI6IElneFRleHRBbGlnbjtcbiAgICAgKiBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICogICAgIHRoaXMucG9zaXRpb25DZW50ZXIgPSBJZ3hUZXh0QWxpZ24uQ0VOVEVSO1xuICAgICAqIH1cbiAgICAgKiAgLy8uLi5cbiAgICAgKiBgYGBcbiAgICAgKiAgYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciB0eXBlPVwid2FybmluZ1wiIFt0ZXh0XT1cIidDdXN0b20gdGV4dCdcIiBbdGV4dEFsaWduXT1cInBvc2l0aW9uQ2VudGVyXCIgW3N0cmlwZWRdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dEFsaWduOiBJZ3hUZXh0QWxpZ24gPSBJZ3hUZXh0QWxpZ24uU1RBUlQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRleHQgdG8gYmUgdmlzaWJsZS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtbGluZWFyLWJhciB0eXBlPVwiZGVmYXVsdFwiIFt0ZXh0VmlzaWJpbGl0eV09XCJmYWxzZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIHRleHRWaXNpYmlsaXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gdGhhdCBkZWZpbmVzIGlmIHRoZSB0ZXh0IHNob3VsZCBiZSBhbGlnbmVkIGFib3ZlIHRoZSBwcm9ncmVzcyBsaW5lLiBCeSBkZWZhdWx0IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtbGluZWFyLWJhciB0eXBlPVwiZXJyb3JcIiBbdGV4dFRvcF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgICBwdWJsaWMgdGV4dFRvcCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY3VzdG9tIHRleHQgdGhhdCBpcyBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvIHRoZSBkZWZpbmVkIHBvc2l0aW9uLlxuICAgICAqICBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIHR5cGU9XCJ3YXJuaW5nXCIgW3RleHRdPVwiJ0N1c3RvbSB0ZXh0J1wiIFt0ZXh0QWxpZ25dPVwicG9zaXRpb25DZW50ZXJcIiBbc3RyaXBlZF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdHlwZSBvZiB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC4gUG9zc2libGUgb3B0aW9ucyAtIGBkZWZhdWx0YCwgYHN1Y2Nlc3NgLCBgaW5mb2AsIGB3YXJuaW5nYCwgYW5kIGBlcnJvcmAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbc3RyaXBlZF09XCJmYWxzZVwiIFttYXhdPVwiMTAwXCIgW3ZhbHVlXT1cIjBcIiB0eXBlPVwiZXJyb3JcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHR5cGUgPSAnZGVmYXVsdCc7XG5cbiAgICBAVmlld0NoaWxkKCdpbmRpY2F0b3InLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByaXZhdGUgX3Byb2dyZXNzSW5kaWNhdG9yOiBFbGVtZW50UmVmO1xuXG4gICAgcHJpdmF0ZSBhbmltYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgd2lkdGg6ICcwJSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXItLWRhbmdlcicpXG4gICAgcHVibGljIGdldCBlcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4UHJvZ3Jlc3NUeXBlLkVSUk9SO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1pbmZvJylcbiAgICBwdWJsaWMgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5JTkZPO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS13YXJuaW5nJylcbiAgICBwdWJsaWMgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5XQVJOSU5HO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1zdWNjZXNzJylcbiAgICBwdWJsaWMgZ2V0IHN1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5TVUNDRVNTO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclByb2dyZXNzVHJhbnNpdGlvbihNSU5fVkFMVUUsIHRoaXMuX2luaXRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRJbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcnVuQW5pbWF0aW9uKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbiAmJiB0aGlzLl9hbmltYXRpb24ucGxheVN0YXRlICE9PSAnZmluaXNoZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZUluUGVyY2VudCA9IHRoaXMubWF4IDw9IDAgPyAwIDogdG9QZXJjZW50KHZhbHVlLCB0aGlzLm1heCk7XG5cbiAgICAgICAgY29uc3QgRlJBTUVTID0gW107XG4gICAgICAgIEZSQU1FU1swXSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuYW5pbWF0aW9uU3RhdGVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLndpZHRoID0gdmFsdWVJblBlcmNlbnQgKyAnJSc7XG4gICAgICAgIEZSQU1FU1sxXSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuYW5pbWF0aW9uU3RhdGVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSB0aGlzLl9wcm9ncmVzc0luZGljYXRvci5uYXRpdmVFbGVtZW50LmFuaW1hdGUoRlJBTUVTLCB7XG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlLW91dCcsXG4gICAgICAgICAgICBmaWxsOiAnZm9yd2FyZHMnLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuYW5pbWF0aW9uRHVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1jaXJjdWxhci1iYXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGVzL2NpcmN1bGFyLWJhci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbTmdUZW1wbGF0ZU91dGxldCwgTmdJZl1cbn0pXG5leHBvcnQgY2xhc3MgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIEJhc2VQcm9ncmVzc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtY2lyY3VsYXItYmFyJztcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW2lkXT1cIidpZ3gtY2lyY3VsYXItYmFyLTU1J1wiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1jaXJjdWxhci1iYXItJHtORVhUX0NJUkNVTEFSX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXItLWluZGV0ZXJtaW5hdGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBpc0luZGV0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGV4dCB2aXNpYmlsaXR5LiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbdGV4dFZpc2liaWxpdHldPVwiZmFsc2VcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIHRleHRWaXNpYmlsaXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQgaW5zaWRlIHRoZSBgaWd4Q2lyY3VsYXJCYXJgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciB0ZXh0PVwiUHJvZ3Jlc3NcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB0ZXh0ID0gdGhpcy5jaXJjdWxhckJhci50ZXh0O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHQ6IHN0cmluZztcblxuICAgIEBDb250ZW50Q2hpbGQoSWd4UHJvZ3Jlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4UHJvZ3Jlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgdGV4dFRlbXBsYXRlOiBJZ3hQcm9ncmVzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIEBDb250ZW50Q2hpbGQoSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZSwgeyByZWFkOiBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlIH0pXG4gICAgcHVibGljIGdyYWRpZW50VGVtcGxhdGU6IElneFByb2dyZXNzQmFyR3JhZGllbnREaXJlY3RpdmU7XG5cbiAgICBAVmlld0NoaWxkKCdjaXJjbGUnLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByaXZhdGUgX3N2Z0NpcmNsZTogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JhZGllbnRJZCA9IGBpZ3gtY2lyY3VsYXItZ3JhZGllbnQtJHtORVhUX0dSQURJRU5UX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNvbnRleHQoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRpbXBsaWNpdDogeyB2YWx1ZTogdGhpcy52YWx1ZSwgdmFsdWVJblBlcmNlbnQ6IHRoaXMudmFsdWVJblBlcmNlbnQsIG1heDogdGhpcy5tYXggfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NpcmNsZVJhZGl1cyA9IDQ2O1xuICAgIHByaXZhdGUgX2NpcmN1bWZlcmVuY2UgPSAyICogTWF0aC5QSSAqIHRoaXMuX2NpcmNsZVJhZGl1cztcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgU1RST0tFX09QQUNJVFlfRFZJREVSID0gMTAwO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgU1RST0tFX09QQUNJVFlfQURESVRJT04gPSAuMjtcblxuICAgIHByaXZhdGUgYW5pbWF0aW9uU3RhdGUgPSB7XG4gICAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IDI4OSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogMVxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgX2RpcmVjdGlvbmFsaXR5OiBJZ3hEaXJlY3Rpb25hbGl0eSkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclByb2dyZXNzVHJhbnNpdGlvbihNSU5fVkFMVUUsIHRoaXMuX2luaXRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRJbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICAgICAgdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICAnc3Ryb2tlJyxcbiAgICAgICAgICAgIGB1cmwoIyR7dGhpcy5ncmFkaWVudElkfSlgXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdGV4dENvbnRlbnQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG5cbiAgICBwdWJsaWMgcnVuQW5pbWF0aW9uKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbiAmJiB0aGlzLl9hbmltYXRpb24ucGxheVN0YXRlICE9PSAnZmluaXNoZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZUluUGVyY2VudCA9IHRoaXMubWF4IDw9IDAgPyAwIDogdG9QZXJjZW50KHZhbHVlLCB0aGlzLm1heCk7XG5cbiAgICAgICAgY29uc3QgRlJBTUVTID0gW107XG4gICAgICAgIEZSQU1FU1swXSA9IHsgLi4udGhpcy5hbmltYXRpb25TdGF0ZSB9O1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuc3Ryb2tlRGFzaG9mZnNldCA9IHRoaXMuZ2V0UHJvZ3Jlc3ModmFsdWVJblBlcmNlbnQpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnN0cm9rZU9wYWNpdHkgPSB0b1BlcmNlbnQodmFsdWUsIHRoaXMubWF4KSAvIHRoaXMuU1RST0tFX09QQUNJVFlfRFZJREVSICsgdGhpcy5TVFJPS0VfT1BBQ0lUWV9BRERJVElPTjtcblxuICAgICAgICBGUkFNRVNbMV0gPSB7XG4gICAgICAgICAgICAuLi50aGlzLmFuaW1hdGlvblN0YXRlXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQuYW5pbWF0ZShGUkFNRVMsIHtcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2Utb3V0JyxcbiAgICAgICAgICAgIGZpbGw6ICdmb3J3YXJkcycsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFByb2dyZXNzKHBlcmNlbnRhZ2U6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uYWxpdHkucnRsID9cbiAgICAgICAgICAgIHRoaXMuX2NpcmN1bWZlcmVuY2UgKyAocGVyY2VudGFnZSAqIHRoaXMuX2NpcmN1bWZlcmVuY2UgLyAxMDApIDpcbiAgICAgICAgICAgIHRoaXMuX2NpcmN1bWZlcmVuY2UgLSAocGVyY2VudGFnZSAqIHRoaXMuX2NpcmN1bWZlcmVuY2UgLyAxMDApO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IHZhbHVlSW5SYW5nZSA9ICh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlciwgbWluID0gMCk6IG51bWJlciA9PiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcblxuZXhwb3J0IGNvbnN0IHRvUGVyY2VudCA9ICh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlcikgPT4gIW1heCA/IDAgOiBNYXRoLmZsb29yKDEwMCAqIHZhbHVlIC8gbWF4KTtcblxuZXhwb3J0IGNvbnN0IHRvVmFsdWUgPSAodmFsdWU6IG51bWJlciwgbWF4OiBudW1iZXIpID0+IG1heCAqIHZhbHVlIC8gMTAwO1xuXG5cbiIsIjxkaXYgY2xhc3M9XCJpZ3gtbGluZWFyLWJhcl9fYmFzZVwiPlxuICAgIDxkaXYgI2luZGljYXRvciBjbGFzcz1cImlneC1saW5lYXItYmFyX19pbmRpY2F0b3JcIiBbc3R5bGUud2lkdGhdPVwiMFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtbGluZWFyLWJhcl9faW5kaWNhdG9yLXNlY29uZGFyeVwiPjwvZGl2PlxuPC9kaXY+XG5cbjxzcGFuXG4gICAgY2xhc3M9XCJpZ3gtbGluZWFyLWJhcl9fdmFsdWVcIlxuICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgJ2lneC1saW5lYXItYmFyX192YWx1ZS0tc3RhcnQnOiB0ZXh0QWxpZ24gPT09ICdzdGFydCcsXG4gICAgICAgICdpZ3gtbGluZWFyLWJhcl9fdmFsdWUtLWNlbnRlcic6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcicsXG4gICAgICAgICdpZ3gtbGluZWFyLWJhcl9fdmFsdWUtLWVuZCc6IHRleHRBbGlnbiA9PT0gJ2VuZCcsXG4gICAgICAgICdpZ3gtbGluZWFyLWJhcl9fdmFsdWUtLXRvcCc6IHRleHRUb3AsXG4gICAgICAgICdpZ3gtbGluZWFyLWJhcl9fdmFsdWUtLWhpZGRlbic6ICF0ZXh0VmlzaWJpbGl0eVxuICAgIH1cIj5cbiAgICAgICAge3t0ZXh0ID8gdGV4dCA6IHZhbHVlSW5QZXJjZW50ICsgJyUnfX1cbjwvc3Bhbj5cbiIsIjxzdmcgI3N2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgdmVyc2lvbj1cIjEuMVwiXG4gICAgdmlld0JveD1cIjAgMCAxMDAgMTAwXCJcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiXG4gICAgcm9sZT1cInByb2dyZXNzYmFyXCJcbiAgICBhcmlhLXZhbHVlbWluPVwiMFwiXG4gICAgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJtYXhcIlxuICAgIFthdHRyLmFyaWEtdmFsdWVub3ddPVwidmFsdWVcIj5cbiAgICA8c3ZnOmNpcmNsZSBjbGFzcz1cImlneC1jaXJjdWxhci1iYXJfX2lubmVyXCIgY3g9XCI1MFwiIGN5PVwiNTBcIiByPVwiNDZcIiAvPlxuICAgIDxzdmc6Y2lyY2xlICNjaXJjbGUgY2xhc3M9XCJpZ3gtY2lyY3VsYXItYmFyX19vdXRlclwiIGN4PVwiNTBcIiBjeT1cIjUwXCIgcj1cIjQ2XCIgLz5cblxuICAgIDxzdmc6ZGVmcz5cbiAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJncmFkaWVudFRlbXBsYXRlID8gZ3JhZGllbnRUZW1wbGF0ZS50ZW1wbGF0ZSA6IGRlZmF1bHRHcmFkaWVudFRlbXBsYXRlO1xuICAgICAgICAgICAgY29udGV4dDogeyAkaW1wbGljaXQ6IGdyYWRpZW50SWQgfVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L3N2ZzpkZWZzPlxuXG4gICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0R3JhZGllbnRUZW1wbGF0ZT5cbiAgICAgICAgPHN2ZzpsaW5lYXJHcmFkaWVudCBbaWRdPVwiZ3JhZGllbnRJZFwiIGdyYWRpZW50VHJhbnNmb3JtPVwicm90YXRlKDkwKVwiPlxuICAgICAgICAgIDxzdG9wIG9mZnNldD1cIjAlXCIgICBjbGFzcz1cImlneC1jaXJjdWxhci1iYXJfX2dyYWRpZW50LXN0YXJ0XCIgLz5cbiAgICAgICAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgY2xhc3M9XCJpZ3gtY2lyY3VsYXItYmFyX19ncmFkaWVudC1lbmRcIiAvPlxuICAgICAgICA8L3N2ZzpsaW5lYXJHcmFkaWVudD5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9zdmc+XG5cbjxzcGFuIGNsYXNzPVwiaWd4LWNpcmN1bGFyLWJhcl9fdGV4dFwiICpuZ0lmPVwidGV4dFZpc2liaWxpdHlcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwidGV4dFRlbXBsYXRlID8gdGV4dFRlbXBsYXRlLnRlbXBsYXRlIDogZGVmYXVsdFRleHRUZW1wbGF0ZTtcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvc3Bhbj5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0VGV4dFRlbXBsYXRlPlxuICAgIHt7dGV4dENvbnRlbnQgPyB0ZXh0Q29udGVudDogdmFsdWVJblBlcmNlbnQgKyAnJSd9fVxuPC9uZy10ZW1wbGF0ZT5cblxuIl19