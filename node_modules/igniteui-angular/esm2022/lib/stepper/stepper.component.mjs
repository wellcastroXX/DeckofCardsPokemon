import { useAnimation } from '@angular/animations';
import { NgIf, NgTemplateOutlet, NgFor } from '@angular/common';
import { Component, ContentChild, ContentChildren, EventEmitter, HostBinding, Inject, Input, Output, TemplateRef, booleanAttribute } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { IgxCarouselComponentBase } from '../carousel/carousel-base';
import { IgxAngularAnimationService } from '../services/animation/angular-animation-service';
import { IgxStepComponent } from './step/step.component';
import { IgxStepperOrientation, IgxStepperTitlePosition, IgxStepType, IGX_STEPPER_COMPONENT, VerticalAnimationType } from './stepper.common';
import { IgxStepActiveIndicatorDirective, IgxStepCompletedIndicatorDirective, IgxStepInvalidIndicatorDirective } from './stepper.directive';
import { IgxStepperService } from './stepper.service';
import { fadeIn, growVerIn, growVerOut } from 'igniteui-angular/animations';
import * as i0 from "@angular/core";
import * as i1 from "./stepper.service";
// TODO: common interface between IgxCarouselComponentBase and ToggleAnimationPlayer?
/**
 * IgxStepper provides a wizard-like workflow by dividing content into logical steps.
 *
 * @igxModule IgxStepperModule
 *
 * @igxKeywords stepper
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI for Angular Stepper component allows the user to navigate between multiple steps.
 * It supports horizontal and vertical orientation as well as keyboard navigation and provides API methods to control the active step.
 * The component offers keyboard navigation and API to control the active step.
 *
 * @example
 * ```html
 * <igx-stepper>
 *  <igx-step [active]="true">
 *      <igx-icon igxStepIndicator>home</igx-icon>
 *      <p igxStepTitle>Home</p>
 *      <div igxStepContent>
 *         ...
 *      </div>
 *  </igx-step>
 *  <igx-step [optional]="true">
 *      <div igxStepContent>
 *          ...
 *      </div>
 *  </igx-step>
 *  <igx-step>
 *      <div igxStepContent>
 *          ...
 *      </div>
 *  </igx-step>
 * </igx-stepper>
 * ```
 */
export class IgxStepperComponent extends IgxCarouselComponentBase {
    /**
     * Get/Set the animation type of the stepper when the orientation direction is vertical.
     *
     * @remarks
     * Default value is `grow`. Other possible values are `fade` and `none`.
     *
     * ```html
     * <igx-stepper verticalAnimationType="none">
     * <igx-stepper>
     * ```
     */
    get verticalAnimationType() {
        return this._verticalAnimationType;
    }
    set verticalAnimationType(value) {
        // TODO: activeChange event is not emitted for the collapsing steps (loop through collapsing steps and emit)
        this.stepperService.collapsingSteps.clear();
        this._verticalAnimationType = value;
        switch (value) {
            case 'grow':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(growVerIn, growVerOut);
                break;
            case 'fade':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(fadeIn, null);
                break;
            case 'none':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(null, null);
                break;
        }
    }
    /**
     * Get/Set the animation type of the stepper when the orientation direction is horizontal.
     *
     * @remarks
     * Default value is `grow`. Other possible values are `fade` and `none`.
     *
     * ```html
     * <igx-stepper animationType="none">
     * <igx-stepper>
     * ```
     */
    get horizontalAnimationType() {
        return this.animationType;
    }
    set horizontalAnimationType(value) {
        // TODO: activeChange event is not emitted for the collapsing steps (loop through collapsing steps and emit)
        this.stepperService.collapsingSteps.clear();
        this.animationType = value;
    }
    /**
     * Get/Set the animation duration.
     * ```html
     * <igx-stepper [animationDuration]="500">
     * <igx-stepper>
     * ```
     */
    get animationDuration() {
        return this.defaultAnimationDuration;
    }
    set animationDuration(value) {
        if (value && value > 0) {
            this.defaultAnimationDuration = value;
            return;
        }
        this.defaultAnimationDuration = this._defaultAnimationDuration;
    }
    /**
     * Get/Set whether the stepper is linear.
     *
     * @remarks
     * If the stepper is in linear mode and if the active step is valid only then the user is able to move forward.
     *
     * ```html
     * <igx-stepper [linear]="true"></igx-stepper>
     * ```
     */
    get linear() {
        return this._linear;
    }
    set linear(value) {
        this._linear = value;
        if (this._linear && this.steps.length > 0) {
            // when the stepper is in linear mode we should calculate which steps should be disabled
            // and which are visited i.e. their validity should be correctly displayed.
            this.stepperService.calculateVisitedSteps();
            this.stepperService.calculateLinearDisabledSteps();
        }
        else {
            this.stepperService.linearDisabledSteps.clear();
        }
    }
    /**
     * Get/Set the stepper orientation.
     *
     * ```typescript
     * this.stepper.orientation = IgxStepperOrientation.Vertical;
     * ```
     */
    get orientation() {
        return this._orientation;
    }
    set orientation(value) {
        if (this._orientation === value) {
            return;
        }
        // TODO: activeChange event is not emitted for the collapsing steps
        this.stepperService.collapsingSteps.clear();
        this._orientation = value;
        this._defaultTitlePosition = this._orientation === IgxStepperOrientation.Horizontal ?
            IgxStepperTitlePosition.Bottom : IgxStepperTitlePosition.End;
    }
    /** @hidden @internal **/
    get directionClass() {
        return this.orientation === IgxStepperOrientation.Horizontal;
    }
    /**
     * Get all steps.
     *
     * ```typescript
     * const steps: IgxStepComponent[] = this.stepper.steps;
     * ```
     */
    get steps() {
        return this._steps?.toArray() || [];
    }
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    constructor(cdr, animationService, stepperService, element) {
        super(animationService, cdr);
        this.stepperService = stepperService;
        this.element = element;
        /**
         * Get/Set the type of the steps.
         *
         * ```typescript
         * this.stepper.stepType = IgxStepType.Indicator;
         * ```
         */
        this.stepType = IgxStepType.Full;
        /**
         * Get/Set whether the content is displayed above the steps.
         *
         * @remarks
         * Default value is `false` and the content is below the steps.
         *
         * ```typescript
         * this.stepper.contentTop = true;
         * ```
         */
        this.contentTop = false;
        /**
         * Get/Set the position of the steps title.
         *
         * @remarks
         * The default value when the stepper is horizontally orientated is `bottom`.
         * In vertical layout the default title position is `end`.
         *
         * ```typescript
         * this.stepper.titlePosition = IgxStepperTitlePosition.Top;
         * ```
         */
        this.titlePosition = null;
        /** @hidden @internal **/
        this.cssClass = 'igx-stepper';
        /** @hidden @internal **/
        this.role = 'tablist';
        /**
         * Emitted when the stepper's active step is changing.
         *
         *```html
         * <igx-stepper (activeStepChanging)="handleActiveStepChanging($event)">
         * </igx-stepper>
         * ```
         *
         *```typescript
         * public handleActiveStepChanging(event: IStepChangingEventArgs) {
         *  if (event.newIndex < event.oldIndex) {
         *      event.cancel = true;
         *  }
         * }
         *```
         */
        this.activeStepChanging = new EventEmitter();
        /**
         * Emitted when the active step is changed.
         *
         * @example
         * ```
         * <igx-stepper (activeStepChanged)="handleActiveStepChanged($event)"></igx-stepper>
         * ```
         */
        this.activeStepChanged = new EventEmitter();
        /** @hidden @internal */
        this.verticalAnimationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut,
        };
        /** @hidden @internal */
        this._defaultTitlePosition = IgxStepperTitlePosition.Bottom;
        this.destroy$ = new Subject();
        this._orientation = IgxStepperOrientation.Horizontal;
        this._verticalAnimationType = VerticalAnimationType.Grow;
        this._linear = false;
        this._defaultAnimationDuration = 350;
        this.stepperService.stepper = this;
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['animationDuration']) {
            this.verticalAnimationType = this._verticalAnimationType;
        }
    }
    /** @hidden @internal */
    ngOnInit() {
        this.enterAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.activeStepChanged.emit({ owner: this, index: this.stepperService.activeStep.index });
        });
        this.leaveAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.stepperService.collapsingSteps.size === 1) {
                this.stepperService.collapse(this.stepperService.previousActiveStep);
            }
            else {
                Array.from(this.stepperService.collapsingSteps).slice(0, this.stepperService.collapsingSteps.size - 1)
                    .forEach(step => this.stepperService.collapse(step));
            }
        });
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        let activeStep;
        this.steps.forEach((step, index) => {
            this.updateStepAria(step, index);
            if (!activeStep && step.active) {
                activeStep = step;
            }
        });
        if (!activeStep) {
            this.activateFirstStep(true);
        }
        if (this.linear) {
            this.stepperService.calculateLinearDisabledSteps();
        }
        this.handleStepChanges();
    }
    /** @hidden @internal */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Activates the step at a given index.
     *
     *```typescript
     * this.stepper.navigateTo(1);
     *```
     */
    navigateTo(index) {
        const step = this.steps[index];
        if (!step || this.stepperService.activeStep === step) {
            return;
        }
        this.activateStep(step);
    }
    /**
     * Activates the next enabled step.
     *
     *```typescript
     * this.stepper.next();
     *```
     */
    next() {
        this.moveToNextStep();
    }
    /**
     * Activates the previous enabled step.
     *
     *```typescript
     * this.stepper.prev();
     *```
     */
    prev() {
        this.moveToNextStep(false);
    }
    /**
     * Resets the stepper to its initial state i.e. activates the first step.
     *
     * @remarks
     * The steps' content will not be automatically reset.
     *```typescript
     * this.stepper.reset();
     *```
     */
    reset() {
        this.stepperService.visitedSteps.clear();
        const activeStep = this.steps.find(s => !s.disabled);
        if (activeStep) {
            this.activateStep(activeStep);
        }
    }
    /** @hidden @internal */
    playHorizontalAnimations() {
        this.previousItem = this.stepperService.previousActiveStep;
        this.currentItem = this.stepperService.activeStep;
        this.triggerAnimations();
    }
    getPreviousElement() {
        return this.stepperService.previousActiveStep?.contentContainer.nativeElement;
    }
    getCurrentElement() {
        return this.stepperService.activeStep.contentContainer.nativeElement;
    }
    updateVerticalAnimationSettings(openAnimation, closeAnimation) {
        const customCloseAnimation = useAnimation(closeAnimation, {
            params: {
                duration: this.animationDuration + 'ms'
            }
        });
        const customOpenAnimation = useAnimation(openAnimation, {
            params: {
                duration: this.animationDuration + 'ms'
            }
        });
        return {
            openAnimation: openAnimation ? customOpenAnimation : null,
            closeAnimation: closeAnimation ? customCloseAnimation : null
        };
    }
    updateStepAria(step, index) {
        step._index = index;
        step.renderer.setAttribute(step.nativeElement, 'aria-setsize', (this.steps.length).toString());
        step.renderer.setAttribute(step.nativeElement, 'aria-posinset', (index + 1).toString());
    }
    handleStepChanges() {
        this._steps.changes.pipe(takeUntil(this.destroy$)).subscribe(steps => {
            Promise.resolve().then(() => {
                steps.forEach((step, index) => {
                    this.updateStepAria(step, index);
                });
                // when the active step is removed
                const hasActiveStep = this.steps.find(s => s === this.stepperService.activeStep);
                if (!hasActiveStep) {
                    this.activateFirstStep();
                }
                // TO DO: mark step added before the active as visited?
                if (this.linear) {
                    this.stepperService.calculateLinearDisabledSteps();
                }
            });
        });
    }
    activateFirstStep(activateInitially = false) {
        const firstEnabledStep = this.steps.find(s => !s.disabled);
        if (firstEnabledStep) {
            firstEnabledStep.active = true;
            if (activateInitially) {
                firstEnabledStep.activeChange.emit(true);
                this.activeStepChanged.emit({ owner: this, index: firstEnabledStep.index });
            }
        }
    }
    activateStep(step) {
        if (this.orientation === IgxStepperOrientation.Horizontal) {
            step.changeHorizontalActiveStep();
        }
        else {
            this.stepperService.expand(step);
        }
    }
    moveToNextStep(next = true) {
        let steps = this.steps;
        let activeStepIndex = this.stepperService.activeStep.index;
        if (!next) {
            steps = this.steps.reverse();
            activeStepIndex = steps.findIndex(s => s === this.stepperService.activeStep);
        }
        const nextStep = steps.find((s, i) => i > activeStepIndex && s.isAccessible);
        if (nextStep) {
            this.activateStep(nextStep);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxStepperComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: IgxAngularAnimationService }, { token: i1.IgxStepperService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.2.4", type: IgxStepperComponent, isStandalone: true, selector: "igx-stepper", inputs: { verticalAnimationType: "verticalAnimationType", horizontalAnimationType: "horizontalAnimationType", animationDuration: "animationDuration", linear: ["linear", "linear", booleanAttribute], orientation: "orientation", stepType: "stepType", contentTop: ["contentTop", "contentTop", booleanAttribute], titlePosition: "titlePosition" }, outputs: { activeStepChanging: "activeStepChanging", activeStepChanged: "activeStepChanged" }, host: { properties: { "attr.aria-orientation": "this.orientation", "class.igx-stepper": "this.cssClass", "attr.role": "this.role", "class.igx-stepper--horizontal": "this.directionClass" } }, providers: [
            IgxStepperService,
            { provide: IGX_STEPPER_COMPONENT, useExisting: IgxStepperComponent },
        ], queries: [{ propertyName: "invalidIndicatorTemplate", first: true, predicate: IgxStepInvalidIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "completedIndicatorTemplate", first: true, predicate: IgxStepCompletedIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "activeIndicatorTemplate", first: true, predicate: IgxStepActiveIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "_steps", predicate: IgxStepComponent }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"!contentTop || orientation !== 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<div *ngIf=\"orientation === 'horizontal'\" class=\"igx-stepper__body\">\n    <ng-container *ngFor=\"let step of steps\">\n        <ng-container *ngTemplateOutlet=\"step.contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<div *ngIf=\"contentTop && orientation === 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<ng-template #stepTemplate>\n    <ng-content select=\"igx-step\"></ng-content>\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxStepperComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-stepper', providers: [
                        IgxStepperService,
                        { provide: IGX_STEPPER_COMPONENT, useExisting: IgxStepperComponent },
                    ], standalone: true, imports: [NgIf, NgTemplateOutlet, NgFor], template: "<div *ngIf=\"!contentTop || orientation !== 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<div *ngIf=\"orientation === 'horizontal'\" class=\"igx-stepper__body\">\n    <ng-container *ngFor=\"let step of steps\">\n        <ng-container *ngTemplateOutlet=\"step.contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<div *ngIf=\"contentTop && orientation === 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<ng-template #stepTemplate>\n    <ng-content select=\"igx-step\"></ng-content>\n</ng-template>\n" }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i1.IgxStepperService }, { type: i0.ElementRef }], propDecorators: { verticalAnimationType: [{
                type: Input
            }], horizontalAnimationType: [{
                type: Input
            }], animationDuration: [{
                type: Input
            }], linear: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], orientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }, {
                type: Input
            }], stepType: [{
                type: Input
            }], contentTop: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], titlePosition: [{
                type: Input
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-stepper']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], directionClass: [{
                type: HostBinding,
                args: ['class.igx-stepper--horizontal']
            }], activeStepChanging: [{
                type: Output
            }], activeStepChanged: [{
                type: Output
            }], invalidIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepInvalidIndicatorDirective, { read: TemplateRef }]
            }], completedIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepCompletedIndicatorDirective, { read: TemplateRef }]
            }], activeIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepActiveIndicatorDirective, { read: TemplateRef }]
            }], _steps: [{
                type: ContentChildren,
                args: [IgxStepComponent, { descendants: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc3RlcHBlci9zdGVwcGVyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zdGVwcGVyL3N0ZXBwZXIuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUE4QixZQUFZLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMvRSxPQUFPLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLEtBQUssRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hFLE9BQU8sRUFDa0MsU0FBUyxFQUFFLFlBQVksRUFBRSxlQUFlLEVBQ2pFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFDNUMsTUFBTSxFQUE0QixXQUFXLEVBQUUsZ0JBQWdCLEVBQzFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBR3JFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLGlEQUFpRCxDQUFDO0FBRTdGLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3pELE9BQU8sRUFDUyxxQkFBcUIsRUFBRSx1QkFBdUIsRUFBRSxXQUFXLEVBQ3ZFLHFCQUFxQixFQUFpRCxxQkFBcUIsRUFDOUYsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBQ0gsK0JBQStCLEVBQy9CLGtDQUFrQyxFQUNsQyxnQ0FBZ0MsRUFDbkMsTUFBTSxxQkFBcUIsQ0FBQztBQUM3QixPQUFPLEVB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QUFNO2dCQVlBLGlCQUFpQjtzQkFEdkIsTUFBTTtnQkFLQSx3QkFBd0I7c0JBRDlCLFlBQVk7dUJBQUMsZ0NBQWdDLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO2dCQUs5RCwwQkFBMEI7c0JBRGhDLFlBQVk7dUJBQUMsa0NBQWtDLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO2dCQUtoRSx1QkFBdUI7c0JBRDdCLFlBQVk7dUJBQUMsK0JBQStCLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO2dCQUs1RCxNQUFNO3NCQURiLGVBQWU7dUJBQUMsZ0JBQWdCLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5pbWF0aW9uUmVmZXJlbmNlTWV0YWRhdGEsIHVzZUFuaW1hdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgTmdJZiwgTmdUZW1wbGF0ZU91dGxldCwgTmdGb3IgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSxcbiAgICBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0LCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZiwgYm9vbGVhbkF0dHJpYnV0ZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneENhcm91c2VsQ29tcG9uZW50QmFzZSB9IGZyb20gJy4uL2Nhcm91c2VsL2Nhcm91c2VsLWJhc2UnO1xuXG5pbXBvcnQgeyBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyB9IGZyb20gJy4uL2V4cGFuc2lvbi1wYW5lbC90b2dnbGUtYW5pbWF0aW9uLWNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hBbmd1bGFyQW5pbWF0aW9uU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2FuaW1hdGlvbi9hbmd1bGFyLWFuaW1hdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IEFuaW1hdGlvblNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9hbmltYXRpb24vYW5pbWF0aW9uJztcbmltcG9ydCB7IElneFN0ZXBDb21wb25lbnQgfSBmcm9tICcuL3N0ZXAvc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBJZ3hTdGVwcGVyLCBJZ3hTdGVwcGVyT3JpZW50YXRpb24sIElneFN0ZXBwZXJUaXRsZVBvc2l0aW9uLCBJZ3hTdGVwVHlwZSxcbiAgICBJR1hfU1RFUFBFUl9DT01QT05FTlQsIElTdGVwQ2hhbmdlZEV2ZW50QXJncywgSVN0ZXBDaGFuZ2luZ0V2ZW50QXJncywgVmVydGljYWxBbmltYXRpb25UeXBlXG59IGZyb20gJy4vc3RlcHBlci5jb21tb24nO1xuaW1wb3J0IHtcbiAgICBJZ3hTdGVwQWN0aXZlSW5kaWNhdG9yRGlyZWN0aXZlLFxuICAgIElneFN0ZXBDb21wbGV0ZWRJbmRpY2F0b3JEaXJlY3RpdmUsXG4gICAgSWd4U3RlcEludmFsaWRJbmRpY2F0b3JEaXJlY3RpdmVcbn0gZnJvbSAnLi9zdGVwcGVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hTdGVwcGVyU2VydmljZSB9IGZyb20gJy4vc3RlcHBlci5zZXJ2aWNlJztcbmltcG9ydCB7IGZhZGVJbiwgZ3Jvd1ZlckluLCBncm93VmVyT3V0IH0gZnJvbSAnaWduaXRldWktYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEhvcml6b250YWxBbmltYXRpb25UeXBlIH0gZnJvbSAnLi4vY2Fyb3VzZWwvZW51bXMnO1xuXG5cbi8vIFRPRE86IGNvbW1vbiBpbnRlcmZhY2UgYmV0d2VlbiBJZ3hDYXJvdXNlbENvbXBvbmVudEJhc2UgYW5kIFRvZ2dsZUFuaW1hdGlvblBsYXllcj9cblxuLyoqXG4gKiBJZ3hTdGVwcGVyIHByb3ZpZGVzIGEgd2l6YXJkLWxpa2Ugd29ya2Zsb3cgYnkgZGl2aWRpbmcgY29udGVudCBpbnRvIGxvZ2ljYWwgc3RlcHMuXG4gKlxuICogQGlneE1vZHVsZSBJZ3hTdGVwcGVyTW9kdWxlXG4gKlxuICogQGlneEtleXdvcmRzIHN0ZXBwZXJcbiAqXG4gKiBAaWd4R3JvdXAgTGF5b3V0c1xuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgSWduaXRlIFVJIGZvciBBbmd1bGFyIFN0ZXBwZXIgY29tcG9uZW50IGFsbG93cyB0aGUgdXNlciB0byBuYXZpZ2F0ZSBiZXR3ZWVuIG11bHRpcGxlIHN0ZXBzLlxuICogSXQgc3VwcG9ydHMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgb3JpZW50YXRpb24gYXMgd2VsbCBhcyBrZXlib2FyZCBuYXZpZ2F0aW9uIGFuZCBwcm92aWRlcyBBUEkgbWV0aG9kcyB0byBjb250cm9sIHRoZSBhY3RpdmUgc3RlcC5cbiAqIFRoZSBjb21wb25lbnQgb2ZmZXJzIGtleWJvYXJkIG5hdmlnYXRpb24gYW5kIEFQSSB0byBjb250cm9sIHRoZSBhY3RpdmUgc3RlcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1zdGVwcGVyPlxuICogIDxpZ3gtc3RlcCBbYWN0aXZlXT1cInRydWVcIj5cbiAqICAgICAgPGlneC1pY29uIGlneFN0ZXBJbmRpY2F0b3I+aG9tZTwvaWd4LWljb24+XG4gKiAgICAgIDxwIGlneFN0ZXBUaXRsZT5Ib21lPC9wPlxuICogICAgICA8ZGl2IGlneFN0ZXBDb250ZW50PlxuICogICAgICAgICAuLi5cbiAqICAgICAgPC9kaXY+XG4gKiAgPC9pZ3gtc3RlcD5cbiAqICA8aWd4LXN0ZXAgW29wdGlvbmFsXT1cInRydWVcIj5cbiAqICAgICAgPGRpdiBpZ3hTdGVwQ29udGVudD5cbiAqICAgICAgICAgIC4uLlxuICogICAgICA8L2Rpdj5cbiAqICA8L2lneC1zdGVwPlxuICogIDxpZ3gtc3RlcD5cbiAqICAgICAgPGRpdiBpZ3hTdGVwQ29udGVudD5cbiAqICAgICAgICAgIC4uLlxuICogICAgICA8L2Rpdj5cbiAqICA8L2lneC1zdGVwPlxuICogPC9pZ3gtc3RlcHBlcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1zdGVwcGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3N0ZXBwZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBJZ3hTdGVwcGVyU2VydmljZSxcbiAgICAgICAgeyBwcm92aWRlOiBJR1hfU1RFUFBFUl9DT01QT05FTlQsIHVzZUV4aXN0aW5nOiBJZ3hTdGVwcGVyQ29tcG9uZW50IH0sXG4gICAgXSxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtOZ0lmLCBOZ1RlbXBsYXRlT3V0bGV0LCBOZ0Zvcl1cbn0pXG5leHBvcnQgY2xhc3MgSWd4U3RlcHBlckNvbXBvbmVudCBleHRlbmRzIElneENhcm91c2VsQ29tcG9uZW50QmFzZSBpbXBsZW1lbnRzIElneFN0ZXBwZXIsIE9uQ2hhbmdlcywgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqXG4gICAgICogR2V0L1NldCB0aGUgYW5pbWF0aW9uIHR5cGUgb2YgdGhlIHN0ZXBwZXIgd2hlbiB0aGUgb3JpZW50YXRpb24gZGlyZWN0aW9uIGlzIHZlcnRpY2FsLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBncm93YC4gT3RoZXIgcG9zc2libGUgdmFsdWVzIGFyZSBgZmFkZWAgYW5kIGBub25lYC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXN0ZXBwZXIgdmVydGljYWxBbmltYXRpb25UeXBlPVwibm9uZVwiPlxuICAgICAqIDxpZ3gtc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgdmVydGljYWxBbmltYXRpb25UeXBlKCk6IFZlcnRpY2FsQW5pbWF0aW9uVHlwZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJ0aWNhbEFuaW1hdGlvblR5cGU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCB2ZXJ0aWNhbEFuaW1hdGlvblR5cGUodmFsdWU6IFZlcnRpY2FsQW5pbWF0aW9uVHlwZSkge1xuICAgICAgICAvLyBUT0RPOiBhY3RpdmVDaGFuZ2UgZXZlbnQgaXMgbm90IGVtaXR0ZWQgZm9yIHRoZSBjb2xsYXBzaW5nIHN0ZXBzIChsb29wIHRocm91Z2ggY29sbGFwc2luZyBzdGVwcyBhbmQgZW1pdClcbiAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzaW5nU3RlcHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fdmVydGljYWxBbmltYXRpb25UeXBlID0gdmFsdWU7XG5cbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnZ3Jvdyc6XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzID0gdGhpcy51cGRhdGVWZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzKGdyb3dWZXJJbiwgZ3Jvd1Zlck91dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmYWRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3MgPSB0aGlzLnVwZGF0ZVZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3MoZmFkZUluLCBudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljYWxBbmltYXRpb25TZXR0aW5ncyA9IHRoaXMudXBkYXRlVmVydGljYWxBbmltYXRpb25TZXR0aW5ncyhudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgdGhlIGFuaW1hdGlvbiB0eXBlIG9mIHRoZSBzdGVwcGVyIHdoZW4gdGhlIG9yaWVudGF0aW9uIGRpcmVjdGlvbiBpcyBob3Jpem9udGFsLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBncm93YC4gT3RoZXIgcG9zc2libGUgdmFsdWVzIGFyZSBgZmFkZWAgYW5kIGBub25lYC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXN0ZXBwZXIgYW5pbWF0aW9uVHlwZT1cIm5vbmVcIj5cbiAgICAgKiA8aWd4LXN0ZXBwZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGhvcml6b250YWxBbmltYXRpb25UeXBlKCk6IEhvcml6b250YWxBbmltYXRpb25UeXBlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uVHlwZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGhvcml6b250YWxBbmltYXRpb25UeXBlKHZhbHVlOiBIb3Jpem9udGFsQW5pbWF0aW9uVHlwZSkge1xuICAgICAgICAvLyBUT0RPOiBhY3RpdmVDaGFuZ2UgZXZlbnQgaXMgbm90IGVtaXR0ZWQgZm9yIHRoZSBjb2xsYXBzaW5nIHN0ZXBzIChsb29wIHRocm91Z2ggY29sbGFwc2luZyBzdGVwcyBhbmQgZW1pdClcbiAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzaW5nU3RlcHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25UeXBlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0L1NldCB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXN0ZXBwZXIgW2FuaW1hdGlvbkR1cmF0aW9uXT1cIjUwMFwiPlxuICAgICAqIDxpZ3gtc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgYW5pbWF0aW9uRHVyYXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgYW5pbWF0aW9uRHVyYXRpb24odmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBbmltYXRpb25EdXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmYXVsdEFuaW1hdGlvbkR1cmF0aW9uID0gdGhpcy5fZGVmYXVsdEFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgd2hldGhlciB0aGUgc3RlcHBlciBpcyBsaW5lYXIuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZSBzdGVwcGVyIGlzIGluIGxpbmVhciBtb2RlIGFuZCBpZiB0aGUgYWN0aXZlIHN0ZXAgaXMgdmFsaWQgb25seSB0aGVuIHRoZSB1c2VyIGlzIGFibGUgdG8gbW92ZSBmb3J3YXJkLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3RlcHBlciBbbGluZWFyXT1cInRydWVcIj48L2lneC1zdGVwcGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBnZXQgbGluZWFyKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZWFyO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgbGluZWFyKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2xpbmVhciA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fbGluZWFyICYmIHRoaXMuc3RlcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gd2hlbiB0aGUgc3RlcHBlciBpcyBpbiBsaW5lYXIgbW9kZSB3ZSBzaG91bGQgY2FsY3VsYXRlIHdoaWNoIHN0ZXBzIHNob3VsZCBiZSBkaXNhYmxlZFxuICAgICAgICAgICAgLy8gYW5kIHdoaWNoIGFyZSB2aXNpdGVkIGkuZS4gdGhlaXIgdmFsaWRpdHkgc2hvdWxkIGJlIGNvcnJlY3RseSBkaXNwbGF5ZWQuXG4gICAgICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNhbGN1bGF0ZVZpc2l0ZWRTdGVwcygpO1xuICAgICAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jYWxjdWxhdGVMaW5lYXJEaXNhYmxlZFN0ZXBzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmxpbmVhckRpc2FibGVkU3RlcHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgdGhlIHN0ZXBwZXIgb3JpZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLm9yaWVudGF0aW9uID0gSWd4U3RlcHBlck9yaWVudGF0aW9uLlZlcnRpY2FsO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLW9yaWVudGF0aW9uJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgb3JpZW50YXRpb24oKTogSWd4U3RlcHBlck9yaWVudGF0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgb3JpZW50YXRpb24odmFsdWU6IElneFN0ZXBwZXJPcmllbnRhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fb3JpZW50YXRpb24gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhY3RpdmVDaGFuZ2UgZXZlbnQgaXMgbm90IGVtaXR0ZWQgZm9yIHRoZSBjb2xsYXBzaW5nIHN0ZXBzXG4gICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY29sbGFwc2luZ1N0ZXBzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRUaXRsZVBvc2l0aW9uID0gdGhpcy5fb3JpZW50YXRpb24gPT09IElneFN0ZXBwZXJPcmllbnRhdGlvbi5Ib3Jpem9udGFsID9cbiAgICAgICAgICAgIElneFN0ZXBwZXJUaXRsZVBvc2l0aW9uLkJvdHRvbSA6IElneFN0ZXBwZXJUaXRsZVBvc2l0aW9uLkVuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHRoZSB0eXBlIG9mIHRoZSBzdGVwcy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnN0ZXBwZXIuc3RlcFR5cGUgPSBJZ3hTdGVwVHlwZS5JbmRpY2F0b3I7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3RlcFR5cGU6IElneFN0ZXBUeXBlID0gSWd4U3RlcFR5cGUuRnVsbDtcblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgd2hldGhlciB0aGUgY29udGVudCBpcyBkaXNwbGF5ZWQgYWJvdmUgdGhlIHN0ZXBzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAgYW5kIHRoZSBjb250ZW50IGlzIGJlbG93IHRoZSBzdGVwcy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnN0ZXBwZXIuY29udGVudFRvcCA9IHRydWU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIGNvbnRlbnRUb3AgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzdGVwcyB0aXRsZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgd2hlbiB0aGUgc3RlcHBlciBpcyBob3Jpem9udGFsbHkgb3JpZW50YXRlZCBpcyBgYm90dG9tYC5cbiAgICAgKiBJbiB2ZXJ0aWNhbCBsYXlvdXQgdGhlIGRlZmF1bHQgdGl0bGUgcG9zaXRpb24gaXMgYGVuZGAuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLnRpdGxlUG9zaXRpb24gPSBJZ3hTdGVwcGVyVGl0bGVQb3NpdGlvbi5Ub3A7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGl0bGVQb3NpdGlvbjogSWd4U3RlcHBlclRpdGxlUG9zaXRpb24gPSBudWxsO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICoqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXN0ZXBwZXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtc3RlcHBlcic7XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKiovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIHB1YmxpYyByb2xlID0gJ3RhYmxpc3QnO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICoqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXN0ZXBwZXItLWhvcml6b250YWwnKVxuICAgIHB1YmxpYyBnZXQgZGlyZWN0aW9uQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uID09PSBJZ3hTdGVwcGVyT3JpZW50YXRpb24uSG9yaXpvbnRhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIHN0ZXBwZXIncyBhY3RpdmUgc3RlcCBpcyBjaGFuZ2luZy5cbiAgICAgKlxuICAgICAqYGBgaHRtbFxuICAgICAqIDxpZ3gtc3RlcHBlciAoYWN0aXZlU3RlcENoYW5naW5nKT1cImhhbmRsZUFjdGl2ZVN0ZXBDaGFuZ2luZygkZXZlbnQpXCI+XG4gICAgICogPC9pZ3gtc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBoYW5kbGVBY3RpdmVTdGVwQ2hhbmdpbmcoZXZlbnQ6IElTdGVwQ2hhbmdpbmdFdmVudEFyZ3MpIHtcbiAgICAgKiAgaWYgKGV2ZW50Lm5ld0luZGV4IDwgZXZlbnQub2xkSW5kZXgpIHtcbiAgICAgKiAgICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7XG4gICAgICogIH1cbiAgICAgKiB9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgYWN0aXZlU3RlcENoYW5naW5nID0gbmV3IEV2ZW50RW1pdHRlcjxJU3RlcENoYW5naW5nRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBhY3RpdmUgc3RlcCBpcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiA8aWd4LXN0ZXBwZXIgKGFjdGl2ZVN0ZXBDaGFuZ2VkKT1cImhhbmRsZUFjdGl2ZVN0ZXBDaGFuZ2VkKCRldmVudClcIj48L2lneC1zdGVwcGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBhY3RpdmVTdGVwQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SVN0ZXBDaGFuZ2VkRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hTdGVwSW52YWxpZEluZGljYXRvckRpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgIHB1YmxpYyBpbnZhbGlkSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneFN0ZXBJbnZhbGlkSW5kaWNhdG9yRGlyZWN0aXZlPjtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4U3RlcENvbXBsZXRlZEluZGljYXRvckRpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgIHB1YmxpYyBjb21wbGV0ZWRJbmRpY2F0b3JUZW1wbGF0ZTogVGVtcGxhdGVSZWY8SWd4U3RlcENvbXBsZXRlZEluZGljYXRvckRpcmVjdGl2ZT47XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBAQ29udGVudENoaWxkKElneFN0ZXBBY3RpdmVJbmRpY2F0b3JEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICBwdWJsaWMgYWN0aXZlSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneFN0ZXBBY3RpdmVJbmRpY2F0b3JEaXJlY3RpdmU+O1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hTdGVwQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9KVxuICAgIHByaXZhdGUgX3N0ZXBzOiBRdWVyeUxpc3Q8SWd4U3RlcENvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHN0ZXBzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHN0ZXBzOiBJZ3hTdGVwQ29tcG9uZW50W10gPSB0aGlzLnN0ZXBwZXIuc3RlcHM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBzdGVwcygpOiBJZ3hTdGVwQ29tcG9uZW50W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcHM/LnRvQXJyYXkoKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0IG5hdGl2ZUVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIHZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3M6IFRvZ2dsZUFuaW1hdGlvblNldHRpbmdzID0ge1xuICAgICAgICBvcGVuQW5pbWF0aW9uOiBncm93VmVySW4sXG4gICAgICAgIGNsb3NlQW5pbWF0aW9uOiBncm93VmVyT3V0LFxuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIF9kZWZhdWx0VGl0bGVQb3NpdGlvbjogSWd4U3RlcHBlclRpdGxlUG9zaXRpb24gPSBJZ3hTdGVwcGVyVGl0bGVQb3NpdGlvbi5Cb3R0b207XG4gICAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgcHJpdmF0ZSBfb3JpZW50YXRpb246IElneFN0ZXBwZXJPcmllbnRhdGlvbiA9IElneFN0ZXBwZXJPcmllbnRhdGlvbi5Ib3Jpem9udGFsO1xuICAgIHByaXZhdGUgX3ZlcnRpY2FsQW5pbWF0aW9uVHlwZTogVmVydGljYWxBbmltYXRpb25UeXBlID0gVmVydGljYWxBbmltYXRpb25UeXBlLkdyb3c7XG4gICAgcHJpdmF0ZSBfbGluZWFyID0gZmFsc2U7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfZGVmYXVsdEFuaW1hdGlvbkR1cmF0aW9uID0gMzUwO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEBJbmplY3QoSWd4QW5ndWxhckFuaW1hdGlvblNlcnZpY2UpIGFuaW1hdGlvblNlcnZpY2U6IEFuaW1hdGlvblNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgc3RlcHBlclNlcnZpY2U6IElneFN0ZXBwZXJTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+KSB7XG4gICAgICAgIHN1cGVyKGFuaW1hdGlvblNlcnZpY2UsIGNkcik7XG4gICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2Uuc3RlcHBlciA9IHRoaXM7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2FuaW1hdGlvbkR1cmF0aW9uJ10pIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljYWxBbmltYXRpb25UeXBlID0gdGhpcy5fdmVydGljYWxBbmltYXRpb25UeXBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmVudGVyQW5pbWF0aW9uRG9uZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcENoYW5nZWQuZW1pdCh7IG93bmVyOiB0aGlzLCBpbmRleDogdGhpcy5zdGVwcGVyU2VydmljZS5hY3RpdmVTdGVwLmluZGV4IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sZWF2ZUFuaW1hdGlvbkRvbmUucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzaW5nU3RlcHMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY29sbGFwc2UodGhpcy5zdGVwcGVyU2VydmljZS5wcmV2aW91c0FjdGl2ZVN0ZXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuc3RlcHBlclNlcnZpY2UuY29sbGFwc2luZ1N0ZXBzKS5zbGljZSgwLCB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNpbmdTdGVwcy5zaXplIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goc3RlcCA9PiB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNlKHN0ZXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIGxldCBhY3RpdmVTdGVwO1xuICAgICAgICB0aGlzLnN0ZXBzLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0ZXBBcmlhKHN0ZXAsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICghYWN0aXZlU3RlcCAmJiBzdGVwLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVN0ZXAgPSBzdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFhY3RpdmVTdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlRmlyc3RTdGVwKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGluZWFyKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNhbGN1bGF0ZUxpbmVhckRpc2FibGVkU3RlcHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFuZGxlU3RlcENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBzdGVwIGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAgICpcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnN0ZXBwZXIubmF2aWdhdGVUbygxKTtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBuYXZpZ2F0ZVRvKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuc3RlcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIXN0ZXAgfHwgdGhpcy5zdGVwcGVyU2VydmljZS5hY3RpdmVTdGVwID09PSBzdGVwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmF0ZVN0ZXAoc3RlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBuZXh0IGVuYWJsZWQgc3RlcC5cbiAgICAgKlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci5uZXh0KCk7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tb3ZlVG9OZXh0U3RlcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB0aGUgcHJldmlvdXMgZW5hYmxlZCBzdGVwLlxuICAgICAqXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLnByZXYoKTtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBwcmV2KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vdmVUb05leHRTdGVwKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHN0ZXBwZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUgaS5lLiBhY3RpdmF0ZXMgdGhlIGZpcnN0IHN0ZXAuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBzdGVwcycgY29udGVudCB3aWxsIG5vdCBiZSBhdXRvbWF0aWNhbGx5IHJlc2V0LlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci5yZXNldCgpO1xuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLnZpc2l0ZWRTdGVwcy5jbGVhcigpO1xuICAgICAgICBjb25zdCBhY3RpdmVTdGVwID0gdGhpcy5zdGVwcy5maW5kKHMgPT4gIXMuZGlzYWJsZWQpO1xuICAgICAgICBpZiAoYWN0aXZlU3RlcCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVN0ZXAoYWN0aXZlU3RlcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgcGxheUhvcml6b250YWxBbmltYXRpb25zKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnByZXZpb3VzSXRlbSA9IHRoaXMuc3RlcHBlclNlcnZpY2UucHJldmlvdXNBY3RpdmVTdGVwO1xuICAgICAgICB0aGlzLmN1cnJlbnRJdGVtID0gdGhpcy5zdGVwcGVyU2VydmljZS5hY3RpdmVTdGVwO1xuICAgICAgICB0aGlzLnRyaWdnZXJBbmltYXRpb25zKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldFByZXZpb3VzRWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBwZXJTZXJ2aWNlLnByZXZpb3VzQWN0aXZlU3RlcD8uY29udGVudENvbnRhaW5lci5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRDdXJyZW50RWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmFjdGl2ZVN0ZXAuY29udGVudENvbnRhaW5lci5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVmVydGljYWxBbmltYXRpb25TZXR0aW5ncyhcbiAgICAgICAgb3BlbkFuaW1hdGlvbjogQW5pbWF0aW9uUmVmZXJlbmNlTWV0YWRhdGEsXG4gICAgICAgIGNsb3NlQW5pbWF0aW9uOiBBbmltYXRpb25SZWZlcmVuY2VNZXRhZGF0YSk6IFRvZ2dsZUFuaW1hdGlvblNldHRpbmdzIHtcbiAgICAgICAgY29uc3QgY3VzdG9tQ2xvc2VBbmltYXRpb24gPSB1c2VBbmltYXRpb24oY2xvc2VBbmltYXRpb24sIHtcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uICsgJ21zJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY3VzdG9tT3BlbkFuaW1hdGlvbiA9IHVzZUFuaW1hdGlvbihvcGVuQW5pbWF0aW9uLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvbiArICdtcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wZW5BbmltYXRpb246IG9wZW5BbmltYXRpb24gPyBjdXN0b21PcGVuQW5pbWF0aW9uIDogbnVsbCxcbiAgICAgICAgICAgIGNsb3NlQW5pbWF0aW9uOiBjbG9zZUFuaW1hdGlvbiA/IGN1c3RvbUNsb3NlQW5pbWF0aW9uIDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlU3RlcEFyaWEoc3RlcDogSWd4U3RlcENvbXBvbmVudCwgaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdGVwLl9pbmRleCA9IGluZGV4O1xuICAgICAgICBzdGVwLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShzdGVwLm5hdGl2ZUVsZW1lbnQsICdhcmlhLXNldHNpemUnLCAodGhpcy5zdGVwcy5sZW5ndGgpLnRvU3RyaW5nKCkpO1xuICAgICAgICBzdGVwLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShzdGVwLm5hdGl2ZUVsZW1lbnQsICdhcmlhLXBvc2luc2V0JywgKGluZGV4ICsgMSkudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVTdGVwQ2hhbmdlcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3RlcHMuY2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKHN0ZXBzID0+IHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0ZXBzLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RlcEFyaWEoc3RlcCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgYWN0aXZlIHN0ZXAgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0FjdGl2ZVN0ZXAgPSB0aGlzLnN0ZXBzLmZpbmQocyA9PiBzID09PSB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmFjdGl2ZVN0ZXApO1xuICAgICAgICAgICAgICAgIGlmICghaGFzQWN0aXZlU3RlcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlRmlyc3RTdGVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPIERPOiBtYXJrIHN0ZXAgYWRkZWQgYmVmb3JlIHRoZSBhY3RpdmUgYXMgdmlzaXRlZD9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jYWxjdWxhdGVMaW5lYXJEaXNhYmxlZFN0ZXBzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWN0aXZhdGVGaXJzdFN0ZXAoYWN0aXZhdGVJbml0aWFsbHkgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBmaXJzdEVuYWJsZWRTdGVwID0gdGhpcy5zdGVwcy5maW5kKHMgPT4gIXMuZGlzYWJsZWQpO1xuICAgICAgICBpZiAoZmlyc3RFbmFibGVkU3RlcCkge1xuICAgICAgICAgICAgZmlyc3RFbmFibGVkU3RlcC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGFjdGl2YXRlSW5pdGlhbGx5KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFbmFibGVkU3RlcC5hY3RpdmVDaGFuZ2UuZW1pdCh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVN0ZXBDaGFuZ2VkLmVtaXQoeyBvd25lcjogdGhpcywgaW5kZXg6IGZpcnN0RW5hYmxlZFN0ZXAuaW5kZXggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFjdGl2YXRlU3RlcChzdGVwOiBJZ3hTdGVwQ29tcG9uZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSBJZ3hTdGVwcGVyT3JpZW50YXRpb24uSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgc3RlcC5jaGFuZ2VIb3Jpem9udGFsQWN0aXZlU3RlcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5leHBhbmQoc3RlcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVUb05leHRTdGVwKG5leHQgPSB0cnVlKSB7XG4gICAgICAgIGxldCBzdGVwczogSWd4U3RlcENvbXBvbmVudFtdID0gdGhpcy5zdGVwcztcbiAgICAgICAgbGV0IGFjdGl2ZVN0ZXBJbmRleCA9IHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcC5pbmRleDtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBzdGVwcyA9IHRoaXMuc3RlcHMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgYWN0aXZlU3RlcEluZGV4ID0gc3RlcHMuZmluZEluZGV4KHMgPT4gcyA9PT0gdGhpcy5zdGVwcGVyU2VydmljZS5hY3RpdmVTdGVwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5leHRTdGVwID0gc3RlcHMuZmluZCgocywgaSkgPT4gaSA+IGFjdGl2ZVN0ZXBJbmRleCAmJiBzLmlzQWNjZXNzaWJsZSk7XG4gICAgICAgIGlmIChuZXh0U3RlcCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVN0ZXAobmV4dFN0ZXApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbiIsIjxkaXYgKm5nSWY9XCIhY29udGVudFRvcCB8fCBvcmllbnRhdGlvbiAhPT0gJ2hvcml6b250YWwnXCIgY2xhc3M9XCJpZ3gtc3RlcHBlcl9faGVhZGVyXCI+XG4gICAgPG5nLXRlbXBsYXRlICpuZ1RlbXBsYXRlT3V0bGV0PVwic3RlcFRlbXBsYXRlXCI+PC9uZy10ZW1wbGF0ZT5cbjwvZGl2PlxuXG48ZGl2ICpuZ0lmPVwib3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJ1wiIGNsYXNzPVwiaWd4LXN0ZXBwZXJfX2JvZHlcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBzdGVwIG9mIHN0ZXBzXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJzdGVwLmNvbnRlbnRUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9kaXY+XG5cbjxkaXYgKm5nSWY9XCJjb250ZW50VG9wICYmIG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCdcIiBjbGFzcz1cImlneC1zdGVwcGVyX19oZWFkZXJcIj5cbiAgICA8bmctdGVtcGxhdGUgKm5nVGVtcGxhdGVPdXRsZXQ9XCJzdGVwVGVtcGxhdGVcIj48L25nLXRlbXBsYXRlPlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjc3RlcFRlbXBsYXRlPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImlneC1zdGVwXCI+PC9uZy1jb250ZW50PlxuPC9uZy10ZW1wbGF0ZT5cbiJdfQ==