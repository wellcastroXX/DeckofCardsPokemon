import { Injectable } from '@angular/core';
import { IgxStepperOrientation } from './stepper.common';
import * as i0 from "@angular/core";
/** @hidden @internal */
export class IgxStepperService {
    constructor() {
        this.collapsingSteps = new Set();
        this.linearDisabledSteps = new Set();
        this.visitedSteps = new Set();
    }
    /**
     * Activates the step, fires the steps change event and plays animations.
     */
    expand(step) {
        if (this.activeStep === step) {
            return;
        }
        const cancel = this.emitActivatingEvent(step);
        if (cancel) {
            return;
        }
        this.collapsingSteps.delete(step);
        this.previousActiveStep = this.activeStep;
        this.activeStep = step;
        this.activeStep.activeChange.emit(true);
        this.collapsingSteps.add(this.previousActiveStep);
        this.visitedSteps.add(this.activeStep);
        if (this.stepper.orientation === IgxStepperOrientation.Vertical) {
            this.previousActiveStep.playCloseAnimation(this.previousActiveStep.contentContainer);
            this.activeStep.cdr.detectChanges();
            this.activeStep.playOpenAnimation(this.activeStep.contentContainer);
        }
        else {
            this.activeStep.cdr.detectChanges();
            this.stepper.playHorizontalAnimations();
        }
    }
    /**
     * Activates the step and fires the steps change event without playing animations.
     */
    expandThroughApi(step) {
        if (this.activeStep === step) {
            return;
        }
        this.collapsingSteps.clear();
        this.previousActiveStep = this.activeStep;
        this.activeStep = step;
        if (this.previousActiveStep) {
            this.previousActiveStep.tabIndex = -1;
        }
        this.activeStep.tabIndex = 0;
        this.visitedSteps.add(this.activeStep);
        this.activeStep.cdr.markForCheck();
        this.previousActiveStep?.cdr.markForCheck();
        this.activeStep.activeChange.emit(true);
        this.previousActiveStep?.activeChange.emit(false);
    }
    /**
     * Collapses the currently active step and fires the change event.
     */
    collapse(step) {
        if (this.activeStep === step) {
            return;
        }
        step.activeChange.emit(false);
        this.collapsingSteps.delete(step);
    }
    /**
     * Determines the steps that should be marked as visited based on the active step.
     */
    calculateVisitedSteps() {
        this.stepper.steps.forEach(step => {
            if (step.index <= this.activeStep.index) {
                this.visitedSteps.add(step);
            }
            else {
                this.visitedSteps.delete(step);
            }
        });
    }
    /**
     * Determines the steps that should be disabled in linear mode based on the validity of the active step.
     */
    calculateLinearDisabledSteps() {
        if (!this.activeStep) {
            return;
        }
        if (this.activeStep.isValid) {
            const firstRequiredIndex = this.getNextRequiredStep();
            if (firstRequiredIndex !== -1) {
                this.updateLinearDisabledSteps(firstRequiredIndex);
            }
            else {
                this.linearDisabledSteps.clear();
            }
        }
        else {
            this.stepper.steps.forEach(s => {
                if (s.index > this.activeStep.index) {
                    this.linearDisabledSteps.add(s);
                }
            });
        }
    }
    emitActivatingEvent(step) {
        const args = {
            owner: this.stepper,
            newIndex: step.index,
            oldIndex: this.activeStep.index,
            cancel: false
        };
        this.stepper.activeStepChanging.emit(args);
        return args.cancel;
    }
    /**
     * Updates the linearDisabled steps from the current active step to the next required invalid step.
     *
     * @param toIndex the index of the last step that should be enabled.
     */
    updateLinearDisabledSteps(toIndex) {
        this.stepper.steps.forEach(s => {
            if (s.index > this.activeStep.index) {
                if (s.index <= toIndex) {
                    this.linearDisabledSteps.delete(s);
                }
                else {
                    this.linearDisabledSteps.add(s);
                }
            }
        });
    }
    getNextRequiredStep() {
        if (!this.activeStep) {
            return;
        }
        return this.stepper.steps.findIndex(s => s.index > this.activeStep.index && !s.optional && !s.disabled && !s.isValid);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxStepperService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxStepperService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxStepperService, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3N0ZXBwZXIvc3RlcHBlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFjLHFCQUFxQixFQUEwQixNQUFNLGtCQUFrQixDQUFDOztBQUc3Rix3QkFBd0I7QUFFeEIsTUFBTSxPQUFPLGlCQUFpQjtJQUQ5QjtRQU1XLG9CQUFlLEdBQTBCLElBQUksR0FBRyxFQUFvQixDQUFDO1FBQ3JFLHdCQUFtQixHQUEwQixJQUFJLEdBQUcsRUFBb0IsQ0FBQztRQUN6RSxpQkFBWSxHQUEwQixJQUFJLEdBQUcsRUFBb0IsQ0FBQztLQXFKNUU7SUFsSkc7O09BRUc7SUFDSSxNQUFNLENBQUMsSUFBc0I7UUFDaEMsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLElBQUksRUFBRTtZQUMxQixPQUFPO1NBQ1Y7UUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUMsSUFBSSxNQUFNLEVBQUU7WUFDUixPQUFPO1NBQ1Y7UUFFRCxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVsQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUMxQyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFeEMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMs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Q0FBQztpQkFDbkM7YUFDSjtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVPLG1CQUFtQjtRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNsQixPQUFPO1NBQ1Y7UUFDRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxSCxDQUFDOzhHQTNKUSxpQkFBaUI7a0hBQWpCLGlCQUFpQjs7MkZBQWpCLGlCQUFpQjtrQkFEN0IsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneFN0ZXBwZXIsIElneFN0ZXBwZXJPcmllbnRhdGlvbiwgSVN0ZXBDaGFuZ2luZ0V2ZW50QXJncyB9IGZyb20gJy4vc3RlcHBlci5jb21tb24nO1xuaW1wb3J0IHsgSWd4U3RlcENvbXBvbmVudCB9IGZyb20gJy4vc3RlcC9zdGVwLmNvbXBvbmVudCc7XG5cbi8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIElneFN0ZXBwZXJTZXJ2aWNlIHtcbiAgICBwdWJsaWMgYWN0aXZlU3RlcDogSWd4U3RlcENvbXBvbmVudDtcbiAgICBwdWJsaWMgcHJldmlvdXNBY3RpdmVTdGVwOiBJZ3hTdGVwQ29tcG9uZW50O1xuICAgIHB1YmxpYyBmb2N1c2VkU3RlcDogSWd4U3RlcENvbXBvbmVudDtcblxuICAgIHB1YmxpYyBjb2xsYXBzaW5nU3RlcHM6IFNldDxJZ3hTdGVwQ29tcG9uZW50PiA9IG5ldyBTZXQ8SWd4U3RlcENvbXBvbmVudD4oKTtcbiAgICBwdWJsaWMgbGluZWFyRGlzYWJsZWRTdGVwczogU2V0PElneFN0ZXBDb21wb25lbnQ+ID0gbmV3IFNldDxJZ3hTdGVwQ29tcG9uZW50PigpO1xuICAgIHB1YmxpYyB2aXNpdGVkU3RlcHM6IFNldDxJZ3hTdGVwQ29tcG9uZW50PiA9IG5ldyBTZXQ8SWd4U3RlcENvbXBvbmVudD4oKTtcbiAgICBwdWJsaWMgc3RlcHBlcjogSWd4U3RlcHBlcjtcblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB0aGUgc3RlcCwgZmlyZXMgdGhlIHN0ZXBzIGNoYW5nZSBldmVudCBhbmQgcGxheXMgYW5pbWF0aW9ucy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZXhwYW5kKHN0ZXA6IElneFN0ZXBDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU3RlcCA9PT0gc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2FuY2VsID0gdGhpcy5lbWl0QWN0aXZhdGluZ0V2ZW50KHN0ZXApO1xuICAgICAgICBpZiAoY2FuY2VsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbGxhcHNpbmdTdGVwcy5kZWxldGUoc3RlcCk7XG5cbiAgICAgICAgdGhpcy5wcmV2aW91c0FjdGl2ZVN0ZXAgPSB0aGlzLmFjdGl2ZVN0ZXA7XG4gICAgICAgIHRoaXMuYWN0aXZlU3RlcCA9IHN0ZXA7XG4gICAgICAgIHRoaXMuYWN0aXZlU3RlcC5hY3RpdmVDaGFuZ2UuZW1pdCh0cnVlKTtcblxuICAgICAgICB0aGlzLmNvbGxhcHNpbmdTdGVwcy5hZGQodGhpcy5wcmV2aW91c0FjdGl2ZVN0ZXApO1xuICAgICAgICB0aGlzLnZpc2l0ZWRTdGVwcy5hZGQodGhpcy5hY3RpdmVTdGVwKTtcblxuICAgICAgICBpZiAodGhpcy5zdGVwcGVyLm9yaWVudGF0aW9uID09PSBJZ3hTdGVwcGVyT3JpZW50YXRpb24uVmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNBY3RpdmVTdGVwLnBsYXlDbG9zZUFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQWN0aXZlU3RlcC5jb250ZW50Q29udGFpbmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTdGVwLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcC5wbGF5T3BlbkFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVN0ZXAuY29udGVudENvbnRhaW5lclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcC5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5zdGVwcGVyLnBsYXlIb3Jpem9udGFsQW5pbWF0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBzdGVwIGFuZCBmaXJlcyB0aGUgc3RlcHMgY2hhbmdlIGV2ZW50IHdpdGhvdXQgcGxheWluZyBhbmltYXRpb25zLlxuICAgICAqL1xuICAgIHB1YmxpYyBleHBhbmRUaHJvdWdoQXBpKHN0ZXA6IElneFN0ZXBDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU3RlcCA9PT0gc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xsYXBzaW5nU3RlcHMuY2xlYXIoKTtcblxuICAgICAgICB0aGlzLnByZXZpb3VzQWN0aXZlU3RlcCA9IHRoaXMuYWN0aXZlU3RlcDtcbiAgICAgICAgdGhpcy5hY3RpdmVTdGVwID0gc3RlcDtcblxuICAgICAgICBpZiAodGhpcy5wcmV2aW91c0FjdGl2ZVN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNBY3RpdmVTdGVwLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVTdGVwLnRhYkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy52aXNpdGVkU3RlcHMuYWRkKHRoaXMuYWN0aXZlU3RlcCk7XG5cbiAgICAgICAgdGhpcy5hY3RpdmVTdGVwLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0FjdGl2ZVN0ZXA/LmNkci5tYXJrRm9yQ2hlY2soKTtcblxuICAgICAgICB0aGlzLmFjdGl2ZVN0ZXAuYWN0aXZlQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgICAgIHRoaXMucHJldmlvdXNBY3RpdmVTdGVwPy5hY3RpdmVDaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHN0ZXAgYW5kIGZpcmVzIHRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgICovXG4gICAgcHVibGljIGNvbGxhcHNlKHN0ZXA6IElneFN0ZXBDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU3RlcCA9PT0gc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAuYWN0aXZlQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgICAgICB0aGlzLmNvbGxhcHNpbmdTdGVwcy5kZWxldGUoc3RlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgc3RlcHMgdGhhdCBzaG91bGQgYmUgbWFya2VkIGFzIHZpc2l0ZWQgYmFzZWQgb24gdGhlIGFjdGl2ZSBzdGVwLlxuICAgICAqL1xuICAgIHB1YmxpYyBjYWxjdWxhdGVWaXNpdGVkU3RlcHMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3RlcHBlci5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4ge1xuICAgICAgICAgICAgaWYgKHN0ZXAuaW5kZXggPD0gdGhpcy5hY3RpdmVTdGVwLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdGVkU3RlcHMuYWRkKHN0ZXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0ZWRTdGVwcy5kZWxldGUoc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIHN0ZXBzIHRoYXQgc2hvdWxkIGJlIGRpc2FibGVkIGluIGxpbmVhciBtb2RlIGJhc2VkIG9uIHRoZSB2YWxpZGl0eSBvZiB0aGUgYWN0aXZlIHN0ZXAuXG4gICAgICovXG4gICAgcHVibGljIGNhbGN1bGF0ZUxpbmVhckRpc2FibGVkU3RlcHMoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVTdGVwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hY3RpdmVTdGVwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UmVxdWlyZWRJbmRleCA9IHRoaXMuZ2V0TmV4dFJlcXVpcmVkU3RlcCgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0UmVxdWlyZWRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxpbmVhckRpc2FibGVkU3RlcHMoZmlyc3RSZXF1aXJlZEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lYXJEaXNhYmxlZFN0ZXBzLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBwZXIuc3RlcHMuZm9yRWFjaChzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocy5pbmRleCA+IHRoaXMuYWN0aXZlU3RlcC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVhckRpc2FibGVkU3RlcHMuYWRkKHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGVtaXRBY3RpdmF0aW5nRXZlbnQoc3RlcDogSWd4U3RlcENvbXBvbmVudCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBhcmdzOiBJU3RlcENoYW5naW5nRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMuc3RlcHBlcixcbiAgICAgICAgICAgIG5ld0luZGV4OiBzdGVwLmluZGV4LFxuICAgICAgICAgICAgb2xkSW5kZXg6IHRoaXMuYWN0aXZlU3RlcC5pbmRleCxcbiAgICAgICAgICAgIGNhbmNlbDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnN0ZXBwZXIuYWN0aXZlU3RlcENoYW5naW5nLmVtaXQoYXJncyk7XG4gICAgICAgIHJldHVybiBhcmdzLmNhbmNlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsaW5lYXJEaXNhYmxlZCBzdGVwcyBmcm9tIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGVwIHRvIHRoZSBuZXh0IHJlcXVpcmVkIGludmFsaWQgc3RlcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b0luZGV4IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdGVwIHRoYXQgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVMaW5lYXJEaXNhYmxlZFN0ZXBzKHRvSW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnN0ZXBwZXIuc3RlcHMuZm9yRWFjaChzID0+IHtcbiAgICAgICAgICAgIGlmIChzLmluZGV4ID4gdGhpcy5hY3RpdmVTdGVwLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHMuaW5kZXggPD0gdG9JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVhckRpc2FibGVkU3RlcHMuZGVsZXRlKHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZWFyRGlzYWJsZWRTdGVwcy5hZGQocyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE5leHRSZXF1aXJlZFN0ZXAoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZVN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcGVyLnN0ZXBzLmZpbmRJbmRleChzID0+IHMuaW5kZXggPiB0aGlzLmFjdGl2ZVN0ZXAuaW5kZXggJiYgIXMub3B0aW9uYWwgJiYgIXMuZGlzYWJsZWQgJiYgIXMuaXNWYWxpZCk7XG4gICAgfVxufVxuIl19