import { ExcelStrings } from './excel-strings';
import { strToU8 } from 'fflate';
import { yieldingLoop } from '../../core/utils';
import { ExportHeaderType, ExportRecordType, GRID_ROOT_SUMMARY, GRID_PARENT, GRID_LEVEL_COL } from '../exporter-common/base-export-service';
/**
 * @hidden
 */
export class RootRelsFile {
    writeElement(folder) {
        folder['.rels'] = strToU8(ExcelStrings.getRels());
    }
}
/**
 * @hidden
 */
export class AppFile {
    writeElement(folder, worksheetData) {
        folder['app.xml'] = strToU8(ExcelStrings.getApp(worksheetData.options.worksheetName));
    }
}
/**
 * @hidden
 */
export class CoreFile {
    writeElement(folder) {
        folder['core.xml'] = strToU8(ExcelStrings.getCore());
    }
}
/**
 * @hidden
 */
export class WorkbookRelsFile {
    writeElement(folder, worksheetData) {
        const hasSharedStrings = !worksheetData.isEmpty || worksheetData.options.alwaysExportHeaders;
        folder['workbook.xml.rels'] = strToU8(ExcelStrings.getWorkbookRels(hasSharedStrings));
    }
}
/**
 * @hidden
 */
export class ThemeFile {
    writeElement(folder) {
        folder['theme1.xml'] = strToU8(ExcelStrings.getTheme());
    }
}
/**
 * @hidden
 */
export class WorksheetFile {
    constructor() {
        this.maxOutlineLevel = 0;
        this.sheetData = '';
        this.dimension = '';
        this.freezePane = '';
        this.rowHeight = '';
        this.mergeCellStr = '';
        this.mergeCellsCounter = 0;
        this.rowIndex = 0;
        this.pivotGridRowHeadersMap = new Map();
        this.dimensionMap = new Map();
        this.hierarchicalDimensionMap = new Map();
        this.currentSummaryOwner = '';
        this.currentHierarchicalOwner = '';
        this.firstColumn = Number.MAX_VALUE;
        this.firstDataRow = Number.MAX_VALUE;
        this.currencyStyleMap = new Map([
            ['USD', { styleXf: 5, symbol: '$' }],
            ['GBP', { styleXf: 6, symbol: '£' }],
            ['CNY', { styleXf: 7, symbol: '¥' }],
            ['EUR', { styleXf: 8, symbol: '€' }],
            ['JPY', { styleXf: 9, symbol: '¥' }],
        ]);
    }
    static { this.MIN_WIDTH = 8.43; }
    writeElement() { }
    async writeElementAsync(folder, worksheetData) {
        return new Promise(resolve => {
            this.prepareDataAsync(worksheetData, (cols, rows) => {
                const hasTable = (!worksheetData.isEmpty || worksheetData.options.alwaysExportHeaders)
                    && worksheetData.options.exportAsTable;
                folder['sheet1.xml'] = strToU8(ExcelStrings.getSheetXML(this.dimension, this.freezePane, cols, rows, hasTable, this.maxOutlineLevel, worksheetData.isHierarchical));
                resolve();
            });
        });
    }
    prepareDataAsync(worksheetData, done) {
        this.sheetData = '';
        let cols = '';
        const dictionary = worksheetData.dataDictionary;
        this.rowIndex = 0;
        if (worksheetData.isEmpty && (!worksheetData.options.alwaysExportHeaders || worksheetData.owner.columns.length === 0)) {
            this.sheetData += '<sheetData/>';
            this.dimension = 'A1';
            done('', this.sheetData);
        }
        else {
            const owner = worksheetData.owner;
            const isHierarchicalGrid = worksheetData.isHierarchical;
            const hasMultiColumnHeader = worksheetData.hasMultiColumnHeader;
            const hasMultiRowHeader = worksheetData.hasMultiRowHeader;
            const hasUserSetIndex = owner.columns.some(col => col.exportIndex !== undefined);
            const height = worksheetData.options.rowHeight;
            this.isValidGrid = worksheetData.isHierarchical || worksheetData.isTreeGrid || worksheetData.isGroupedGrid;
            this.rowHeight = height ? ` ht="${height}" customHeight="1"` : '';
            this.sheetData += `<sheetData>`;
            let headersForLevel = [];
            for (let i = 0; i <= owner.maxRowLevel; i++) {
                headersForLevel = owner.columns.filter(c => c.level === i && c.rowSpan > 0 && !c.skip);
                this.printHeaders(worksheetData, headersForLevel, i, true);
                this.rowIndex++;
            }
            this.rowIndex = 0;
            for (let i = 0; i <= owner.maxLevel; i++) {
                this.rowIndex++;
                const pivotGridColumns = this.pivotGridRowHeadersMap.get(this.rowIndex) ?? "";
                this.sheetData += `<row r="${this.rowIndex}"${this.rowHeight}>${pivotGridColumns}`;
                const allowedColumns = owner.columns.filter(c => c.headerType !== ExportHeaderType.RowHeader && c.headerType !== ExportHeaderType.MultiRowHeader);
                headersForLevel = hasMultiColumnHeader ?
                    allowedColumns
                        .filter(c => (c.level < i &&
                        c.headerType !== ExportHeaderType.MultiColumnHeader || c.level === i) && c.columnSpan > 0 && !c.skip)
                        .sort((a, b) => a.startIndex - b.startIndex)
                        .sort((a, b) => a.pinnedIndex - b.pinnedIndex) :
                    hasUserSetIndex ?
                        allowedColumns.filter(c => !c.skip) :
                        allowedColumns.filter(c => !c.skip)
                            .sort((a, b) => a.startIndex - b.startIndex)
                            .sort((a, b) => a.pinnedIndex - b.pinnedIndex);
                this.printHeaders(worksheetData, headersForLevel, i, false);
                this.sheetData += `</row>`;
            }
            const multiColumnHeaderLevel = worksheetData.options.ignoreMultiColumnHeaders ? 0 : owner.maxLevel;
            const freezeHeaders = worksheetData.options.freezeHeaders ? 2 + multiColumnHeaderLevel : 1;
            if (!isHierarchicalGrid) {
                const col = worksheetData.hasSummaries ? worksheetData.columnCount + 1 : worksheetData.columnCount - 1;
                this.dimension = 'A1:' + ExcelStrings.getExcelColumn(col) + (worksheetData.rowCount);
                cols += '<cols>';
                if (!hasMultiColumnHeader) {
                    for (let j = 0; j < worksheetData.columnCount; j++) {
                        const width = dictionary.columnWidths[j];
                        // Use the width provided in the options if it exists
                        let widthInTwips = worksheetData.options.columnWidth !== undefined ?
                            worksheetData.options.columnWidth :
                            Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                        if (!(widthInTwips > 0)) {
                            widthInTwips = WorksheetFile.MIN_WIDTH;
                        }
                        cols += `<col min="${(j + 1)}" max="${(j + 1)}" width="${widthInTwips}" customWidth="1"/>`;
                    }
                }
                else {
                    cols += `<col min="1" max="${worksheetData.columnCount}" width="15" customWidth="1"/>`;
                }
                const indexOfLastPinnedColumn = worksheetData.indexOfLastPinnedColumn;
                const frozenColumnCount = indexOfLastPinnedColumn + 1;
                let firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + freezeHeaders;
                if (indexOfLastPinnedColumn !== undefined && indexOfLastPinnedColumn !== -1 &&
                    !worksheetData.options.ignorePinning &&
                    !worksheetData.options.ignoreColumnsOrder) {
                    this.freezePane =
                        `<pane xSplit="${frozenColumnCount}" ySplit="${freezeHeaders - 1}"
                         topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
                }
                else if (worksheetData.options.freezeHeaders) {
                    firstCell = ExcelStrings.getExcelColumn(0) + freezeHeaders;
                    this.freezePane =
                        `<pane xSplit="0" ySplit="${freezeHeaders - 1}"
                         topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
                }
            }
            else {
                const columnWidth = worksheetData.options.columnWidth ? worksheetData.options.columnWidth : 20;
                cols += `<cols><col min="1" max="${worksheetData.columnCount}" width="${columnWidth}" customWidth="1"/>`;
                if (worksheetData.options.freezeHeaders) {
                    const firstCell = ExcelStrings.getExcelColumn(0) + freezeHeaders;
                    this.freezePane =
                        `<pane xSplit="0" ySplit="${freezeHeaders - 1}"
                         topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
                }
            }
            if (worksheetData.hasSummaries) {
                cols += `<col min="${worksheetData.columnCount + 2}" max="${worksheetData.columnCount + 2}" hidden="1"/>`;
            }
            cols += '</cols>';
            this.processDataRecordsAsync(worksheetData, (rows) => {
                this.sheetData += rows;
                this.sheetData += '</sheetData>';
                if ((hasMultiColumnHeader || hasMultiRowHeader) && this.mergeCellsCounter > 0) {
                    this.sheetData += `<mergeCells count="${this.mergeCellsCounter}">${this.mergeCellStr}</mergeCells>`;
                }
                done(cols, this.sheetData);
            });
        }
    }
    processDataRecordsAsync(worksheetData, done) {
        const rowDataArr = [];
        const height = worksheetData.options.rowHeight;
        this.rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
        const isHierarchicalGrid = worksheetData.isHierarchical;
        const hasUserSetIndex = worksheetData.owner.columns.some(c => c.exportIndex !== undefined);
        let recordHeaders = [];
        yieldingLoop(worksheetData.rowCount - worksheetData.multiColumnHeaderRows - 1, 1000, (i) => {
            if (!worksheetData.isEmpty) {
                if (!isHierarchicalGrid) {
                    if (hasUserSetIndex) {
                        recordHeaders = worksheetData.rootKeys;
                    }
                    else {
                        recordHeaders = worksheetData.owner.columns
                            .filter(c => c.headerType === ExportHeaderType.ColumnHeader && !c.skip)
                            .sort((a, b) => a.startIndex - b.startIndex)
                            .sort((a, b) => a.pinnedIndex - b.pinnedIndex)
                            .map(c => c.field);
                    }
                }
                else {
                    const record = worksheetData.data[i];
                    if (record.type === ExportRecordType.HeaderRecord) {
                        const recordOwner = worksheetData.owners.get(record.owner);
                        const hasMultiColumnHeaders = recordOwner.columns.some(c => !c.skip && c.headerType === ExportHeaderType.MultiColumnHeader);
                        if (hasMultiColumnHeaders) {
                            this.hGridPrintMultiColHeaders(worksheetData, rowDataArr, record, recordOwner);
                        }
                    }
                    recordHeaders = Object.keys(worksheetData.data[i].data);
                }
                rowDataArr.push(this.processRow(worksheetData, i, recordHeaders, isHierarchicalGrid));
            }
        }, () => {
            done(rowDataArr.join(''));
        });
    }
    hGridPrintMultiColHeaders(worksheetData, rowDataArr, record, owner) {
        for (let j = 0; j < owner.maxLevel; j++) {
            const recordLevel = record.level;
            const outlineLevel = recordLevel > 0 ? ` outlineLevel="${recordLevel}"` : '';
            this.maxOutlineLevel = this.maxOutlineLevel < recordLevel ? recordLevel : this.maxOutlineLevel;
            const sHidden = record.hidden ? ` hidden="1"` : '';
            this.rowIndex++;
            let row = `<row r="${this.rowIndex}"${this.rowHeight}${outlineLevel}${sHidden}>`;
            const headersForLevel = owner.columns
                .filter(c => (c.level < j &&
                c.headerType !== ExportHeaderType.MultiColumnHeader || c.level === j) && c.columnSpan > 0 && !c.skip)
                .sort((a, b) => a.startIndex - b.startIndex)
                .sort((a, b) => a.pinnedIndex - b.pinnedIndex);
            let startValue = 0 + record.level;
            for (const currentCol of headersForLevel) {
                if (currentCol.level === j) {
                    let columnCoordinate;
                    columnCoordinate =
                        ExcelStrings.getExcelColumn(startValue) + this.rowIndex;
                    const columnValue = worksheetData.dataDictionary.saveValue(currentCol.header, true);
                    row += `<c r="${columnCoordinate}" s="3" t="s"><v>${columnValue}</v></c>`;
                    if (j !== owner.maxLevel) {
                        this.mergeCellsCounter++;
                        this.mergeCellStr += ` <mergeCell ref="${columnCoordinate}:`;
                        if (currentCol.headerType === ExportHeaderType.ColumnHeader) {
                            columnCoordinate = ExcelStrings.getExcelColumn(startValue) +
                                (this.rowIndex + owner.maxLevel - currentCol.level);
                        }
                        else {
                            for (let k = 1; k < currentCol.columnSpan; k++) {
                                columnCoordinate = ExcelStrings.getExcelColumn(startValue + k) + this.rowIndex;
                                row += `<c r="${columnCoordinate}" s="3" />`;
                            }
                        }
                        this.mergeCellStr += `${columnCoordinate}" />`;
                    }
                }
                startValue += currentCol.columnSpan;
            }
            row += `</row>`;
            rowDataArr.push(row);
        }
    }
    processRow(worksheetData, i, headersForLevel, isHierarchicalGrid) {
        const record = worksheetData.data[i];
        const rowData = new Array(worksheetData.columnCount + 2);
        const rowLevel = record.level;
        const outlineLevel = rowLevel > 0 ? ` outlineLevel="${rowLevel}"` : '';
        this.maxOutlineLevel = this.maxOutlineLevel < rowLevel ? rowLevel : this.maxOutlineLevel;
        const sHidden = record.hidden ? ` hidden="1"` : '';
        this.rowIndex++;
        const pivotGridColumns = this.pivotGridRowHeadersMap.get(this.rowIndex) ?? "";
        rowData[0] = `<row r="${this.rowIndex}"${this.rowHeight}${outlineLevel}${sHidden}>${pivotGridColumns}`;
        const keys = worksheetData.isSpecialData ? [record.data] : headersForLevel;
        const isDataRecord = record.type === ExportRecordType.HierarchicalGridRecord
            || record.type === ExportRecordType.DataRecord
            || record.type === ExportRecordType.GroupedRecord
            || record.type === ExportRecordType.TreeGridRecord;
        const isValidRecordType = isDataRecord || record.type === ExportRecordType.SummaryRecord;
        if (isValidRecordType && worksheetData.hasSummaries) {
            this.resolveSummaryDimensions(record, isDataRecord, worksheetData.isGroupedGrid);
        }
        for (let j = 0; j < keys.length; j++) {
            const col = j + (isHierarchicalGrid ? rowLevel : worksheetData.isPivotGrid ? worksheetData.owner.maxRowLevel : 0);
            const cellData = this.getCellData(worksheetData, i, col, keys[j]);
            rowData[j + 1] = cellData;
        }
        rowData[keys.length + 1] = '</row>';
        return rowData.join('');
    }
    getCellData(worksheetData, row, column, key) {
        const dictionary = worksheetData.dataDictionary;
        let columnName = ExcelStrings.getExcelColumn(column) + (this.rowIndex);
        const fullRow = worksheetData.data[row];
        const isHeaderRecord = fullRow.type === ExportRecordType.HeaderRecord;
        const isSummaryRecord = fullRow.type === ExportRecordType.SummaryRecord;
        const isValidRecordType = fullRow.type === ExportRecordType.GroupedRecord
            || fullRow.type === ExportRecordType.DataRecord
            || fullRow.type === ExportRecordType.HierarchicalGridRecord
            || fullRow.type === ExportRecordType.TreeGridRecord;
        this.firstDataRow = this.firstDataRow > this.rowIndex ? this.rowIndex : this.firstDataRow;
        const cellValue = worksheetData.isSpecialData ?
            fullRow.data :
            fullRow.data[key];
        if (cellValue === GRID_LEVEL_COL || key === GRID_LEVEL_COL) {
            columnName = ExcelStrings.getExcelColumn(worksheetData.columnCount + 1) + (this.rowIndex);
        }
        if (worksheetData.hasSummaries && (isValidRecordType || (worksheetData.isGroupedGrid && isSummaryRecord))) {
            this.setSummaryCoordinates(columnName, key, fullRow.hierarchicalOwner, worksheetData.isGroupedGrid && isSummaryRecord);
        }
        if (fullRow.summaryKey && fullRow.summaryKey === GRID_ROOT_SUMMARY && key !== GRID_LEVEL_COL && worksheetData.isGroupedGrid) {
            this.setRootSummaryStartCoordinate(column, key);
            if (this.firstColumn > column) {
                this.setRootSummaryStartCoordinate(worksheetData.columnCount + 1, GRID_LEVEL_COL);
                this.firstColumn = column;
            }
        }
        const targetColArr = Array.from(worksheetData.owners.values()).map(arr => arr.columns).find(product => product.some(item => item.field === key));
        const targetCol = targetColArr ? targetColArr.find(col => col.field === key) : undefined;
        if ((cellValue === undefined || cellValue === null) && !worksheetData.hasSummaries) {
            return `<c r="${columnName}" s="1"/>`;
        }
        else if ((worksheetData.hasSummaries && (isValidRecordType || isHeaderRecord)) || !worksheetData.hasSummaries) {
            const savedValue = dictionary.saveValue(cellValue, isHeaderRecord);
            const isSavedAsString = savedValue !== -1;
            const isSavedAsDate = !isSavedAsString && cellValue instanceof Date;
            let value = isSavedAsString ? savedValue : cellValue;
            if (isSavedAsDate) {
                const timeZoneOffset = value.getTimezoneOffset() * 60000;
                const isoString = (new Date(value - timeZoneOffset)).toISOString();
                value = isoString.substring(0, isoString.indexOf('.'));
            }
            const type = isSavedAsString ? ` t="s"` : isSavedAsDate ? ` t="d"` : '';
            const isTime = targetCol?.dataType === 'time';
            const isDateTime = targetCol?.dataType === 'dateTime';
            const isPercentage = targetCol?.dataType === 'percent';
            const isColumnCurrencyType = targetCol?.dataType === 'currency';
            const format = isPercentage ? ` s="12"` : isDateTime ? ` s="11"` : isTime ? ` s="10"` : isHeaderRecord ? ` s="3"` : isSavedAsString ? '' : isSavedAsDate ? ` s="2"` : isColumnCurrencyType ? ` s="${this.currencyStyleMap.get(targetCol.currencyCode)?.styleXf || 0}"` : ` s="1"`;
            return `<c r="${columnName}"${type}${format}><v>${value}</v></c>`;
        }
        else {
            let summaryFunc = `"${cellValue ?? ""}"`;
            if (isSummaryRecord && cellValue) {
                const dimensionMapKey = this.isValidGrid ? fullRow.hierarchicalOwner ?? GRID_PARENT : null;
                const level = worksheetData.isGroupedGrid ? worksheetData.maxLevel : fullRow.level;
                summaryFunc = this.getSummaryFunction(cellValue.label, key, dimensionMapKey, level, targetCol);
                if (!summaryFunc) {
                    const cellStr = `${cellValue.label}: ${cellValue.value}`;
                    const savedValue = dictionary.saveValue(cellStr, false);
                    return `<c r="${columnName}" t="s" s="1"><v>${savedValue}</v></c>`;
                }
                return `<c r="${columnName}"><f t="array" ref="${columnName}">${summaryFunc}</f></c>`;
            }
            return `<c r="${columnName}" s="1"><f>${summaryFunc}</f></c>`;
        }
    }
    resolveSummaryDimensions(record, isDataRecord, isGroupedGrid) {
        if (this.isValidGrid &&
            this.currentHierarchicalOwner !== '' &&
            this.currentHierarchicalOwner !== record.owner &&
            !this.hierarchicalDimensionMap.get(this.currentHierarchicalOwner)) {
            this.hierarchicalDimensionMap.set(this.currentHierarchicalOwner, new Map(this.dimensionMap));
        }
        if (isDataRecord) {
            if (this.currentSummaryOwner !== record.summaryKey || this.currentHierarchicalOwner !== record.hierarchicalOwner) {
                this.dimensionMap.clear();
            }
            this.currentSummaryOwner = record.summaryKey;
            // For grouped grid we need to reset the parent map
            // so we can change the startCoordinate for each record
            if (isGroupedGrid && this.currentHierarchicalOwner !== '' && record.hierarchicalOwner === GRID_PARENT) {
                this.hierarchicalDimensionMap.delete(GRID_PARENT);
            }
            this.currentHierarchicalOwner = record.hierarchicalOwner;
        }
    }
    setSummaryCoordinates(columnName, key, hierarchicalOwner, useLastValidEndCoordinate) {
        const targetDimensionMap = this.hierarchicalDimensionMap.get(hierarchicalOwner) ?? this.dimensionMap;
        if (!targetDimensionMap.get(key)) {
            const initialDimensions = {
                startCoordinate: columnName,
                endCoordinate: columnName
            };
            targetDimensionMap.set(key, initialDimensions);
        }
        else {
            if (useLastValidEndCoordinate) {
                this.setEndCoordinates(targetDimensionMap, true);
            }
            else {
                targetDimensionMap.get(key).endCoordinate = columnName;
                this.lastValidRow = targetDimensionMap.get(key).endCoordinate.match(/[a-z]+|[^a-z]+/gi)[1];
            }
        }
        if (this.isValidGrid && !useLastValidEndCoordinate && hierarchicalOwner !== GRID_PARENT) {
            const parentMap = this.hierarchicalDimensionMap.get(GRID_PARENT);
            this.setEndCoordinates(parentMap);
        }
    }
    setEndCoordinates(map, useLastValidEndCoordinate = false) {
        for (const a of map.values()) {
            const colName = a.endCoordinate.match(/[a-z]+|[^a-z]+/gi)[0];
            a.endCoordinate = `${colName}${useLastValidEndCoordinate ? this.lastValidRow : this.rowIndex}`;
        }
    }
    getSummaryFunction(type, key, dimensionMapKey, recordLevel, col) {
        const dimensionMap = dimensionMapKey ? this.hierarchicalDimensionMap.get(dimensionMapKey) : this.dimensionMap;
        const dimensions = dimensionMap.get(key);
        const levelDimensions = dimensionMap.get(GRID_LEVEL_COL);
        let func = '';
        let funcType = '';
        let result = '';
        const currencyInfo = this.currencyStyleMap.get(col.currencyCode);
        switch (type.toLowerCase()) {
            case "count":
                return `"Count: "&amp;_xlfn.COUNTIF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}, ${recordLevel})`;
            case "min":
                func = `_xlfn.MIN(_xlfn.IF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}=${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate}))`;
                funcType = `"Min: "&amp;`;
                result = funcType + (col.dataType === 'currency' && currencyInfo
                    ? `_xlfn.TEXT(${func}, "${currencyInfo.symbol}#,##0.00")`
                    : `${func}`);
                return result;
            case "max":
                func = `_xlfn.MAX(_xlfn.IF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}=${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate}))`;
                funcType = `"Max: "&amp;`;
                result = funcType + (col.dataType === 'currency' && currencyInfo
                    ? `_xlfn.TEXT(${func}, "${currencyInfo.symbol}#,##0.00")`
                    : `${func}`);
                return result;
            case "sum":
                func = `_xlfn.SUMIF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}, ${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate})`;
                funcType = `"Sum: "&amp;`;
                result = funcType + (col.dataType === 'currency' && currencyInfo
                    ? `_xlfn.TEXT(${func}, "${currencyInfo.symbol}#,##0.00")`
                    : `${func}`);
                return result;
            case "avg":
                func = `_xlfn.AVERAGEIF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}, ${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate})`;
                funcType = `"Avg: "&amp;`;
                result = funcType + (col.dataType === 'currency' && currencyInfo
                    ? `_xlfn.TEXT(${func}, "${currencyInfo.symbol}#,##0.00")`
                    : `${func}`);
                return result;
            case "earliest":
                // TODO: get date format from locale
                return `"Earliest: "&amp;_xlfn.TEXT(_xlfn.MIN(_xlfn.IF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}=${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate})), "m/d/yyyy")`;
            case "latest":
                // TODO: get date format from locale
                return `"Latest: "&amp;_xlfn.TEXT(_xlfn.MAX(_xlfn.IF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}=${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate})), "m/d/yyyy")`;
        }
    }
    setRootSummaryStartCoordinate(column, key) {
        const firstDataRecordColName = ExcelStrings.getExcelColumn(column) + (this.firstDataRow);
        const targetMap = this.hierarchicalDimensionMap.get(GRID_PARENT);
        if (targetMap.get(key).startCoordinate !== firstDataRecordColName) {
            targetMap.get(key).startCoordinate = firstDataRecordColName;
        }
    }
    printHeaders(worksheetData, headersForLevel, i, isVertical) {
        let startValue = 0;
        let str = '';
        const isHierarchicalGrid = worksheetData.isHierarchical;
        let rowStyle = isHierarchicalGrid ? ' s="3"' : '';
        const dictionary = worksheetData.dataDictionary;
        const owner = worksheetData.owner;
        const maxLevel = isVertical
            ? owner.maxRowLevel
            : owner.maxLevel;
        for (const currentCol of headersForLevel) {
            const spanLength = isVertical ? currentCol.rowSpan : currentCol.columnSpan;
            if (currentCol.level === i) {
                let columnCoordinate;
                const column = isVertical
                    ? this.rowIndex
                    : startValue + (owner.maxRowLevel ?? 0);
                const rowCoordinate = isVertical
                    ? startValue + owner.maxLevel + 2
                    : this.rowIndex;
                const columnValue = dictionary.saveValue(currentCol.header, true, false);
                columnCoordinate = (currentCol.field === GRID_LEVEL_COL
                    ? ExcelStrings.getExcelColumn(worksheetData.columnCount + 1)
                    : ExcelStrings.getExcelColumn(column)) + rowCoordinate;
                rowStyle = isVertical && currentCol.rowSpan > 1 ? ' s="4"' : rowStyle;
                str = `<c r="${columnCoordinate}"${rowStyle} t="s"><v>${columnValue}</v></c>`;
                if (isVertical) {
                    if (this.pivotGridRowHeadersMap.has(rowCoordinate)) {
                        this.pivotGridRowHeadersMap.set(rowCoordinate, this.pivotGridRowHeadersMap.get(rowCoordinate) + str);
                    }
                    else {
                        this.pivotGridRowHeadersMap.set(rowCoordinate, str);
                    }
                }
                else {
                    this.sheetData += str;
                }
                if (i !== maxLevel) {
                    this.mergeCellsCounter++;
                    this.mergeCellStr += ` <mergeCell ref="${columnCoordinate}:`;
                    if (currentCol.headerType === ExportHeaderType.ColumnHeader) {
                        const col = isVertical
                            ? maxLevel
                            : startValue + (owner.maxRowLevel ?? 0);
                        const row = isVertical
                            ? rowCoordinate
                            : owner.maxLevel + 1;
                        columnCoordinate = ExcelStrings.getExcelColumn(col) + row;
                    }
                    else {
                        for (let k = 1; k < spanLength; k++) {
                            const col = isVertical
                                ? column
                                : column + k;
                            const row = isVertical
                                ? rowCoordinate + k
                                : this.rowIndex;
                            columnCoordinate = ExcelStrings.getExcelColumn(col) + row;
                            str = `<c r="${columnCoordinate}"${rowStyle} />`;
                            isVertical
                                ? this.pivotGridRowHeadersMap.set(row, str)
                                : this.sheetData += str;
                        }
                    }
                    this.mergeCellStr += `${columnCoordinate}" />`;
                }
            }
            startValue += spanLength;
        }
    }
}
/**
 * @hidden
 */
export class StyleFile {
    writeElement(folder) {
        folder['styles.xml'] = strToU8(ExcelStrings.getStyles());
    }
}
/**
 * @hidden
 */
export class WorkbookFile {
    writeElement(folder, worksheetData) {
        folder['workbook.xml'] = strToU8(ExcelStrings.getWorkbook(worksheetData.options.worksheetName));
    }
}
/**
 * @hidden
 */
export class ContentTypesFile {
    writeElement(folder, worksheetData) {
        const hasSharedStrings = !worksheetData.isEmpty || worksheetData.options.alwaysExportHeaders;
        folder['[Content_Types].xml'] = strToU8(ExcelStrings.getContentTypesXML(hasSharedStrings, worksheetData.options.exportAsTable));
    }
}
/**
 * @hidden
 */
export class SharedStringsFile {
    writeElement(folder, worksheetData) {
        const dict = worksheetData.dataDictionary;
        const sortedValues = dict.getKeys();
        const sharedStrings = new Array(sortedValues.length);
        for (const value of sortedValues) {
            sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
        }
        folder['sharedStrings.xml'] = strToU8(ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
    }
}
/**
 * @hidden
 */
export class TablesFile {
    writeElement(folder, worksheetData) {
        const columnCount = worksheetData.columnCount;
        const lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
        const autoFilterDimension = 'A1:' + lastColumn;
        const tableDimension = worksheetData.isEmpty
            ? 'A1:' + ExcelStrings.getExcelColumn(columnCount - 1) + (worksheetData.rowCount + 1)
            : autoFilterDimension;
        const hasUserSetIndex = worksheetData.owner.columns.some(c => c.exportIndex !== undefined);
        const values = hasUserSetIndex
            ? worksheetData.rootKeys
            : worksheetData.owner.columns
                .filter(c => !c.skip)
                .sort((a, b) => a.startIndex - b.startIndex)
                .sort((a, b) => a.pinnedIndex - b.pinnedIndex)
                .map(c => c.header);
        let sortString = '';
        let tableColumns = '<tableColumns count="' + columnCount + '">';
        for (let i = 0; i < columnCount; i++) {
            const value = values[i];
            tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
        }
        tableColumns += '</tableColumns>';
        if (worksheetData.sort) {
            const sortingExpression = worksheetData.sort;
            const sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
            const dir = sortingExpression.dir - 1;
            sortString = `<sortState ref="A2:${lastColumn}"><sortCondition descending="${dir}" ref="${sc}1:${sc}15"/></sortState>`;
        }
        folder['table1.xml'] = strToU8(ExcelStrings.getTablesXML(autoFilterDimension, tableDimension, tableColumns, sortString));
    }
}
/**
 * @hidden
 */
export class WorksheetRelsFile {
    writeElement(folder) {
        folder['sheet1.xml.rels'] = strToU8(ExcelStrings.getWorksheetRels());
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhjZWwtZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc2VydmljZXMvZXhjZWwvZXhjZWwtZmlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRy9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDakMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBMkMsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBRXJMOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFlBQVk7SUFDZCxZQUFZLENBQUMsTUFBYztRQUM5QixNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ3RELENBQUM7Q0FDSjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLE9BQU87SUFDVCxZQUFZLENBQUMsTUFBYyxFQUFFLGFBQTRCO1FBQzVELE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDMUYsQ0FBQztDQUNKO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sUUFBUTtJQUNWLFlBQVksQ0FBQyxNQUFjO1FBQzlCLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDekQsQ0FBQztDQUNKO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sZ0JBQWdCO0lBQ2xCLFlBQVksQ0FBQyxNQUFjLEVB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LFlBQVksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7SUFDekUsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUV4Y2VsRmlsZSB9IGZyb20gJy4vZXhjZWwtaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBFeGNlbFN0cmluZ3MgfSBmcm9tICcuL2V4Y2VsLXN0cmluZ3MnO1xuaW1wb3J0IHsgV29ya3NoZWV0RGF0YSB9IGZyb20gJy4vd29ya3NoZWV0LWRhdGEnO1xuXG5pbXBvcnQgeyBzdHJUb1U4IH0gZnJvbSAnZmZsYXRlJztcbmltcG9ydCB7IHlpZWxkaW5nTG9vcCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgRXhwb3J0SGVhZGVyVHlwZSwgRXhwb3J0UmVjb3JkVHlwZSwgSUV4cG9ydFJlY29yZCwgSUNvbHVtbkxpc3QsIElDb2x1bW5JbmZvLCBHUklEX1JPT1RfU1VNTUFSWSwgR1JJRF9QQVJFTlQsIEdSSURfTEVWRUxfQ09MIH0gZnJvbSAnLi4vZXhwb3J0ZXItY29tbW9uL2Jhc2UtZXhwb3J0LXNlcnZpY2UnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFJvb3RSZWxzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBPYmplY3QpIHtcbiAgICAgICAgZm9sZGVyWycucmVscyddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0UmVscygpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQXBwRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBPYmplY3QsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgZm9sZGVyWydhcHAueG1sJ10gPSBzdHJUb1U4KEV4Y2VsU3RyaW5ncy5nZXRBcHAod29ya3NoZWV0RGF0YS5vcHRpb25zLndvcmtzaGVldE5hbWUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQ29yZUZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogT2JqZWN0KSB7XG4gICAgICAgIGZvbGRlclsnY29yZS54bWwnXSA9IHN0clRvVTgoRXhjZWxTdHJpbmdzLmdldENvcmUoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmtib29rUmVsc0ZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogT2JqZWN0LCB3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IGhhc1NoYXJlZFN0cmluZ3MgPSAhd29ya3NoZWV0RGF0YS5pc0VtcHR5IHx8IHdvcmtzaGVldERhdGEub3B0aW9ucy5hbHdheXNFeHBvcnRIZWFkZXJzO1xuICAgICAgICBmb2xkZXJbJ3dvcmtib29rLnhtbC5yZWxzJ10gPSBzdHJUb1U4KEV4Y2VsU3RyaW5ncy5nZXRXb3JrYm9va1JlbHMoaGFzU2hhcmVkU3RyaW5ncykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBUaGVtZUZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogT2JqZWN0KSB7XG4gICAgICAgIGZvbGRlclsndGhlbWUxLnhtbCddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0VGhlbWUoKSk7XG4gICAgfVxufVxuXG5pbnRlcmZhY2UgRGltZW5zaW9ucyB7XG4gICAgc3RhcnRDb29yZGluYXRlOiBzdHJpbmdcbiAgICBlbmRDb29yZGluYXRlOiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIEN1cnJlbmN5SW5mbyB7XG4gICAgc3R5bGVYZjogbnVtYmVyXG4gICAgc3ltYm9sOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3Jrc2hlZXRGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgTUlOX1dJRFRIID0gOC40MztcbiAgICBwcml2YXRlIG1heE91dGxpbmVMZXZlbCA9IDA7XG4gICAgcHJpdmF0ZSBzaGVldERhdGEgPSAnJztcbiAgICBwcml2YXRlIGRpbWVuc2lvbiA9ICcnO1xuICAgIHByaXZhdGUgZnJlZXplUGFuZSA9ICcnO1xuICAgIHByaXZhdGUgcm93SGVpZ2h0ID0gJyc7XG5cbiAgICBwcml2YXRlIG1lcmdlQ2VsbFN0ciA9ICcnO1xuICAgIHByaXZhdGUgbWVyZ2VDZWxsc0NvdW50ZXIgPSAwO1xuICAgIHByaXZhdGUgcm93SW5kZXggPSAwO1xuICAgIHByaXZhdGUgcGl2b3RHcmlkUm93SGVhZGVyc01hcCA9IG5ldyBNYXA8bnVtYmVyLCBzdHJpbmc+KCk7XG5cbiAgICBwcml2YXRlIGRpbWVuc2lvbk1hcDogTWFwPHN0cmluZywgRGltZW5zaW9ucz4gPSBuZXcgTWFwPHN0cmluZywgRGltZW5zaW9ucz4oKTtcbiAgICBwcml2YXRlIGhpZXJhcmNoaWNhbERpbWVuc2lvbk1hcDogTWFwPGFueSwgIE1hcDxzdHJpbmcsIERpbWVuc2lvbnM+PiA9IG5ldyBNYXA8YW55LCAgTWFwPHN0cmluZywgRGltZW5zaW9ucz4+KCk7XG4gICAgcHJpdmF0ZSBjdXJyZW50U3VtbWFyeU93bmVyID0gJyc7XG4gICAgcHJpdmF0ZSBjdXJyZW50SGllcmFyY2hpY2FsT3duZXIgPSAnJztcbiAgICBwcml2YXRlIGZpcnN0Q29sdW1uID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBwcml2YXRlIGZpcnN0RGF0YVJvdyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgcHJpdmF0ZSBpc1ZhbGlkR3JpZDogYm9vbGVhbjtcbiAgICBwcml2YXRlIGxhc3RWYWxpZFJvdzogc3RyaW5nO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW5jeVN0eWxlTWFwID0gbmV3IE1hcDxzdHJpbmcsIEN1cnJlbmN5SW5mbz4oW1xuICAgICAgICBbJ1VTRCcsIHtzdHlsZVhmOiA1LCBzeW1ib2w6ICckJ31dLFxuICAgICAgICBbJ0dCUCcsIHtzdHlsZVhmOiA2LCBzeW1ib2w6ICfCoyd9XSxcbiAgICAgICAgWydDTlknLCB7c3R5bGVYZjogNywgc3ltYm9sOiAnwqUnfV0sXG4gICAgICAgIFsnRVVSJywge3N0eWxlWGY6IDgsIHN5bWJvbDogJ+KCrCd9XSxcbiAgICAgICAgWydKUFknLCB7c3R5bGVYZjogOSwgc3ltYm9sOiAnwqUnfV0sXG4gICAgXSk7XG5cbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KCkge31cblxuICAgIHB1YmxpYyBhc3luYyB3cml0ZUVsZW1lbnRBc3luYyhmb2xkZXI6IE9iamVjdCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByZXBhcmVEYXRhQXN5bmMod29ya3NoZWV0RGF0YSwgKGNvbHMsIHJvd3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNUYWJsZSA9ICghd29ya3NoZWV0RGF0YS5pc0VtcHR5IHx8IHdvcmtzaGVldERhdGEub3B0aW9ucy5hbHdheXNFeHBvcnRIZWFkZXJzKVxuICAgICAgICAgICAgICAgICAgICAmJiB3b3Jrc2hlZXREYXRhLm9wdGlvbnMuZXhwb3J0QXNUYWJsZTtcblxuICAgICAgICAgICAgICAgIGZvbGRlclsnc2hlZXQxLnhtbCddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0U2hlZXRYTUwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGltZW5zaW9uLCB0aGlzLmZyZWV6ZVBhbmUsIGNvbHMsIHJvd3MsIGhhc1RhYmxlLCB0aGlzLm1heE91dGxpbmVMZXZlbCwgd29ya3NoZWV0RGF0YS5pc0hpZXJhcmNoaWNhbCkpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHByZXBhcmVEYXRhQXN5bmMod29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSwgZG9uZTogKGNvbHM6IHN0cmluZywgc2hlZXREYXRhOiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5zaGVldERhdGEgPSAnJztcbiAgICAgICAgbGV0IGNvbHMgPSAnJztcbiAgICAgICAgY29uc3QgZGljdGlvbmFyeSA9IHdvcmtzaGVldERhdGEuZGF0YURpY3Rpb25hcnk7XG4gICAgICAgIHRoaXMucm93SW5kZXggPSAwO1xuXG4gICAgICAgIGlmICh3b3Jrc2hlZXREYXRhLmlzRW1wdHkgJiYgKCF3b3Jrc2hlZXREYXRhLm9wdGlvbnMuYWx3YXlzRXhwb3J0SGVhZGVycyB8fCB3b3Jrc2hlZXREYXRhLm93bmVyLmNvbHVtbnMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5zaGVldERhdGEgKz0gJzxzaGVldERhdGEvPic7XG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbiA9ICdBMSc7XG4gICAgICAgICAgICBkb25lKCcnLCB0aGlzLnNoZWV0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvd25lciA9IHdvcmtzaGVldERhdGEub3duZXI7XG4gICAgICAgICAgICBjb25zdCBpc0hpZXJhcmNoaWNhbEdyaWQgPSB3b3Jrc2hlZXREYXRhLmlzSGllcmFyY2hpY2FsO1xuICAgICAgICAgICAgY29uc3QgaGFzTXVsdGlDb2x1bW5IZWFkZXIgPSB3b3Jrc2hlZXREYXRhLmhhc011bHRpQ29sdW1uSGVhZGVyO1xuICAgICAgICAgICAgY29uc3QgaGFzTXVsdGlSb3dIZWFkZXIgPSB3b3Jrc2hlZXREYXRhLmhhc011bHRpUm93SGVhZGVyO1xuXG4gICAgICAgICAgICBjb25zdCBoYXNVc2VyU2V0SW5kZXggPSBvd25lci5jb2x1bW5zLnNvbWUoY29sID0+IGNvbC5leHBvcnRJbmRleCAhPT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gIHdvcmtzaGVldERhdGEub3B0aW9ucy5yb3dIZWlnaHQ7XG5cbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZEdyaWQgPSB3b3Jrc2hlZXREYXRhLmlzSGllcmFyY2hpY2FsIHx8IHdvcmtzaGVldERhdGEuaXNUcmVlR3JpZCB8fCB3b3Jrc2hlZXREYXRhLmlzR3JvdXBlZEdyaWQ7XG4gICAgICAgICAgICB0aGlzLnJvd0hlaWdodCA9IGhlaWdodCA/IGAgaHQ9XCIke2hlaWdodH1cIiBjdXN0b21IZWlnaHQ9XCIxXCJgIDogJyc7XG4gICAgICAgICAgICB0aGlzLnNoZWV0RGF0YSArPSBgPHNoZWV0RGF0YT5gO1xuXG4gICAgICAgICAgICBsZXQgaGVhZGVyc0ZvckxldmVsOiBJQ29sdW1uSW5mb1tdID0gW107XG5cbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPD0gb3duZXIubWF4Um93TGV2ZWw7IGkrKykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNGb3JMZXZlbCA9ICBvd25lci5jb2x1bW5zLmZpbHRlcihjID0+IGMubGV2ZWwgPT09IGkgJiYgYy5yb3dTcGFuID4gMCAmJiAhYy5za2lwKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludEhlYWRlcnMod29ya3NoZWV0RGF0YSwgaGVhZGVyc0ZvckxldmVsLCBpLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucm93SW5kZXgrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yb3dJbmRleCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG93bmVyLm1heExldmVsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd0luZGV4Kys7XG4gICAgICAgICAgICAgICAgY29uc3QgcGl2b3RHcmlkQ29sdW1ucyA9IHRoaXMucGl2b3RHcmlkUm93SGVhZGVyc01hcC5nZXQodGhpcy5yb3dJbmRleCkgPz8gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnNoZWV0RGF0YSArPSBgPHJvdyByPVwiJHt0aGlzLnJvd0luZGV4fVwiJHt0aGlzLnJvd0hlaWdodH0+JHtwaXZvdEdyaWRDb2x1bW5zfWA7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkQ29sdW1ucyA9IG93bmVyLmNvbHVtbnMuZmlsdGVyKGMgPT4gYy5oZWFkZXJUeXBlICE9PSBFeHBvcnRIZWFkZXJUeXBlLlJvd0hlYWRlciAmJiBjLmhlYWRlclR5cGUgIT09IEV4cG9ydEhlYWRlclR5cGUuTXVsdGlSb3dIZWFkZXIpO1xuXG4gICAgICAgICAgICAgICAgaGVhZGVyc0ZvckxldmVsID0gaGFzTXVsdGlDb2x1bW5IZWFkZXIgP1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkQ29sdW1uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjID0+IChjLmxldmVsIDwgaSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaGVhZGVyVHlwZSAhPT0gRXhwb3J0SGVhZGVyVHlwZS5NdWx0aUNvbHVtbkhlYWRlciB8fCBjLmxldmVsID09PSBpKSAmJiBjLmNvbHVtblNwYW4gPiAwICYmICFjLnNraXApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5zdGFydEluZGV4IC0gYi5zdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEucGlubmVkSW5kZXggLSBiLnBpbm5lZEluZGV4KSA6XG4gICAgICAgICAgICAgICAgICAgIGhhc1VzZXJTZXRJbmRleCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkQ29sdW1ucy5maWx0ZXIoYyA9PiAhYy5za2lwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkQ29sdW1ucy5maWx0ZXIoYyA9PiAhYy5za2lwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0SW5kZXggLSBiLnN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEucGlubmVkSW5kZXggLSBiLnBpbm5lZEluZGV4KTtcblxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRIZWFkZXJzKHdvcmtzaGVldERhdGEsIGhlYWRlcnNGb3JMZXZlbCwgaSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zaGVldERhdGEgKz0gYDwvcm93PmA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG11bHRpQ29sdW1uSGVhZGVyTGV2ZWwgPSB3b3Jrc2hlZXREYXRhLm9wdGlvbnMuaWdub3JlTXVsdGlDb2x1bW5IZWFkZXJzID8gMCA6IG93bmVyLm1heExldmVsO1xuICAgICAgICAgICAgY29uc3QgZnJlZXplSGVhZGVycyA9IHdvcmtzaGVldERhdGEub3B0aW9ucy5mcmVlemVIZWFkZXJzID8gMiArIG11bHRpQ29sdW1uSGVhZGVyTGV2ZWwgOiAxO1xuXG4gICAgICAgICAgICBpZiAoIWlzSGllcmFyY2hpY2FsR3JpZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHdvcmtzaGVldERhdGEuaGFzU3VtbWFyaWVzID8gd29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudCArIDEgOiB3b3Jrc2hlZXREYXRhLmNvbHVtbkNvdW50IC0gMVxuICAgICAgICAgICAgICAgIHRoaXMuZGltZW5zaW9uID0gJ0ExOicgKyBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oY29sKSArICh3b3Jrc2hlZXREYXRhLnJvd0NvdW50KTtcblxuICAgICAgICAgICAgICAgIGNvbHMgKz0gJzxjb2xzPic7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhhc011bHRpQ29sdW1uSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGRpY3Rpb25hcnkuY29sdW1uV2lkdGhzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB3aWR0aCBwcm92aWRlZCBpbiB0aGUgb3B0aW9ucyBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aEluVHdpcHMgPSB3b3Jrc2hlZXREYXRhLm9wdGlvbnMuY29sdW1uV2lkdGggIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3Jrc2hlZXREYXRhLm9wdGlvbnMuY29sdW1uV2lkdGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoKCh3aWR0aCAvIDk2KSAqIDE0LjQpLCBXb3Jrc2hlZXRGaWxlLk1JTl9XSURUSCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh3aWR0aEluVHdpcHMgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoSW5Ud2lwcyA9IFdvcmtzaGVldEZpbGUuTUlOX1dJRFRIO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzICs9IGA8Y29sIG1pbj1cIiR7KGogKyAxKX1cIiBtYXg9XCIkeyhqICsgMSl9XCIgd2lkdGg9XCIke3dpZHRoSW5Ud2lwc31cIiBjdXN0b21XaWR0aD1cIjFcIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHMgKz0gYDxjb2wgbWluPVwiMVwiIG1heD1cIiR7d29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudH1cIiB3aWR0aD1cIjE1XCIgY3VzdG9tV2lkdGg9XCIxXCIvPmA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhPZkxhc3RQaW5uZWRDb2x1bW4gPSB3b3Jrc2hlZXREYXRhLmluZGV4T2ZMYXN0UGlubmVkQ29sdW1uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb3plbkNvbHVtbkNvdW50ID0gaW5kZXhPZkxhc3RQaW5uZWRDb2x1bW4gKyAxO1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdENlbGwgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oZnJvemVuQ29sdW1uQ291bnQpICsgZnJlZXplSGVhZGVycztcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZkxhc3RQaW5uZWRDb2x1bW4gIT09IHVuZGVmaW5lZCAmJiBpbmRleE9mTGFzdFBpbm5lZENvbHVtbiAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgIXdvcmtzaGVldERhdGEub3B0aW9ucy5pZ25vcmVQaW5uaW5nICYmXG4gICAgICAgICAgICAgICAgICAgICF3b3Jrc2hlZXREYXRhLm9wdGlvbnMuaWdub3JlQ29sdW1uc09yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJlZXplUGFuZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBgPHBhbmUgeFNwbGl0PVwiJHtmcm96ZW5Db2x1bW5Db3VudH1cIiB5U3BsaXQ9XCIke2ZyZWV6ZUhlYWRlcnMgLSAxfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGVmdENlbGw9XCIke2ZpcnN0Q2VsbH1cIiBhY3RpdmVQYW5lPVwidG9wUmlnaHRcIiBzdGF0ZT1cImZyb3plblwiLz5gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod29ya3NoZWV0RGF0YS5vcHRpb25zLmZyZWV6ZUhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDZWxsID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKDApICsgZnJlZXplSGVhZGVycztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVlemVQYW5lID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGA8cGFuZSB4U3BsaXQ9XCIwXCIgeVNwbGl0PVwiJHtmcmVlemVIZWFkZXJzIC0gMX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnRDZWxsPVwiJHtmaXJzdENlbGx9XCIgYWN0aXZlUGFuZT1cInRvcFJpZ2h0XCIgc3RhdGU9XCJmcm96ZW5cIi8+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbldpZHRoID0gd29ya3NoZWV0RGF0YS5vcHRpb25zLmNvbHVtbldpZHRoID8gd29ya3NoZWV0RGF0YS5vcHRpb25zLmNvbHVtbldpZHRoIDogMjA7XG4gICAgICAgICAgICAgICAgY29scyArPSBgPGNvbHM+PGNvbCBtaW49XCIxXCIgbWF4PVwiJHt3b3Jrc2hlZXREYXRhLmNvbHVtbkNvdW50fVwiIHdpZHRoPVwiJHtjb2x1bW5XaWR0aH1cIiBjdXN0b21XaWR0aD1cIjFcIi8+YDtcblxuICAgICAgICAgICAgICAgIGlmICh3b3Jrc2hlZXREYXRhLm9wdGlvbnMuZnJlZXplSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdENlbGwgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oMCkgKyBmcmVlemVIZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWV6ZVBhbmUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYDxwYW5lIHhTcGxpdD1cIjBcIiB5U3BsaXQ9XCIke2ZyZWV6ZUhlYWRlcnMgLSAxfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGVmdENlbGw9XCIke2ZpcnN0Q2VsbH1cIiBhY3RpdmVQYW5lPVwidG9wUmlnaHRcIiBzdGF0ZT1cImZyb3plblwiLz5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtzaGVldERhdGEuaGFzU3VtbWFyaWVzKSB7XG4gICAgICAgICAgICAgICAgY29scyArPSBgPGNvbCBtaW49XCIke3dvcmtzaGVldERhdGEuY29sdW1uQ291bnQgKyAyfVwiIG1heD1cIiR7d29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudCArIDJ9XCIgaGlkZGVuPVwiMVwiLz5gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2xzICs9ICc8L2NvbHM+JztcblxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRGF0YVJlY29yZHNBc3luYyh3b3Jrc2hlZXREYXRhLCAocm93cykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hlZXREYXRhICs9IHJvd3M7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGVldERhdGEgKz0gJzwvc2hlZXREYXRhPic7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGhhc011bHRpQ29sdW1uSGVhZGVyIHx8IGhhc011bHRpUm93SGVhZGVyKSAmJiB0aGlzLm1lcmdlQ2VsbHNDb3VudGVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoZWV0RGF0YSArPSBgPG1lcmdlQ2VsbHMgY291bnQ9XCIke3RoaXMubWVyZ2VDZWxsc0NvdW50ZXJ9XCI+JHt0aGlzLm1lcmdlQ2VsbFN0cn08L21lcmdlQ2VsbHM+YDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb25lKGNvbHMsIHRoaXMuc2hlZXREYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcm9jZXNzRGF0YVJlY29yZHNBc3luYyh3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhLCBkb25lOiAocm93czogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgICAgIGNvbnN0IHJvd0RhdGFBcnIgPSBbXTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gIHdvcmtzaGVldERhdGEub3B0aW9ucy5yb3dIZWlnaHQ7XG4gICAgICAgIHRoaXMucm93SGVpZ2h0ID0gaGVpZ2h0ID8gJyBodD1cIicgKyBoZWlnaHQgKyAnXCIgY3VzdG9tSGVpZ2h0PVwiMVwiJyA6ICcnO1xuXG4gICAgICAgIGNvbnN0IGlzSGllcmFyY2hpY2FsR3JpZCA9IHdvcmtzaGVldERhdGEuaXNIaWVyYXJjaGljYWw7XG4gICAgICAgIGNvbnN0IGhhc1VzZXJTZXRJbmRleCA9IHdvcmtzaGVldERhdGEub3duZXIuY29sdW1ucy5zb21lKGMgPT4gYy5leHBvcnRJbmRleCAhPT0gdW5kZWZpbmVkKTtcblxuICAgICAgICBsZXQgcmVjb3JkSGVhZGVycyA9IFtdO1xuXG4gICAgICAgIHlpZWxkaW5nTG9vcCh3b3Jrc2hlZXREYXRhLnJvd0NvdW50IC0gd29ya3NoZWV0RGF0YS5tdWx0aUNvbHVtbkhlYWRlclJvd3MgLSAxLCAxMDAwLFxuICAgICAgICAgICAgKGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmtzaGVldERhdGEuaXNFbXB0eSl7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNIaWVyYXJjaGljYWxHcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVXNlclNldEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkSGVhZGVycyA9IHdvcmtzaGVldERhdGEucm9vdEtleXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZEhlYWRlcnMgPSB3b3Jrc2hlZXREYXRhLm93bmVyLmNvbHVtbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjID0+IGMuaGVhZGVyVHlwZSA9PT0gRXhwb3J0SGVhZGVyVHlwZS5Db2x1bW5IZWFkZXIgJiYgIWMuc2tpcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRJbmRleC1iLnN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnBpbm5lZEluZGV4LWIucGlubmVkSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHdvcmtzaGVldERhdGEuZGF0YVtpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLkhlYWRlclJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZE93bmVyID0gd29ya3NoZWV0RGF0YS5vd25lcnMuZ2V0KHJlY29yZC5vd25lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTXVsdGlDb2x1bW5IZWFkZXJzID0gcmVjb3JkT3duZXIuY29sdW1ucy5zb21lKGMgPT4gIWMuc2tpcCAmJiBjLmhlYWRlclR5cGUgPT09IEV4cG9ydEhlYWRlclR5cGUuTXVsdGlDb2x1bW5IZWFkZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc011bHRpQ29sdW1uSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhHcmlkUHJpbnRNdWx0aUNvbEhlYWRlcnMod29ya3NoZWV0RGF0YSwgcm93RGF0YUFyciwgcmVjb3JkLCByZWNvcmRPd25lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRIZWFkZXJzID0gT2JqZWN0LmtleXMod29ya3NoZWV0RGF0YS5kYXRhW2ldLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcm93RGF0YUFyci5wdXNoKHRoaXMucHJvY2Vzc1Jvdyh3b3Jrc2hlZXREYXRhLCBpLCByZWNvcmRIZWFkZXJzLCBpc0hpZXJhcmNoaWNhbEdyaWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvbmUocm93RGF0YUFyci5qb2luKCcnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgaEdyaWRQcmludE11bHRpQ29sSGVhZGVycyh3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhLCByb3dEYXRhQXJyOiBhbnlbXSwgcmVjb3JkOiBJRXhwb3J0UmVjb3JkLFxuICAgICAgICBvd25lcjogSUNvbHVtbkxpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvd25lci5tYXhMZXZlbDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmRMZXZlbCA9IHJlY29yZC5sZXZlbDtcbiAgICAgICAgICAgIGNvbnN0IG91dGxpbmVMZXZlbCA9IHJlY29yZExldmVsID4gMCA/IGAgb3V0bGluZUxldmVsPVwiJHtyZWNvcmRMZXZlbH1cImAgOiAnJztcbiAgICAgICAgICAgIHRoaXMubWF4T3V0bGluZUxldmVsID0gdGhpcy5tYXhPdXRsaW5lTGV2ZWwgPCByZWNvcmRMZXZlbCA/IHJlY29yZExldmVsIDogdGhpcy5tYXhPdXRsaW5lTGV2ZWw7XG4gICAgICAgICAgICBjb25zdCBzSGlkZGVuID0gcmVjb3JkLmhpZGRlbiA/IGAgaGlkZGVuPVwiMVwiYCA6ICcnO1xuXG4gICAgICAgICAgICB0aGlzLnJvd0luZGV4Kys7XG4gICAgICAgICAgICBsZXQgcm93ID0gYDxyb3cgcj1cIiR7dGhpcy5yb3dJbmRleH1cIiR7dGhpcy5yb3dIZWlnaHR9JHtvdXRsaW5lTGV2ZWx9JHtzSGlkZGVufT5gO1xuXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzRm9yTGV2ZWwgPSBvd25lci5jb2x1bW5zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihjID0+IChjLmxldmVsIDwgaiAmJlxuICAgICAgICAgICAgICAgICAgICBjLmhlYWRlclR5cGUgIT09IEV4cG9ydEhlYWRlclR5cGUuTXVsdGlDb2x1bW5IZWFkZXIgfHwgYy5sZXZlbCA9PT0gaikgJiYgYy5jb2x1bW5TcGFuID4gMCAmJiAhYy5za2lwKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0SW5kZXggLSBiLnN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEucGlubmVkSW5kZXggLSBiLnBpbm5lZEluZGV4KTtcblxuICAgICAgICAgICAgbGV0IHN0YXJ0VmFsdWUgPSAwICsgcmVjb3JkLmxldmVsO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRDb2wgb2YgaGVhZGVyc0ZvckxldmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDb2wubGV2ZWwgPT09IGopIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbHVtbkNvb3JkaW5hdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkNvb3JkaW5hdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKHN0YXJ0VmFsdWUpICsgdGhpcy5yb3dJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5WYWx1ZSA9IHdvcmtzaGVldERhdGEuZGF0YURpY3Rpb25hcnkuc2F2ZVZhbHVlKGN1cnJlbnRDb2wuaGVhZGVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcm93ICs9IGA8YyByPVwiJHtjb2x1bW5Db29yZGluYXRlfVwiIHM9XCIzXCIgdD1cInNcIj48dj4ke2NvbHVtblZhbHVlfTwvdj48L2M+YDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gb3duZXIubWF4TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VDZWxsc0NvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VDZWxsU3RyICs9IGAgPG1lcmdlQ2VsbCByZWY9XCIke2NvbHVtbkNvb3JkaW5hdGV9OmA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q29sLmhlYWRlclR5cGUgPT09IEV4cG9ydEhlYWRlclR5cGUuQ29sdW1uSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQ29vcmRpbmF0ZSA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihzdGFydFZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnJvd0luZGV4ICsgb3duZXIubWF4TGV2ZWwgLSBjdXJyZW50Q29sLmxldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCBjdXJyZW50Q29sLmNvbHVtblNwYW47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5Db29yZGluYXRlID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKHN0YXJ0VmFsdWUgKyBrKSArIHRoaXMucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyArPSBgPGMgcj1cIiR7Y29sdW1uQ29vcmRpbmF0ZX1cIiBzPVwiM1wiIC8+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VDZWxsU3RyICs9IGAke2NvbHVtbkNvb3JkaW5hdGV9XCIgLz5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZSArPSBjdXJyZW50Q29sLmNvbHVtblNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3cgKz0gYDwvcm93PmA7XG4gICAgICAgICAgICByb3dEYXRhQXJyLnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcHJvY2Vzc1Jvdyh3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhLCBpOiBudW1iZXIsIGhlYWRlcnNGb3JMZXZlbDogYW55W10sIGlzSGllcmFyY2hpY2FsR3JpZDogYm9vbGVhbikge1xuICAgICAgICBjb25zdCByZWNvcmQgPSB3b3Jrc2hlZXREYXRhLmRhdGFbaV07XG5cbiAgICAgICAgY29uc3Qgcm93RGF0YSA9IG5ldyBBcnJheSh3b3Jrc2hlZXREYXRhLmNvbHVtbkNvdW50ICsgMik7XG5cbiAgICAgICAgY29uc3Qgcm93TGV2ZWwgPSByZWNvcmQubGV2ZWw7XG4gICAgICAgIGNvbnN0IG91dGxpbmVMZXZlbCA9IHJvd0xldmVsID4gMCA/IGAgb3V0bGluZUxldmVsPVwiJHtyb3dMZXZlbH1cImAgOiAnJztcbiAgICAgICAgdGhpcy5tYXhPdXRsaW5lTGV2ZWwgPSB0aGlzLm1heE91dGxpbmVMZXZlbCA8IHJvd0xldmVsID8gcm93TGV2ZWwgOiB0aGlzLm1heE91dGxpbmVMZXZlbDtcblxuICAgICAgICBjb25zdCBzSGlkZGVuID0gcmVjb3JkLmhpZGRlbiA/IGAgaGlkZGVuPVwiMVwiYCA6ICcnO1xuXG4gICAgICAgIHRoaXMucm93SW5kZXgrKztcbiAgICAgICAgY29uc3QgcGl2b3RHcmlkQ29sdW1ucyA9IHRoaXMucGl2b3RHcmlkUm93SGVhZGVyc01hcC5nZXQodGhpcy5yb3dJbmRleCkgPz8gXCJcIjtcblxuICAgICAgICByb3dEYXRhWzBdID0gYDxyb3cgcj1cIiR7dGhpcy5yb3dJbmRleH1cIiR7dGhpcy5yb3dIZWlnaHR9JHtvdXRsaW5lTGV2ZWx9JHtzSGlkZGVufT4ke3Bpdm90R3JpZENvbHVtbnN9YDtcbiAgICAgICAgY29uc3Qga2V5cyA9IHdvcmtzaGVldERhdGEuaXNTcGVjaWFsRGF0YSA/IFtyZWNvcmQuZGF0YV0gOiBoZWFkZXJzRm9yTGV2ZWw7XG4gICAgICAgIGNvbnN0IGlzRGF0YVJlY29yZCA9IHJlY29yZC50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLkhpZXJhcmNoaWNhbEdyaWRSZWNvcmRcbiAgICAgICAgICAgIHx8IHJlY29yZC50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLkRhdGFSZWNvcmRcbiAgICAgICAgICAgIHx8IHJlY29yZC50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLkdyb3VwZWRSZWNvcmRcbiAgICAgICAgICAgIHx8IHJlY29yZC50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLlRyZWVHcmlkUmVjb3JkO1xuXG4gICAgICAgIGNvbnN0IGlzVmFsaWRSZWNvcmRUeXBlID0gaXNEYXRhUmVjb3JkIHx8IHJlY29yZC50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLlN1bW1hcnlSZWNvcmQ7XG5cbiAgICAgICAgaWYgKGlzVmFsaWRSZWNvcmRUeXBlICYmIHdvcmtzaGVldERhdGEuaGFzU3VtbWFyaWVzKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVTdW1tYXJ5RGltZW5zaW9ucyhyZWNvcmQsIGlzRGF0YVJlY29yZCwgd29ya3NoZWV0RGF0YS5pc0dyb3VwZWRHcmlkKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2wgPSBqICsgKGlzSGllcmFyY2hpY2FsR3JpZCA/IHJvd0xldmVsIDogd29ya3NoZWV0RGF0YS5pc1Bpdm90R3JpZCA/IHdvcmtzaGVldERhdGEub3duZXIubWF4Um93TGV2ZWwgOiAwKTtcblxuICAgICAgICAgICAgY29uc3QgY2VsbERhdGEgPSB0aGlzLmdldENlbGxEYXRhKHdvcmtzaGVldERhdGEsIGksIGNvbCwga2V5c1tqXSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGFbaiArIDFdID0gY2VsbERhdGE7XG4gICAgICAgIH1cblxuICAgICAgICByb3dEYXRhW2tleXMubGVuZ3RoICsgMV0gPSAnPC9yb3c+JztcblxuICAgICAgICByZXR1cm4gcm93RGF0YS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENlbGxEYXRhKHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEsIHJvdzogbnVtYmVyLCBjb2x1bW46IG51bWJlciwga2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBkaWN0aW9uYXJ5ID0gd29ya3NoZWV0RGF0YS5kYXRhRGljdGlvbmFyeTtcbiAgICAgICAgbGV0IGNvbHVtbk5hbWUgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oY29sdW1uKSArICh0aGlzLnJvd0luZGV4KTtcbiAgICAgICAgY29uc3QgZnVsbFJvdyA9IHdvcmtzaGVldERhdGEuZGF0YVtyb3ddO1xuICAgICAgICBjb25zdCBpc0hlYWRlclJlY29yZCA9IGZ1bGxSb3cudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5IZWFkZXJSZWNvcmQ7XG4gICAgICAgIGNvbnN0IGlzU3VtbWFyeVJlY29yZCA9IGZ1bGxSb3cudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5TdW1tYXJ5UmVjb3JkO1xuICAgICAgICBjb25zdCBpc1ZhbGlkUmVjb3JkVHlwZSA9IGZ1bGxSb3cudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5Hcm91cGVkUmVjb3JkXG4gICAgICAgICAgICB8fCBmdWxsUm93LnR5cGUgPT09IEV4cG9ydFJlY29yZFR5cGUuRGF0YVJlY29yZFxuICAgICAgICAgICAgfHwgZnVsbFJvdy50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLkhpZXJhcmNoaWNhbEdyaWRSZWNvcmRcbiAgICAgICAgICAgIHx8IGZ1bGxSb3cudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5UcmVlR3JpZFJlY29yZDtcblxuICAgICAgICB0aGlzLmZpcnN0RGF0YVJvdyA9IHRoaXMuZmlyc3REYXRhUm93ID4gdGhpcy5yb3dJbmRleCA/IHRoaXMucm93SW5kZXggOiB0aGlzLmZpcnN0RGF0YVJvdztcblxuICAgICAgICBjb25zdCBjZWxsVmFsdWUgPSB3b3Jrc2hlZXREYXRhLmlzU3BlY2lhbERhdGEgP1xuICAgICAgICAgICAgZnVsbFJvdy5kYXRhIDpcbiAgICAgICAgICAgIGZ1bGxSb3cuZGF0YVtrZXldO1xuXG4gICAgICAgIGlmIChjZWxsVmFsdWUgPT09IEdSSURfTEVWRUxfQ09MIHx8IGtleSA9PT0gR1JJRF9MRVZFTF9DT0wpIHtcbiAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4od29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudCArIDEpICsgKHRoaXMucm93SW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdvcmtzaGVldERhdGEuaGFzU3VtbWFyaWVzICYmIChpc1ZhbGlkUmVjb3JkVHlwZSB8fCAod29ya3NoZWV0RGF0YS5pc0dyb3VwZWRHcmlkICYmIGlzU3VtbWFyeVJlY29yZCkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN1bW1hcnlDb29yZGluYXRlcyhjb2x1bW5OYW1lLCBrZXksIGZ1bGxSb3cuaGllcmFyY2hpY2FsT3duZXIsIHdvcmtzaGVldERhdGEuaXNHcm91cGVkR3JpZCAmJiBpc1N1bW1hcnlSZWNvcmQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnVsbFJvdy5zdW1tYXJ5S2V5ICYmIGZ1bGxSb3cuc3VtbWFyeUtleSA9PT0gR1JJRF9ST09UX1NVTU1BUlkgJiYga2V5ICE9PSBHUklEX0xFVkVMX0NPTCAmJiB3b3Jrc2hlZXREYXRhLmlzR3JvdXBlZEdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Um9vdFN1bW1hcnlTdGFydENvb3JkaW5hdGUoY29sdW1uLCBrZXkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5maXJzdENvbHVtbiA+IGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Um9vdFN1bW1hcnlTdGFydENvb3JkaW5hdGUod29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudCArIDEsIEdSSURfTEVWRUxfQ09MKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0Q29sdW1uID0gY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0Q29sQXJyID0gQXJyYXkuZnJvbSh3b3Jrc2hlZXREYXRhLm93bmVycy52YWx1ZXMoKSkubWFwKGFyciA9PiBhcnIuY29sdW1ucykuZmluZChwcm9kdWN0ID0+IHByb2R1Y3Quc29tZShpdGVtID0+IGl0ZW0uZmllbGQgPT09IGtleSkpO1xuICAgICAgICBjb25zdCB0YXJnZXRDb2wgPSB0YXJnZXRDb2xBcnIgPyB0YXJnZXRDb2xBcnIuZmluZChjb2wgPT4gY29sLmZpZWxkID09PSBrZXkpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICgoY2VsbFZhbHVlID09PSB1bmRlZmluZWQgfHwgY2VsbFZhbHVlID09PSBudWxsKSAmJiAhd29ya3NoZWV0RGF0YS5oYXNTdW1tYXJpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBgPGMgcj1cIiR7Y29sdW1uTmFtZX1cIiBzPVwiMVwiLz5gO1xuICAgICAgICB9IGVsc2UgaWYgKCh3b3Jrc2hlZXREYXRhLmhhc1N1bW1hcmllcyAmJiAoaXNWYWxpZFJlY29yZFR5cGUgfHwgaXNIZWFkZXJSZWNvcmQpKSB8fCAhd29ya3NoZWV0RGF0YS5oYXNTdW1tYXJpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhdmVkVmFsdWUgPSBkaWN0aW9uYXJ5LnNhdmVWYWx1ZShjZWxsVmFsdWUsIGlzSGVhZGVyUmVjb3JkKTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2F2ZWRBc1N0cmluZyA9IHNhdmVkVmFsdWUgIT09IC0xO1xuXG4gICAgICAgICAgICBjb25zdCBpc1NhdmVkQXNEYXRlID0gIWlzU2F2ZWRBc1N0cmluZyAmJiBjZWxsVmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xuXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBpc1NhdmVkQXNTdHJpbmcgPyBzYXZlZFZhbHVlIDogY2VsbFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaXNTYXZlZEFzRGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVab25lT2Zmc2V0ID0gdmFsdWUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzb1N0cmluZyA9IChuZXcgRGF0ZSh2YWx1ZSAtIHRpbWVab25lT2Zmc2V0KSkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGlzb1N0cmluZy5zdWJzdHJpbmcoMCwgaXNvU3RyaW5nLmluZGV4T2YoJy4nKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBpc1NhdmVkQXNTdHJpbmcgPyBgIHQ9XCJzXCJgIDogaXNTYXZlZEFzRGF0ZSA/IGAgdD1cImRcImAgOiAnJztcblxuICAgICAgICAgICAgY29uc3QgaXNUaW1lID0gdGFyZ2V0Q29sPy5kYXRhVHlwZSA9PT0gJ3RpbWUnO1xuICAgICAgICAgICAgY29uc3QgaXNEYXRlVGltZSA9IHRhcmdldENvbD8uZGF0YVR5cGUgPT09ICdkYXRlVGltZSc7XG4gICAgICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2UgPSB0YXJnZXRDb2w/LmRhdGFUeXBlID09PSAncGVyY2VudCc7XG4gICAgICAgICAgICBjb25zdCBpc0NvbHVtbkN1cnJlbmN5VHlwZSA9IHRhcmdldENvbD8uZGF0YVR5cGUgPT09ICdjdXJyZW5jeSc7XG5cbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGlzUGVyY2VudGFnZSA/IGAgcz1cIjEyXCJgIDogaXNEYXRlVGltZSA/IGAgcz1cIjExXCJgIDogaXNUaW1lID8gYCBzPVwiMTBcImAgOiBpc0hlYWRlclJlY29yZCA/IGAgcz1cIjNcImAgOiBpc1NhdmVkQXNTdHJpbmcgPyAnJyA6IGlzU2F2ZWRBc0RhdGUgPyBgIHM9XCIyXCJgIDogaXNDb2x1bW5DdXJyZW5jeVR5cGUgPyBgIHM9XCIke3RoaXMuY3VycmVuY3lTdHlsZU1hcC5nZXQodGFyZ2V0Q29sLmN1cnJlbmN5Q29kZSk/LnN0eWxlWGYgfHwgMH1cImAgOiBgIHM9XCIxXCJgO1xuXG4gICAgICAgICAgICByZXR1cm4gYDxjIHI9XCIke2NvbHVtbk5hbWV9XCIke3R5cGV9JHtmb3JtYXR9Pjx2PiR7dmFsdWV9PC92PjwvYz5gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN1bW1hcnlGdW5jID0gYFwiJHtjZWxsVmFsdWUgPz8gXCJcIn1cImA7XG5cbiAgICAgICAgICAgIGlmIChpc1N1bW1hcnlSZWNvcmQgJiYgY2VsbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uTWFwS2V5ID0gdGhpcy5pc1ZhbGlkR3JpZCA/IGZ1bGxSb3cuaGllcmFyY2hpY2FsT3duZXIgPz8gR1JJRF9QQVJFTlQgOiBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxldmVsID0gd29ya3NoZWV0RGF0YS5pc0dyb3VwZWRHcmlkID8gd29ya3NoZWV0RGF0YS5tYXhMZXZlbCA6IGZ1bGxSb3cubGV2ZWw7XG5cbiAgICAgICAgICAgICAgICBzdW1tYXJ5RnVuYyA9IHRoaXMuZ2V0U3VtbWFyeUZ1bmN0aW9uKGNlbGxWYWx1ZS5sYWJlbCwga2V5LCBkaW1lbnNpb25NYXBLZXksIGxldmVsLCB0YXJnZXRDb2wpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzdW1tYXJ5RnVuYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsU3RyID0gYCR7Y2VsbFZhbHVlLmxhYmVsfTogJHtjZWxsVmFsdWUudmFsdWV9YDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2F2ZWRWYWx1ZSA9IGRpY3Rpb25hcnkuc2F2ZVZhbHVlKGNlbGxTdHIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA8YyByPVwiJHtjb2x1bW5OYW1lfVwiIHQ9XCJzXCIgcz1cIjFcIj48dj4ke3NhdmVkVmFsdWV9PC92PjwvYz5gO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBgPGMgcj1cIiR7Y29sdW1uTmFtZX1cIj48ZiB0PVwiYXJyYXlcIiByZWY9XCIke2NvbHVtbk5hbWV9XCI+JHtzdW1tYXJ5RnVuY308L2Y+PC9jPmA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBgPGMgcj1cIiR7Y29sdW1uTmFtZX1cIiBzPVwiMVwiPjxmPiR7c3VtbWFyeUZ1bmN9PC9mPjwvYz5gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNvbHZlU3VtbWFyeURpbWVuc2lvbnMocmVjb3JkOiBJRXhwb3J0UmVjb3JkLCBpc0RhdGFSZWNvcmQ6IGJvb2xlYW4sIGlzR3JvdXBlZEdyaWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZEdyaWQgJiZcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEhpZXJhcmNoaWNhbE93bmVyICE9PSAnJyAmJlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SGllcmFyY2hpY2FsT3duZXIgIT09IHJlY29yZC5vd25lciAmJlxuICAgICAgICAgICAgIXRoaXMuaGllcmFyY2hpY2FsRGltZW5zaW9uTWFwLmdldCh0aGlzLmN1cnJlbnRIaWVyYXJjaGljYWxPd25lcikpIHtcbiAgICAgICAgICAgIHRoaXMuaGllcmFyY2hpY2FsRGltZW5zaW9uTWFwLnNldCh0aGlzLmN1cnJlbnRIaWVyYXJjaGljYWxPd25lciwgbmV3IE1hcCh0aGlzLmRpbWVuc2lvbk1hcCkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEYXRhUmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U3VtbWFyeU93bmVyICE9PSByZWNvcmQuc3VtbWFyeUtleSB8fCB0aGlzLmN1cnJlbnRIaWVyYXJjaGljYWxPd25lciAhPT0gcmVjb3JkLmhpZXJhcmNoaWNhbE93bmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaW1lbnNpb25NYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3VtbWFyeU93bmVyID0gcmVjb3JkLnN1bW1hcnlLZXk7XG5cbiAgICAgICAgICAgIC8vIEZvciBncm91cGVkIGdyaWQgd2UgbmVlZCB0byByZXNldCB0aGUgcGFyZW50IG1hcFxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgc3RhcnRDb29yZGluYXRlIGZvciBlYWNoIHJlY29yZFxuICAgICAgICAgICAgaWYgKGlzR3JvdXBlZEdyaWQgJiYgdGhpcy5jdXJyZW50SGllcmFyY2hpY2FsT3duZXIgIT09ICcnICYmIHJlY29yZC5oaWVyYXJjaGljYWxPd25lciA9PT0gR1JJRF9QQVJFTlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbERpbWVuc2lvbk1hcC5kZWxldGUoR1JJRF9QQVJFTlQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudEhpZXJhcmNoaWNhbE93bmVyID0gcmVjb3JkLmhpZXJhcmNoaWNhbE93bmVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRTdW1tYXJ5Q29vcmRpbmF0ZXMoY29sdW1uTmFtZTogc3RyaW5nLCBrZXk6IHN0cmluZywgaGllcmFyY2hpY2FsT3duZXI6IHN0cmluZywgdXNlTGFzdFZhbGlkRW5kQ29vcmRpbmF0ZTogYm9vbGVhbikge1xuICAgICAgICBjb25zdCB0YXJnZXREaW1lbnNpb25NYXAgPSB0aGlzLmhpZXJhcmNoaWNhbERpbWVuc2lvbk1hcC5nZXQoaGllcmFyY2hpY2FsT3duZXIpID8/IHRoaXMuZGltZW5zaW9uTWFwO1xuXG4gICAgICAgIGlmICghdGFyZ2V0RGltZW5zaW9uTWFwLmdldChrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsRGltZW5zaW9uczogRGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydENvb3JkaW5hdGU6IGNvbHVtbk5hbWUsXG4gICAgICAgICAgICAgICAgZW5kQ29vcmRpbmF0ZTogY29sdW1uTmFtZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGFyZ2V0RGltZW5zaW9uTWFwLnNldChrZXksIGluaXRpYWxEaW1lbnNpb25zKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHVzZUxhc3RWYWxpZEVuZENvb3JkaW5hdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVuZENvb3JkaW5hdGVzKHRhcmdldERpbWVuc2lvbk1hcCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldERpbWVuc2lvbk1hcC5nZXQoa2V5KS5lbmRDb29yZGluYXRlID0gY29sdW1uTmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RWYWxpZFJvdyA9IHRhcmdldERpbWVuc2lvbk1hcC5nZXQoa2V5KS5lbmRDb29yZGluYXRlLm1hdGNoKC9bYS16XSt8W15hLXpdKy9naSlbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRHcmlkICYmICF1c2VMYXN0VmFsaWRFbmRDb29yZGluYXRlICYmIGhpZXJhcmNoaWNhbE93bmVyICE9PSBHUklEX1BBUkVOVCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TWFwID0gdGhpcy5oaWVyYXJjaGljYWxEaW1lbnNpb25NYXAuZ2V0KEdSSURfUEFSRU5UKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RW5kQ29vcmRpbmF0ZXMocGFyZW50TWFwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0RW5kQ29vcmRpbmF0ZXMobWFwOiBNYXA8c3RyaW5nLCBEaW1lbnNpb25zPiwgdXNlTGFzdFZhbGlkRW5kQ29vcmRpbmF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBtYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbE5hbWUgPSBhLmVuZENvb3JkaW5hdGUubWF0Y2goL1thLXpdK3xbXmEtel0rL2dpKVswXTtcbiAgICAgICAgICAgIGEuZW5kQ29vcmRpbmF0ZSA9IGAke2NvbE5hbWV9JHt1c2VMYXN0VmFsaWRFbmRDb29yZGluYXRlID8gdGhpcy5sYXN0VmFsaWRSb3cgOiB0aGlzLnJvd0luZGV4fWA7XG4gICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRTdW1tYXJ5RnVuY3Rpb24odHlwZTogc3RyaW5nLCBrZXk6IHN0cmluZywgZGltZW5zaW9uTWFwS2V5OiBhbnksIHJlY29yZExldmVsOiBudW1iZXIsIGNvbDogSUNvbHVtbkluZm8pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBkaW1lbnNpb25NYXAgPSBkaW1lbnNpb25NYXBLZXkgPyB0aGlzLmhpZXJhcmNoaWNhbERpbWVuc2lvbk1hcC5nZXQoZGltZW5zaW9uTWFwS2V5KSA6IHRoaXMuZGltZW5zaW9uTWFwO1xuICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gZGltZW5zaW9uTWFwLmdldChrZXkpO1xuICAgICAgICBjb25zdCBsZXZlbERpbWVuc2lvbnMgPSBkaW1lbnNpb25NYXAuZ2V0KEdSSURfTEVWRUxfQ09MKTtcblxuICAgICAgICBsZXQgZnVuYyA9ICcnO1xuICAgICAgICBsZXQgZnVuY1R5cGUgPSAnJztcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBjb25zdCBjdXJyZW5jeUluZm8gPSB0aGlzLmN1cnJlbmN5U3R5bGVNYXAuZ2V0KGNvbC5jdXJyZW5jeUNvZGUpO1xuXG4gICAgICAgIHN3aXRjaCh0eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjb3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgXCJDb3VudDogXCImYW1wO194bGZuLkNPVU5USUYoJHtsZXZlbERpbWVuc2lvbnMuc3RhcnRDb29yZGluYXRlfToke2xldmVsRGltZW5zaW9ucy5lbmRDb29yZGluYXRlfSwgJHtyZWNvcmRMZXZlbH0pYFxuICAgICAgICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICAgICAgICAgIGZ1bmMgPSBgX3hsZm4uTUlOKF94bGZuLklGKCR7bGV2ZWxEaW1lbnNpb25zLnN0YXJ0Q29vcmRpbmF0ZX06JHtsZXZlbERpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX09JHtyZWNvcmRMZXZlbH0sICR7ZGltZW5zaW9ucy5zdGFydENvb3JkaW5hdGV9OiR7ZGltZW5zaW9ucy5lbmRDb29yZGluYXRlfSkpYFxuICAgICAgICAgICAgICAgIGZ1bmNUeXBlID0gYFwiTWluOiBcIiZhbXA7YDtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNUeXBlICsgKGNvbC5kYXRhVHlwZSA9PT0gJ2N1cnJlbmN5JyAmJiBjdXJyZW5jeUluZm9cbiAgICAgICAgICAgICAgICAgICAgPyBgX3hsZm4uVEVYVCgke2Z1bmN9LCBcIiR7Y3VycmVuY3lJbmZvLnN5bWJvbH0jLCMjMC4wMFwiKWBcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtmdW5jfWApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgY2FzZSBcIm1heFwiOlxuICAgICAgICAgICAgICAgIGZ1bmMgPSBgX3hsZm4uTUFYKF94bGZuLklGKCR7bGV2ZWxEaW1lbnNpb25zLnN0YXJ0Q29vcmRpbmF0ZX06JHtsZXZlbERpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX09JHtyZWNvcmRMZXZlbH0sICR7ZGltZW5zaW9ucy5zdGFydENvb3JkaW5hdGV9OiR7ZGltZW5zaW9ucy5lbmRDb29yZGluYXRlfSkpYFxuICAgICAgICAgICAgICAgIGZ1bmNUeXBlID0gYFwiTWF4OiBcIiZhbXA7YDtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNUeXBlICsgKGNvbC5kYXRhVHlwZSA9PT0gJ2N1cnJlbmN5JyAmJiBjdXJyZW5jeUluZm9cbiAgICAgICAgICAgICAgICAgICAgPyBgX3hsZm4uVEVYVCgke2Z1bmN9LCBcIiR7Y3VycmVuY3lJbmZvLnN5bWJvbH0jLCMjMC4wMFwiKWBcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtmdW5jfWApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgY2FzZSBcInN1bVwiOlxuICAgICAgICAgICAgICAgIGZ1bmMgPSAgYF94bGZuLlNVTUlGKCR7bGV2ZWxEaW1lbnNpb25zLnN0YXJ0Q29vcmRpbmF0ZX06JHtsZXZlbERpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX0sICR7cmVjb3JkTGV2ZWx9LCAke2RpbWVuc2lvbnMuc3RhcnRDb29yZGluYXRlfToke2RpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX0pYFxuICAgICAgICAgICAgICAgIGZ1bmNUeXBlID0gYFwiU3VtOiBcIiZhbXA7YDtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNUeXBlICsgKGNvbC5kYXRhVHlwZSA9PT0gJ2N1cnJlbmN5JyAmJiBjdXJyZW5jeUluZm9cbiAgICAgICAgICAgICAgICAgICAgPyBgX3hsZm4uVEVYVCgke2Z1bmN9LCBcIiR7Y3VycmVuY3lJbmZvLnN5bWJvbH0jLCMjMC4wMFwiKWBcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtmdW5jfWApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgY2FzZSBcImF2Z1wiOlxuICAgICAgICAgICAgICAgIGZ1bmMgPSBgX3hsZm4uQVZFUkFHRUlGKCR7bGV2ZWxEaW1lbnNpb25zLnN0YXJ0Q29vcmRpbmF0ZX06JHtsZXZlbERpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX0sICR7cmVjb3JkTGV2ZWx9LCAke2RpbWVuc2lvbnMuc3RhcnRDb29yZGluYXRlfToke2RpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX0pYFxuICAgICAgICAgICAgICAgIGZ1bmNUeXBlID0gYFwiQXZnOiBcIiZhbXA7YDtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNUeXBlICsgKGNvbC5kYXRhVHlwZSA9PT0gJ2N1cnJlbmN5JyAmJiBjdXJyZW5jeUluZm9cbiAgICAgICAgICAgICAgICAgICAgPyBgX3hsZm4uVEVYVCgke2Z1bmN9LCBcIiR7Y3VycmVuY3lJbmZvLnN5bWJvbH0jLCMjMC4wMFwiKWBcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtmdW5jfWApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgY2FzZSBcImVhcmxpZXN0XCI6XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZ2V0IGRhdGUgZm9ybWF0IGZyb20gbG9jYWxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcIkVhcmxpZXN0OiBcIiZhbXA7X3hsZm4uVEVYVChfeGxmbi5NSU4oX3hsZm4uSUYoJHtsZXZlbERpbWVuc2lvbnMuc3RhcnRDb29yZGluYXRlfToke2xldmVsRGltZW5zaW9ucy5lbmRDb29yZGluYXRlfT0ke3JlY29yZExldmVsfSwgJHtkaW1lbnNpb25zLnN0YXJ0Q29vcmRpbmF0ZX06JHtkaW1lbnNpb25zLmVuZENvb3JkaW5hdGV9KSksIFwibS9kL3l5eXlcIilgXG4gICAgICAgICAgICBjYXNlIFwibGF0ZXN0XCI6XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZ2V0IGRhdGUgZm9ybWF0IGZyb20gbG9jYWxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcIkxhdGVzdDogXCImYW1wO194bGZuLlRFWFQoX3hsZm4uTUFYKF94bGZuLklGKCR7bGV2ZWxEaW1lbnNpb25zLnN0YXJ0Q29vcmRpbmF0ZX06JHtsZXZlbERpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX09JHtyZWNvcmRMZXZlbH0sICR7ZGltZW5zaW9ucy5zdGFydENvb3JkaW5hdGV9OiR7ZGltZW5zaW9ucy5lbmRDb29yZGluYXRlfSkpLCBcIm0vZC95eXl5XCIpYFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRSb290U3VtbWFyeVN0YXJ0Q29vcmRpbmF0ZShjb2x1bW46IG51bWJlciwga2V5OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgZmlyc3REYXRhUmVjb3JkQ29sTmFtZSA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihjb2x1bW4pICsgKHRoaXMuZmlyc3REYXRhUm93KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TWFwID0gdGhpcy5oaWVyYXJjaGljYWxEaW1lbnNpb25NYXAuZ2V0KEdSSURfUEFSRU5UKTtcblxuICAgICAgICBpZiAodGFyZ2V0TWFwLmdldChrZXkpLnN0YXJ0Q29vcmRpbmF0ZSAhPT0gZmlyc3REYXRhUmVjb3JkQ29sTmFtZSkge1xuICAgICAgICAgICAgdGFyZ2V0TWFwLmdldChrZXkpLnN0YXJ0Q29vcmRpbmF0ZSA9IGZpcnN0RGF0YVJlY29yZENvbE5hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHByaW50SGVhZGVycyh3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhLCBoZWFkZXJzRm9yTGV2ZWw6IElDb2x1bW5JbmZvW10sIGk6IG51bWJlciwgaXNWZXJ0aWNhbDogYm9vbGVhbikge1xuICAgICAgICBsZXQgc3RhcnRWYWx1ZSA9IDA7XG4gICAgICAgIGxldCBzdHIgPSAnJztcblxuICAgICAgICBjb25zdCBpc0hpZXJhcmNoaWNhbEdyaWQgPSB3b3Jrc2hlZXREYXRhLmlzSGllcmFyY2hpY2FsO1xuICAgICAgICBsZXQgcm93U3R5bGUgPSBpc0hpZXJhcmNoaWNhbEdyaWQgPyAnIHM9XCIzXCInIDogJyc7XG4gICAgICAgIGNvbnN0IGRpY3Rpb25hcnkgPSB3b3Jrc2hlZXREYXRhLmRhdGFEaWN0aW9uYXJ5O1xuICAgICAgICBjb25zdCBvd25lciA9IHdvcmtzaGVldERhdGEub3duZXI7XG4gICAgICAgIGNvbnN0IG1heExldmVsID0gaXNWZXJ0aWNhbFxuICAgICAgICAgICAgPyBvd25lci5tYXhSb3dMZXZlbFxuICAgICAgICAgICAgOiBvd25lci5tYXhMZXZlbDtcblxuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRDb2wgb2YgaGVhZGVyc0ZvckxldmVsKSB7XG4gICAgICAgICAgICBjb25zdCBzcGFuTGVuZ3RoID0gaXNWZXJ0aWNhbCA/IGN1cnJlbnRDb2wucm93U3BhbiA6IGN1cnJlbnRDb2wuY29sdW1uU3BhbjtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb2wubGV2ZWwgPT09IGkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29sdW1uQ29vcmRpbmF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBpc1ZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5yb3dJbmRleFxuICAgICAgICAgICAgICAgICAgICA6IHN0YXJ0VmFsdWUgKyAob3duZXIubWF4Um93TGV2ZWwgPz8gMClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0Nvb3JkaW5hdGUgPSBpc1ZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgID8gc3RhcnRWYWx1ZSArIG93bmVyLm1heExldmVsICsgMlxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMucm93SW5kZXhcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtblZhbHVlID0gZGljdGlvbmFyeS5zYXZlVmFsdWUoY3VycmVudENvbC5oZWFkZXIsIHRydWUsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIGNvbHVtbkNvb3JkaW5hdGUgPSAoY3VycmVudENvbC5maWVsZCA9PT0gR1JJRF9MRVZFTF9DT0xcbiAgICAgICAgICAgICAgICAgICAgPyBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4od29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudCArIDEpXG4gICAgICAgICAgICAgICAgICAgIDogRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGNvbHVtbikpICsgcm93Q29vcmRpbmF0ZTtcblxuICAgICAgICAgICAgICAgIHJvd1N0eWxlID0gaXNWZXJ0aWNhbCAmJiBjdXJyZW50Q29sLnJvd1NwYW4gPiAxID8gJyBzPVwiNFwiJyA6IHJvd1N0eWxlO1xuICAgICAgICAgICAgICAgIHN0ciA9IGA8YyByPVwiJHtjb2x1bW5Db29yZGluYXRlfVwiJHtyb3dTdHlsZX0gdD1cInNcIj48dj4ke2NvbHVtblZhbHVlfTwvdj48L2M+YDtcblxuICAgICAgICAgICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBpdm90R3JpZFJvd0hlYWRlcnNNYXAuaGFzKHJvd0Nvb3JkaW5hdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBpdm90R3JpZFJvd0hlYWRlcnNNYXAuc2V0KHJvd0Nvb3JkaW5hdGUsIHRoaXMucGl2b3RHcmlkUm93SGVhZGVyc01hcC5nZXQocm93Q29vcmRpbmF0ZSkgKyBzdHIpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBpdm90R3JpZFJvd0hlYWRlcnNNYXAuc2V0KHJvd0Nvb3JkaW5hdGUsIHN0cilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hlZXREYXRhICs9IHN0cjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gbWF4TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZUNlbGxzQ291bnRlcisrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlQ2VsbFN0ciArPSBgIDxtZXJnZUNlbGwgcmVmPVwiJHtjb2x1bW5Db29yZGluYXRlfTpgO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q29sLmhlYWRlclR5cGUgPT09IEV4cG9ydEhlYWRlclR5cGUuQ29sdW1uSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSBpc1ZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtYXhMZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc3RhcnRWYWx1ZSArIChvd25lci5tYXhSb3dMZXZlbCA/PyAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gaXNWZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcm93Q29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3duZXIubWF4TGV2ZWwgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5Db29yZGluYXRlID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGNvbCkgKyByb3c7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IHNwYW5MZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IGlzVmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb2x1bW4gKyBrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gaXNWZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJvd0Nvb3JkaW5hdGUgKyBrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5yb3dJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkNvb3JkaW5hdGUgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oY29sKSArIHJvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBgPGMgcj1cIiR7Y29sdW1uQ29vcmRpbmF0ZX1cIiR7cm93U3R5bGV9IC8+YDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnBpdm90R3JpZFJvd0hlYWRlcnNNYXAuc2V0KHJvdywgc3RyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuc2hlZXREYXRhICs9IHN0clxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZUNlbGxTdHIgKz0gYCR7Y29sdW1uQ29vcmRpbmF0ZX1cIiAvPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGFydFZhbHVlICs9IHNwYW5MZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgU3R5bGVGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IE9iamVjdCkge1xuICAgICAgICBmb2xkZXJbJ3N0eWxlcy54bWwnXSA9IHN0clRvVTgoRXhjZWxTdHJpbmdzLmdldFN0eWxlcygpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgV29ya2Jvb2tGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IE9iamVjdCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBmb2xkZXJbJ3dvcmtib29rLnhtbCddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0V29ya2Jvb2sod29ya3NoZWV0RGF0YS5vcHRpb25zLndvcmtzaGVldE5hbWUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQ29udGVudFR5cGVzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBPYmplY3QsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgY29uc3QgaGFzU2hhcmVkU3RyaW5ncyA9ICF3b3Jrc2hlZXREYXRhLmlzRW1wdHkgfHwgd29ya3NoZWV0RGF0YS5vcHRpb25zLmFsd2F5c0V4cG9ydEhlYWRlcnM7XG4gICAgICAgIGZvbGRlclsnW0NvbnRlbnRfVHlwZXNdLnhtbCddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0Q29udGVudFR5cGVzWE1MKGhhc1NoYXJlZFN0cmluZ3MsIHdvcmtzaGVldERhdGEub3B0aW9ucy5leHBvcnRBc1RhYmxlKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFNoYXJlZFN0cmluZ3NGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IE9iamVjdCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBjb25zdCBkaWN0ID0gd29ya3NoZWV0RGF0YS5kYXRhRGljdGlvbmFyeTtcbiAgICAgICAgY29uc3Qgc29ydGVkVmFsdWVzID0gZGljdC5nZXRLZXlzKCk7XG4gICAgICAgIGNvbnN0IHNoYXJlZFN0cmluZ3MgPSBuZXcgQXJyYXk8c3RyaW5nPihzb3J0ZWRWYWx1ZXMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNvcnRlZFZhbHVlcykge1xuICAgICAgICAgICAgc2hhcmVkU3RyaW5nc1tkaWN0LmdldFNhbml0aXplZFZhbHVlKHZhbHVlKV0gPSAnPHNpPjx0PicgKyB2YWx1ZSArICc8L3Q+PC9zaT4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9sZGVyWydzaGFyZWRTdHJpbmdzLnhtbCddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0U2hhcmVkU3RyaW5nWE1MKFxuICAgICAgICAgICAgICAgICAgICAgICAgZGljdC5zdHJpbmdzQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRWYWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkU3RyaW5ncy5qb2luKCcnKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgVGFibGVzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBPYmplY3QsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgY29uc3QgY29sdW1uQ291bnQgPSB3b3Jrc2hlZXREYXRhLmNvbHVtbkNvdW50O1xuICAgICAgICBjb25zdCBsYXN0Q29sdW1uID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGNvbHVtbkNvdW50IC0gMSkgKyB3b3Jrc2hlZXREYXRhLnJvd0NvdW50O1xuICAgICAgICBjb25zdCBhdXRvRmlsdGVyRGltZW5zaW9uID0gJ0ExOicgKyBsYXN0Q29sdW1uO1xuICAgICAgICBjb25zdCB0YWJsZURpbWVuc2lvbiA9IHdvcmtzaGVldERhdGEuaXNFbXB0eVxuICAgICAgICAgICAgPyAnQTE6JyArIEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihjb2x1bW5Db3VudCAtIDEpICsgKHdvcmtzaGVldERhdGEucm93Q291bnQgKyAxKVxuICAgICAgICAgICAgOiBhdXRvRmlsdGVyRGltZW5zaW9uO1xuICAgICAgICBjb25zdCBoYXNVc2VyU2V0SW5kZXggPSB3b3Jrc2hlZXREYXRhLm93bmVyLmNvbHVtbnMuc29tZShjID0+IGMuZXhwb3J0SW5kZXggIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGhhc1VzZXJTZXRJbmRleFxuICAgICAgICAgICAgPyB3b3Jrc2hlZXREYXRhLnJvb3RLZXlzXG4gICAgICAgICAgICA6IHdvcmtzaGVldERhdGEub3duZXIuY29sdW1uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiAhYy5za2lwKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0SW5kZXggLSBiLnN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEucGlubmVkSW5kZXggLSBiLnBpbm5lZEluZGV4KVxuICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLmhlYWRlcik7XG5cbiAgICAgICAgbGV0IHNvcnRTdHJpbmcgPSAnJztcblxuICAgICAgICBsZXQgdGFibGVDb2x1bW5zID0gJzx0YWJsZUNvbHVtbnMgY291bnQ9XCInICsgY29sdW1uQ291bnQgKyAnXCI+JztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICB2YWx1ZXNbaV07XG4gICAgICAgICAgICB0YWJsZUNvbHVtbnMgKz0gJzx0YWJsZUNvbHVtbiBpZD1cIicgKyAoaSArIDEpICsgJ1wiIG5hbWU9XCInICsgdmFsdWUgKyAnXCIvPic7XG4gICAgICAgIH1cblxuICAgICAgICB0YWJsZUNvbHVtbnMgKz0gJzwvdGFibGVDb2x1bW5zPic7XG5cbiAgICAgICAgaWYgKHdvcmtzaGVldERhdGEuc29ydCkge1xuICAgICAgICAgICAgY29uc3Qgc29ydGluZ0V4cHJlc3Npb24gPSB3b3Jrc2hlZXREYXRhLnNvcnQ7XG4gICAgICAgICAgICBjb25zdCBzYyA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbih2YWx1ZXMuaW5kZXhPZihzb3J0aW5nRXhwcmVzc2lvbi5maWVsZE5hbWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IHNvcnRpbmdFeHByZXNzaW9uLmRpciAtIDE7XG4gICAgICAgICAgICBzb3J0U3RyaW5nID0gYDxzb3J0U3RhdGUgcmVmPVwiQTI6JHtsYXN0Q29sdW1ufVwiPjxzb3J0Q29uZGl0aW9uIGRlc2NlbmRpbmc9XCIke2Rpcn1cIiByZWY9XCIke3NjfTE6JHtzY30xNVwiLz48L3NvcnRTdGF0ZT5gO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9sZGVyWyd0YWJsZTEueG1sJ10gPSBzdHJUb1U4KEV4Y2VsU3RyaW5ncy5nZXRUYWJsZXNYTUwoYXV0b0ZpbHRlckRpbWVuc2lvbiwgdGFibGVEaW1lbnNpb24sIHRhYmxlQ29sdW1ucywgc29ydFN0cmluZykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3Jrc2hlZXRSZWxzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBPYmplY3QpIHtcbiAgICAgICAgZm9sZGVyWydzaGVldDEueG1sLnJlbHMnXSA9IHN0clRvVTgoRXhjZWxTdHJpbmdzLmdldFdvcmtzaGVldFJlbHMoKSk7XG4gICAgfVxufVxuIl19