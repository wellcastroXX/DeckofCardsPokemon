import { EventEmitter } from '@angular/core';
export class IgxAngularAnimationPlayer {
    get position() {
        return this._innerPlayer.getPosition();
    }
    set position(value) {
        this.internalPlayer.setPosition(value);
    }
    constructor(internalPlayer) {
        this.internalPlayer = internalPlayer;
        this.animationStart = new EventEmitter();
        this.animationEnd = new EventEmitter();
        this.internalPlayer.onDone(() => this.onDone());
        const innerRenderer = this.internalPlayer._renderer;
        //  We need inner player as Angular.AnimationPlayer.getPosition returns always 0.
        // To workaround this we are getting the positions from the inner player.
        //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
        //  As soon as this is resolved we can remove this hack
        this._innerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
    }
    init() {
        this.internalPlayer.init();
    }
    play() {
        this.animationStart.emit({ owner: this });
        this.internalPlayer.play();
    }
    finish() {
        this.internalPlayer.finish();
        // TODO: when animation finish angular deletes all onDone handlers. Add handlers again if needed
    }
    reset() {
        this.internalPlayer.reset();
        // calling reset does not change hasStarted to false. This is why we are doing it here via internal field
        this.internalPlayer._started = false;
    }
    destroy() {
        this.internalPlayer.destroy();
    }
    hasStarted() {
        return this.internalPlayer.hasStarted();
    }
    onDone() {
        this.animationEnd.emit({ owner: this });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1hbmltYXRpb24tcGxheWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NlcnZpY2VzL2FuaW1hdGlvbi9hbmd1bGFyLWFuaW1hdGlvbi1wbGF5ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUk3QyxNQUFNLE9BQU8seUJBQXlCO0lBS2xDLElBQVcsUUFBUTtRQUNmLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUMzQyxDQUFDO0lBRUQsSUFBVyxRQUFRLENBQUMsS0FBYTtRQUM3QixJQUFJLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQsWUFBb0IsY0FBc0M7UUFBdEMsbUJBQWMsR0FBZCxjQUFjLENBQXdCO1FBWG5ELG1CQUFjLEdBQWlDLElBQUksWUFBWSxFQUFrQixDQUFDO1FBQ2xGLGlCQUFZLEdBQWlDLElBQUksWUFBWSxFQUFrQixDQUFDO1FBV25GLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQ2hELE1BQU0sYUFBYSxHQUFJLElBQUksQ0FBQyxjQUFzQixDQUFDLFNBQVMsQ0FBQztRQUM3RCxpRkFBaUY7UUFDakYseUVBQXlFO1FBQ3pFLG9GQUFvRjtRQUNwRix1REFBdUQ7UUFDdkQsSUFBSSxDQUFDLFlBQVksR0FBRyxhQUFhLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDOUYsQ0FBQztJQUVNLElBQUk7UUFDUCxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFTSxJQUFJO1FBQ1AsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUMxQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFTSxNQUFNO1FBQ1QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUM3QixnR0FBZ0c7SUFDcEcsQ0FBQztJQUVNLEtBQUs7UUFDUixJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQzVCLHlHQUF5RztRQUN4RyxJQUFJLENBQUMsY0FBc0IsQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO0lBQ2xELENBQUM7SUFFTSxPQUFPO1FBQ1YsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRU0sVUFBVTtRQUNiLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRU8sTUFBTTtRQUNWLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDNUMsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5pbWF0aW9uUGxheWVyIGFzIEFuZ3VsYXJBbmltYXRpb25QbGF5ZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSUJhc2VFdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IEFuaW1hdGlvblBsYXllciB9IGZyb20gJy4vYW5pbWF0aW9uJztcblxuZXhwb3J0IGNsYXNzIElneEFuZ3VsYXJBbmltYXRpb25QbGF5ZXIgaW1wbGVtZW50cyBBbmltYXRpb25QbGF5ZXIge1xuICAgIHByaXZhdGUgX2lubmVyUGxheWVyOiBBbmd1bGFyQW5pbWF0aW9uUGxheWVyO1xuICAgIHB1YmxpYyBhbmltYXRpb25TdGFydDogRXZlbnRFbWl0dGVyPElCYXNlRXZlbnRBcmdzPiA9IG5ldyBFdmVudEVtaXR0ZXI8SUJhc2VFdmVudEFyZ3M+KCk7XG4gICAgcHVibGljIGFuaW1hdGlvbkVuZDogRXZlbnRFbWl0dGVyPElCYXNlRXZlbnRBcmdzPiA9IG5ldyBFdmVudEVtaXR0ZXI8SUJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICBwdWJsaWMgZ2V0IHBvc2l0aW9uKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lclBsYXllci5nZXRQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgcG9zaXRpb24odmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLmludGVybmFsUGxheWVyLnNldFBvc2l0aW9uKHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGludGVybmFsUGxheWVyOiBBbmd1bGFyQW5pbWF0aW9uUGxheWVyKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxQbGF5ZXIub25Eb25lKCgpID0+IHRoaXMub25Eb25lKCkpO1xuICAgICAgICBjb25zdCBpbm5lclJlbmRlcmVyID0gKHRoaXMuaW50ZXJuYWxQbGF5ZXIgYXMgYW55KS5fcmVuZGVyZXI7XG4gICAgICAgIC8vICBXZSBuZWVkIGlubmVyIHBsYXllciBhcyBBbmd1bGFyLkFuaW1hdGlvblBsYXllci5nZXRQb3NpdGlvbiByZXR1cm5zIGFsd2F5cyAwLlxuICAgICAgICAvLyBUbyB3b3JrYXJvdW5kIHRoaXMgd2UgYXJlIGdldHRpbmcgdGhlIHBvc2l0aW9ucyBmcm9tIHRoZSBpbm5lciBwbGF5ZXIuXG4gICAgICAgIC8vICBUaGlzIGlzIGxvZ2dlZCBpbiBBbmd1bGFyIGhlcmUgLSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xODg5MVxuICAgICAgICAvLyAgQXMgc29vbiBhcyB0aGlzIGlzIHJlc29sdmVkIHdlIGNhbiByZW1vdmUgdGhpcyBoYWNrXG4gICAgICAgIHRoaXMuX2lubmVyUGxheWVyID0gaW5uZXJSZW5kZXJlci5lbmdpbmUucGxheWVyc1tpbm5lclJlbmRlcmVyLmVuZ2luZS5wbGF5ZXJzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmludGVybmFsUGxheWVyLmluaXQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcGxheSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGFydC5lbWl0KHsgb3duZXI6IHRoaXMgfSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxQbGF5ZXIucGxheSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmaW5pc2goKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxQbGF5ZXIuZmluaXNoKCk7XG4gICAgICAgIC8vIFRPRE86IHdoZW4gYW5pbWF0aW9uIGZpbmlzaCBhbmd1bGFyIGRlbGV0ZXMgYWxsIG9uRG9uZSBoYW5kbGVycy4gQWRkIGhhbmRsZXJzIGFnYWluIGlmIG5lZWRlZFxuICAgIH1cblxuICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFBsYXllci5yZXNldCgpO1xuICAgICAgICAvLyBjYWxsaW5nIHJlc2V0IGRvZXMgbm90IGNoYW5nZSBoYXNTdGFydGVkIHRvIGZhbHNlLiBUaGlzIGlzIHdoeSB3ZSBhcmUgZG9pbmcgaXQgaGVyZSB2aWEgaW50ZXJuYWwgZmllbGRcbiAgICAgICAgKHRoaXMuaW50ZXJuYWxQbGF5ZXIgYXMgYW55KS5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmludGVybmFsUGxheWVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaGFzU3RhcnRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxQbGF5ZXIuaGFzU3RhcnRlZCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25Eb25lKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkVuZC5lbWl0KHsgb3duZXI6IHRoaXMgfSk7XG4gICAgfVxufVxuIl19