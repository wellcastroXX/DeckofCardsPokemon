import { NgIf } from '@angular/common';
import { Component, HostBinding, Input } from '@angular/core';
import { mkenum } from '../core/utils';
import { IgxIconComponent } from '../icon/icon.component';
import * as i0 from "@angular/core";
let NEXT_ID = 0;
/**
 * Determines the igxBadge type
 */
export const IgxBadgeType = /*@__PURE__*/ mkenum({
    PRIMARY: 'primary',
    INFO: 'info',
    SUCCESS: 'success',
    WARNING: 'warning',
    ERROR: 'error'
});
/**
 * Badge provides visual notifications used to decorate avatars, menus, etc.
 *
 * @igxModule IgxBadgeModule
 *
 * @igxTheme igx-badge-theme
 *
 * @igxKeywords badge, icon, notification
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
 * application when visual notification is needed. They are usually designed as icons with a predefined
 * style to communicate information, success, warnings, or errors.
 *
 * @example
 * ```html
 * <igx-avatar>
 *   <igx-badge icon="check" type="success"></igx-badge>
 * </igx-avatar>
 */
export class IgxBadgeComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the badge.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-badge-0"`.
         *
         * @example
         * ```html
         * <igx-badge id="igx-badge-2"></igx-badge>
         * ```
         */
        this.id = `igx-badge-${NEXT_ID++}`;
        /**
         * Sets/gets the type of the badge.
         *
         * @remarks
         * Allowed values are `primary`, `info`, `success`, `warning`, `error`.
         * Providing an invalid value won't display a badge.
         *
         * @example
         * ```html
         * <igx-badge type="success"></igx-badge>
         * ```
         */
        this.type = IgxBadgeType.PRIMARY;
        /**
         * Sets/gets the value to be displayed inside the badge.
         *
         * @remarks
         * If an `icon` property is already set the `icon` will be displayed.
         * If neither a `value` nor an `icon` is set the content of the badge will be empty.
         *
         * @example
         * ```html
         * <igx-badge value="11"></igx-badge>
         * ```
         */
        this.value = '';
        /**
         * Sets/gets the role attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.role = 'status';
         * ```
         */
        this.role = 'status';
        /**
         * Sets/gets the css class to use on the badge.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.cssClass = 'my-badge-class';
         * ```
         */
        this.cssClass = 'igx-badge';
        /**
         * Sets a square shape to the badge, if `shape` is set to `square`.
         * By default the shape of the badge is rounded.
         *
         * @example
         * ```html
         * <igx-badge shape="square"></igx-badge>
         * ```
         */
        this.shape = 'rounded';
        /**
         * Sets/gets the aria-label attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.label = 'badge';
         * ```
         */
        this.label = 'badge';
    }
    /** @hidden @internal */
    get _squareShape() {
        return this.shape === 'square';
    }
    /**
     * Defines a human-readable, accessor, author-localized description for
     * the `type` and the `icon` or `value` of the element.
     *
     * @hidden
     * @internal
     */
    get roleDescription() {
        if (this.icon) {
            return this.type + ' type badge with icon type ' + this.icon;
        }
        else if (this.value || this.value === 0) {
            return this.type + ' badge type with value ' + this.value;
        }
        return this.type + ' badge type without value';
    }
    get infoClass() {
        return this.type === IgxBadgeType.INFO;
    }
    get successClass() {
        return this.type === IgxBadgeType.SUCCESS;
    }
    get warningClass() {
        return this.type === IgxBadgeType.WARNING;
    }
    get errorClass() {
        return this.type === IgxBadgeType.ERROR;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxBadgeComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: IgxBadgeComponent, isStandalone: true, selector: "igx-badge", inputs: { id: "id", type: "type", value: "value", icon: "icon", iconSet: "iconSet", shape: "shape" }, host: { properties: { "attr.id": "this.id", "attr.role": "this.role", "class.igx-badge": "this.cssClass", "class.igx-badge--square": "this._squareShape", "attr.aria-label": "this.label", "attr.aria-roledescription": "this.roleDescription", "class.igx-badge--info": "this.infoClass", "class.igx-badge--success": "this.successClass", "class.igx-badge--warning": "this.warningClass", "class.igx-badge--error": "this.errorClass" } }, ngImport: i0, template: "<span *ngIf=\"value || value === 0 && !icon\" class=\"igx-badge__value\">{{value}}</span>\n<igx-icon *ngIf=\"icon && !iconSet\">{{icon}}</igx-icon>\n<igx-icon *ngIf=\"icon && iconSet\" [family]=\"iconSet\" [name]=\"icon\">{{icon}}</igx-icon>\n<ng-content></ng-content>\n", dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxBadgeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-badge', standalone: true, imports: [NgIf, IgxIconComponent], template: "<span *ngIf=\"value || value === 0 && !icon\" class=\"igx-badge__value\">{{value}}</span>\n<igx-icon *ngIf=\"icon && !iconSet\">{{icon}}</igx-icon>\n<igx-icon *ngIf=\"icon && iconSet\" [family]=\"iconSet\" [name]=\"icon\">{{icon}}</igx-icon>\n<ng-content></ng-content>\n" }]
        }], propDecorators: { id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], type: [{
                type: Input
            }], value: [{
                type: Input
            }], icon: [{
                type: Input
            }], iconSet: [{
                type: Input
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-badge']
            }], shape: [{
                type: Input
            }], _squareShape: [{
                type: HostBinding,
                args: ['class.igx-badge--square']
            }], label: [{
                type: HostBinding,
                args: ['attr.aria-label']
            }], roleDescription: [{
                type: HostBinding,
                args: ['attr.aria-roledescription']
            }], infoClass: [{
                type: HostBinding,
                args: ['class.igx-badge--info']
            }], successClass: [{
                type: HostBinding,
                args: ['class.igx-badge--success']
            }], warningClass: [{
                type: HostBinding,
                args: ['class.igx-badge--warning']
            }], errorClass: [{
                type: HostBinding,
                args: ['class.igx-badge--error']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFkZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2JhZGdlL2JhZGdlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9iYWRnZS9iYWRnZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdkMsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzlELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7O0FBRTFELElBQUksT0FBTyxHQUFHLENBQUMsQ0FBQztBQUVoQjs7R0FFRztBQUNILE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxhQUFhLENBQUEsTUFBTSxDQUFDO0lBQzVDLE9BQU8sRUFBRSxTQUFTO0lBQ2xCLElBQUksRUFBRSxNQUFNO0lBQ1osT0FBTyxFQUFFLFNBQVM7SUFDbEIsT0FBTyxFQUFFLFNBQVM7SUFDbEIsS0FBSyxFQUFFLE9BQU87Q0FDakIsQ0FBQyxDQUFDO0FBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQU9ILE1BQU0sT0FBTyxpQkFBaUI7SUFOOUI7UUFRRzs7Ozs7Ozs7OztXQVVHO1FBR0ssT0FBRSxHQUFHLGFBQWEsT0FBTyxFQUFFLEVBQUUsQ0FBQztRQUV0Qzs7Ozs7Ozs7Ozs7V0FXRztRQUVLLFNBQUksR0FBMEIsWUFBWSxDQUFDLE9BQU8sQ0FBQztRQUUzRDs7Ozs7Ozs7Ozs7V0FXRztRQUVLLFVBQUssR0FBb0IsRUFBRSxDQUFDO1FBd0JuQzs7Ozs7Ozs7OztXQVVHO1FBRUksU0FBSSxHQUFHLFFBQVEsQ0FBQztRQUV2Qjs7Ozs7Ozs7OztXQVVHO1FBRUksYUFBUSxHQUFHLFdBQVcsQ0FBQztRQUU5Qjs7Ozs7Ozs7V0FRRztRQUVJLFVBQUssR0FBeUIsU0FBUyxDQUFDO1FBUS9DOzs7Ozs7Ozs7O1dBVUc7UUFFSSxVQUFLLEdBQUcsT0FBTyxDQUFDO0tBc0MxQjtJQXhERyx3QkFBd0I7SUFDeEIsSUFDVyxZQUFZO1FBQ25CLE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxRQUFRLENBQUM7SUFDbkMsQ0FBQztJQWdCRDs7Ozs7O09BTUc7SUFDSCxJQUNXLGVBQWU7UUFDdEIsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1gsT0FBTyxJQUFJLENBQUMsSUFBSSxHQUFHLDZCQUE2QixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7U0FDaEU7YUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLEVBQUU7WUFDdkMsT0FBTyxJQUFJLENBQUMsSUFBSSxHQUFHLHlCQUF5QixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7U0FDN0Q7UUFDRCxPQUFPLElBQUksQ0FBQyxJQUFJLEdBQUcsMkJBQTJCLENBQUM7SUFDbkQsQ0FBQztJQUVELElBQ1csU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxDQUFDLElBQUksQ0FBQztJQUMzQyxDQUFDO0lBRUQsSUFDVyxZQUFZO1FBQ25CLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxZQUFZLENBQUMsT0FBTyxDQUFDO0lBQzlDLENBQUM7SUFFRCxJQUNXLFlBQVk7UUFDbkIsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQyxPQUFPLENBQUM7SUFDOUMsQ0FBQztJQUVELElBQ1csVUFBVTtRQUNqQixPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxDQUFDLEtBQUssQ0FBQztJQUM1QyxDQUFDOzhHQXBLUSxpQkFBaUI7a0dBQWpCLGlCQUFpQix5bEJDOUM5QixnUkFJQSw0Q0R3Q2MsSUFBSSw2RkFBRSxnQkFBZ0I7OzJGQUV2QixpQkFBaUI7a0JBTjdCLFNBQVM7K0JBQ0ksV0FBVyxjQUVULElBQUksV0FDUCxDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQzs4QkFpQjFCLEVBQUU7c0JBRlIsV0FBVzt1QkFBQyxTQUFTOztzQkFDckIsS0FBSztnQkFnQkMsSUFBSTtzQkFEVixLQUFLO2dCQWdCQyxLQUFLO3NCQURYLEtBQUs7Z0JBaUJDLElBQUk7c0JBRFYsS0FBSztnQkFPQyxPQUFPO3NCQURiLEtBQUs7Z0JBZUMsSUFBSTtzQkFEVixXQUFXO3VCQUFDLFdBQVc7Z0JBZWpCLFFBQVE7c0JBRGQsV0FBVzt1QkFBQyxpQkFBaUI7Z0JBYXZCLEtBQUs7c0JBRFgsS0FBSztnQkFLSyxZQUFZO3NCQUR0QixXQUFXO3VCQUFDLHlCQUF5QjtnQkFpQi9CLEtBQUs7c0JBRFgsV0FBVzt1QkFBQyxpQkFBaUI7Z0JBV25CLGVBQWU7c0JBRHpCLFdBQVc7dUJBQUMsMkJBQTJCO2dCQVc3QixTQUFTO3NCQURuQixXQUFXO3VCQUFDLHVCQUF1QjtnQkFNekIsWUFBWTtzQkFEdEIsV0FBVzt1QkFBQywwQkFBMEI7Z0JBTTVCLFlBQVk7c0JBRHRCLFdBQVc7dUJBQUMsMEJBQTBCO2dCQU01QixVQUFVO3NCQURwQixXQUFXO3VCQUFDLHdCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nSWYgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZywgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG1rZW51bSB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSWd4SWNvbkNvbXBvbmVudCB9IGZyb20gJy4uL2ljb24vaWNvbi5jb21wb25lbnQnO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgaWd4QmFkZ2UgdHlwZVxuICovXG5leHBvcnQgY29uc3QgSWd4QmFkZ2VUeXBlID0gLypAX19QVVJFX18qL21rZW51bSh7XG4gICAgUFJJTUFSWTogJ3ByaW1hcnknLFxuICAgIElORk86ICdpbmZvJyxcbiAgICBTVUNDRVNTOiAnc3VjY2VzcycsXG4gICAgV0FSTklORzogJ3dhcm5pbmcnLFxuICAgIEVSUk9SOiAnZXJyb3InXG59KTtcbmV4cG9ydCB0eXBlIElneEJhZGdlVHlwZSA9ICh0eXBlb2YgSWd4QmFkZ2VUeXBlKVtrZXlvZiB0eXBlb2YgSWd4QmFkZ2VUeXBlXTtcbi8qKlxuICogQmFkZ2UgcHJvdmlkZXMgdmlzdWFsIG5vdGlmaWNhdGlvbnMgdXNlZCB0byBkZWNvcmF0ZSBhdmF0YXJzLCBtZW51cywgZXRjLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4QmFkZ2VNb2R1bGVcbiAqXG4gKiBAaWd4VGhlbWUgaWd4LWJhZGdlLXRoZW1lXG4gKlxuICogQGlneEtleXdvcmRzIGJhZGdlLCBpY29uLCBub3RpZmljYXRpb25cbiAqXG4gKiBAaWd4R3JvdXAgRGF0YSBFbnRyeSAmIERpc3BsYXlcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIElnbml0ZSBVSSBCYWRnZSBpcyB1c2VkIHRvIGRlY29yYXRlIGF2YXRhcnMsIG5hdmlnYXRpb24gbWVudXMsIG9yIG90aGVyIGNvbXBvbmVudHMgaW4gdGhlXG4gKiBhcHBsaWNhdGlvbiB3aGVuIHZpc3VhbCBub3RpZmljYXRpb24gaXMgbmVlZGVkLiBUaGV5IGFyZSB1c3VhbGx5IGRlc2lnbmVkIGFzIGljb25zIHdpdGggYSBwcmVkZWZpbmVkXG4gKiBzdHlsZSB0byBjb21tdW5pY2F0ZSBpbmZvcm1hdGlvbiwgc3VjY2Vzcywgd2FybmluZ3MsIG9yIGVycm9ycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1hdmF0YXI+XG4gKiAgIDxpZ3gtYmFkZ2UgaWNvbj1cImNoZWNrXCIgdHlwZT1cInN1Y2Nlc3NcIj48L2lneC1iYWRnZT5cbiAqIDwvaWd4LWF2YXRhcj5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtYmFkZ2UnLFxuICAgIHRlbXBsYXRlVXJsOiAnYmFkZ2UuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW05nSWYsIElneEljb25Db21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIElneEJhZGdlQ29tcG9uZW50IHtcblxuICAgLyoqXG4gICAgKiBTZXRzL2dldHMgdGhlIGBpZGAgb2YgdGhlIGJhZGdlLlxuICAgICpcbiAgICAqIEByZW1hcmtzXG4gICAgKiBJZiBub3Qgc2V0LCB0aGUgYGlkYCB3aWxsIGhhdmUgdmFsdWUgYFwiaWd4LWJhZGdlLTBcImAuXG4gICAgKlxuICAgICogQGV4YW1wbGVcbiAgICAqIGBgYGh0bWxcbiAgICAqIDxpZ3gtYmFkZ2UgaWQ9XCJpZ3gtYmFkZ2UtMlwiPjwvaWd4LWJhZGdlPlxuICAgICogYGBgXG4gICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1iYWRnZS0ke05FWFRfSUQrK31gO1xuXG4gICAvKipcbiAgICAqIFNldHMvZ2V0cyB0aGUgdHlwZSBvZiB0aGUgYmFkZ2UuXG4gICAgKlxuICAgICogQHJlbWFya3NcbiAgICAqIEFsbG93ZWQgdmFsdWVzIGFyZSBgcHJpbWFyeWAsIGBpbmZvYCwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBlcnJvcmAuXG4gICAgKiBQcm92aWRpbmcgYW4gaW52YWxpZCB2YWx1ZSB3b24ndCBkaXNwbGF5IGEgYmFkZ2UuXG4gICAgKlxuICAgICogQGV4YW1wbGVcbiAgICAqIGBgYGh0bWxcbiAgICAqIDxpZ3gtYmFkZ2UgdHlwZT1cInN1Y2Nlc3NcIj48L2lneC1iYWRnZT5cbiAgICAqIGBgYFxuICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdHlwZTogc3RyaW5nIHwgSWd4QmFkZ2VUeXBlID0gSWd4QmFkZ2VUeXBlLlBSSU1BUlk7XG5cbiAgIC8qKlxuICAgICogU2V0cy9nZXRzIHRoZSB2YWx1ZSB0byBiZSBkaXNwbGF5ZWQgaW5zaWRlIHRoZSBiYWRnZS5cbiAgICAqXG4gICAgKiBAcmVtYXJrc1xuICAgICogSWYgYW4gYGljb25gIHByb3BlcnR5IGlzIGFscmVhZHkgc2V0IHRoZSBgaWNvbmAgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgKiBJZiBuZWl0aGVyIGEgYHZhbHVlYCBub3IgYW4gYGljb25gIGlzIHNldCB0aGUgY29udGVudCBvZiB0aGUgYmFkZ2Ugd2lsbCBiZSBlbXB0eS5cbiAgICAqXG4gICAgKiBAZXhhbXBsZVxuICAgICogYGBgaHRtbFxuICAgICogPGlneC1iYWRnZSB2YWx1ZT1cIjExXCI+PC9pZ3gtYmFkZ2U+XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyBhbiBpY29uIGZvciB0aGUgYmFkZ2UgZnJvbSB0aGUgbWF0ZXJpYWwgaWNvbnMgc2V0LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBIYXMgcHJpb3JpdHkgb3ZlciB0aGUgYHZhbHVlYCBwcm9wZXJ0eS5cbiAgICAgKiBJZiBuZWl0aGVyIGEgYHZhbHVlYCBub3IgYW4gYGljb25gIGlzIHNldCB0aGUgY29udGVudCBvZiB0aGUgYmFkZ2Ugd2lsbCBiZSBlbXB0eS5cbiAgICAgKiBQcm92aWRpbmcgYW4gaW52YWxpZCB2YWx1ZSB3b24ndCBkaXNwbGF5IGFueXRoaW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1iYWRnZSBpY29uPVwiY2hlY2tcIj48L2lneC1iYWRnZT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpY29uOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgaWNvbiBzZXQuIFVzZWQgaW4gY2FzZSB0aGUgaWNvbiBpcyBmcm9tIGEgZGlmZmVyZW50IGljb24gc2V0LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGljb25TZXQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgcm9sZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiTXlCYWRnZVwiLCB7IHJlYWQ6IElneEJhZGdlQ29tcG9uZW50IH0pXG4gICAgICogcHVibGljIGJhZGdlOiBJZ3hCYWRnZUNvbXBvbmVudDtcbiAgICAgKlxuICAgICAqIGJhZGdlLnJvbGUgPSAnc3RhdHVzJztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpXG4gICAgcHVibGljIHJvbGUgPSAnc3RhdHVzJztcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgY3NzIGNsYXNzIHRvIHVzZSBvbiB0aGUgYmFkZ2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiTXlCYWRnZVwiLCB7IHJlYWQ6IElneEJhZGdlQ29tcG9uZW50IH0pXG4gICAgICogcHVibGljIGJhZGdlOiBJZ3hCYWRnZUNvbXBvbmVudDtcbiAgICAgKlxuICAgICAqIGJhZGdlLmNzc0NsYXNzID0gJ215LWJhZGdlLWNsYXNzJztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1iYWRnZScpXG4gICAgcHVibGljIGNzc0NsYXNzID0gJ2lneC1iYWRnZSc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgc3F1YXJlIHNoYXBlIHRvIHRoZSBiYWRnZSwgaWYgYHNoYXBlYCBpcyBzZXQgdG8gYHNxdWFyZWAuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgc2hhcGUgb2YgdGhlIGJhZGdlIGlzIHJvdW5kZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWJhZGdlIHNoYXBlPVwic3F1YXJlXCI+PC9pZ3gtYmFkZ2U+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2hhcGU6ICdyb3VuZGVkJyB8ICdzcXVhcmUnID0gJ3JvdW5kZWQnO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtYmFkZ2UtLXNxdWFyZScpXG4gICAgcHVibGljIGdldCBfc3F1YXJlU2hhcGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXBlID09PSAnc3F1YXJlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIk15QmFkZ2VcIiwgeyByZWFkOiBJZ3hCYWRnZUNvbXBvbmVudCB9KVxuICAgICAqIHB1YmxpYyBiYWRnZTogSWd4QmFkZ2VDb21wb25lbnQ7XG4gICAgICpcbiAgICAgKiBiYWRnZS5sYWJlbCA9ICdiYWRnZSc7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtbGFiZWwnKVxuICAgIHB1YmxpYyBsYWJlbCA9ICdiYWRnZSc7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgaHVtYW4tcmVhZGFibGUsIGFjY2Vzc29yLCBhdXRob3ItbG9jYWxpemVkIGRlc2NyaXB0aW9uIGZvclxuICAgICAqIHRoZSBgdHlwZWAgYW5kIHRoZSBgaWNvbmAgb3IgYHZhbHVlYCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1yb2xlZGVzY3JpcHRpb24nKVxuICAgIHB1YmxpYyBnZXQgcm9sZURlc2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pY29uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgJyB0eXBlIGJhZGdlIHdpdGggaWNvbiB0eXBlICcgKyB0aGlzLmljb247XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZSB8fCB0aGlzLnZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgJyBiYWRnZSB0eXBlIHdpdGggdmFsdWUgJyArIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgYmFkZ2UgdHlwZSB3aXRob3V0IHZhbHVlJztcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1iYWRnZS0taW5mbycpXG4gICAgcHVibGljIGdldCBpbmZvQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneEJhZGdlVHlwZS5JTkZPO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWJhZGdlLS1zdWNjZXNzJylcbiAgICBwdWJsaWMgZ2V0IHN1Y2Nlc3NDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4QmFkZ2VUeXBlLlNVQ0NFU1M7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtYmFkZ2UtLXdhcm5pbmcnKVxuICAgIHB1YmxpYyBnZXQgd2FybmluZ0NsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBJZ3hCYWRnZVR5cGUuV0FSTklORztcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1iYWRnZS0tZXJyb3InKVxuICAgIHB1YmxpYyBnZXQgZXJyb3JDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4QmFkZ2VUeXBlLkVSUk9SO1xuICAgIH1cbn1cbiIsIjxzcGFuICpuZ0lmPVwidmFsdWUgfHwgdmFsdWUgPT09IDAgJiYgIWljb25cIiBjbGFzcz1cImlneC1iYWRnZV9fdmFsdWVcIj57e3ZhbHVlfX08L3NwYW4+XG48aWd4LWljb24gKm5nSWY9XCJpY29uICYmICFpY29uU2V0XCI+e3tpY29ufX08L2lneC1pY29uPlxuPGlneC1pY29uICpuZ0lmPVwiaWNvbiAmJiBpY29uU2V0XCIgW2ZhbWlseV09XCJpY29uU2V0XCIgW25hbWVdPVwiaWNvblwiPnt7aWNvbn19PC9pZ3gtaWNvbj5cbjxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiJdfQ==