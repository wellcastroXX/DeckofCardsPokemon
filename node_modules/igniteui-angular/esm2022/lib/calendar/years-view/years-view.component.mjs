import { Component, Output, EventEmitter, Input, HostBinding, HostListener, Injectable, ViewChildren, booleanAttribute } from '@angular/core';
import { range, Calendar } from '../calendar';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { HammerGestureConfig, HAMMER_GESTURE_CONFIG } from '@angular/platform-browser';
import { IgxCalendarYearDirective } from '../calendar.directives';
import { noop } from 'rxjs';
import { NgFor } from '@angular/common';
import { HammerGesturesManager } from '../../core/touch';
import * as i0 from "@angular/core";
export class CalendarHammerConfig extends HammerGestureConfig {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: HammerGesturesManager.Hammer?.DIRECTION_VERTICAL, threshold: 1 }
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: CalendarHammerConfig, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: CalendarHammerConfig }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: CalendarHammerConfig, decorators: [{
            type: Injectable
        }] });
export class IgxYearsViewComponent {
    /**
     * Gets/sets the selected date of the years view.
     * By default it is the current date.
     * ```html
     * <igx-years-view [date]="myDate"></igx-years-view>
     * ```
     * ```typescript
     * let date =  this.yearsView.date;
     * ```
     *
     * @memberof IgxYearsViewComponent
     */
    get date() {
        return this._date;
    }
    set date(value) {
        if (!(value instanceof Date)) {
            return;
        }
        this._date = value;
    }
    /**
     * Gets the year format option of the years view.
     * ```typescript
     * let yearFormat = this.yearsView.yearFormat.
     * ```
     */
    get yearFormat() {
        return this._yearFormat;
    }
    /**
     * Sets the year format option of the years view.
     * ```html
     * <igx-years-view [yearFormat]="numeric"></igx-years-view>
     * ```
     *
     * @memberof IgxYearsViewComponent
     */
    set yearFormat(value) {
        this._yearFormat = value;
        this.initYearFormatter();
    }
    /**
     * Gets the `locale` of the years view.
     * Default value is `"en"`.
     * ```typescript
     * let locale =  this.yearsView.locale;
     * ```
     *
     * @memberof IgxYearsViewComponent
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the years view.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     * ```html
     * <igx-years-view [locale]="de"></igx-years-view>
     * ```
     *
     * @memberof IgxYearsViewComponent
     */
    set locale(value) {
        this._locale = value;
        this.initYearFormatter();
    }
    /**
     * Returns an array of date objects which are then used to properly
     * render the years.
     *
     * Used in the template of the component.
     *
     * @hidden
     */
    get decade() {
        const result = [];
        const start = this.date.getFullYear() - 3;
        const end = this.date.getFullYear() + 4;
        for (const year of range(start, end)) {
            result.push(new Date(year, this.date.getMonth(), this.date.getDate()));
        }
        return result;
    }
    constructor(el) {
        this.el = el;
        /**
         * Emits an event when a selection is made in the years view.
         * Provides reference the `date` property in the `IgxYearsViewComponent`.
         * ```html
         * <igx-years-view (selected)="onSelection($event)"></igx-years-view>
         * ```
         *
         * @memberof IgxYearsViewComponent
         */
        this.selected = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._yearFormat = 'numeric';
        /**
         * @hidden
         */
        this._date = new Date();
        /**
         * @hidden
         */
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this._onChangeCallback = noop;
        this.initYearFormatter();
        this._calendarModel = new Calendar();
    }
    /**
     * @hidden
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(1);
        this.calendarDir.find(date => date.isCurrentYear).nativeElement.nextElementSibling.focus();
    }
    /**
     * @hidden
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(-1);
        this.calendarDir.find(date => date.isCurrentYear).nativeElement.previousElementSibling.focus();
    }
    /**
     * @hidden
     */
    onKeydownEnter() {
        this.selected.emit(this.date);
        this._onChangeCallback(this.date);
    }
    /**
     * Returns the locale representation of the year in the years view.
     *
     * @hidden
     */
    formattedYear(value) {
        if (this.formatView) {
            return this._formatterYear.format(value);
        }
        return `${value.getFullYear()}`;
    }
    /**
     * @hidden
     */
    selectYear(event) {
        this.date = event;
        this.selected.emit(this.date);
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     */
    scroll(event) {
        event.preventDefault();
        event.stopPropagation();
        const delta = event.deltaY < 0 ? -1 : 1;
        this.generateYearRange(delta);
    }
    /**
     * @hidden
     */
    pan(event) {
        const delta = event.deltaY < 0 ? 1 : -1;
        this.generateYearRange(delta);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    yearTracker(index, item) {
        return `${item.getFullYear()}}`;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (value) {
            this.date = value;
        }
    }
    /**
     * @hidden
     */
    initYearFormatter() {
        this._formatterYear = new Intl.DateTimeFormat(this._locale, { year: this.yearFormat });
    }
    /**
     * @hidden
     */
    generateYearRange(delta) {
        const currentYear = new Date().getFullYear();
        if ((delta > 0 && this.date.getFullYear() - currentYear >= 95) ||
            (delta < 0 && currentYear - this.date.getFullYear() >= 95)) {
            return;
        }
        this.date = this._calendarModel.timedelta(this.date, 'year', delta);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxYearsViewComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.2.4", type: IgxYearsViewComponent, isStandalone: true, selector: "igx-years-view", inputs: { formatView: ["formatView", "formatView", booleanAttribute], date: "date", yearFormat: "yearFormat", locale: "locale" }, outputs: { selected: "selected" }, host: { listeners: { "keydown.arrowdown": "onKeydownArrowDown($event)", "keydown.arrowup": "onKeydownArrowUp($event)", "keydown.enter": "onKeydownEnter()" }, properties: { "class.igx-calendar": "this.styleClass" } }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxYearsViewComponent,
                multi: true
            },
            {
                provide: HAMMER_GESTURE_CONFIG,
                useClass: CalendarHammerConfig
            }
        ], viewQueries: [{ propertyName: "calendarDir", predicate: IgxCalendarYearDirective, descendants: true, read: IgxCalendarYearDirective }], ngImport: i0, template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-column\" (wheel)=\"scroll($event)\" (pan)=\"pan($event)\">\n        <span class=\"igx-calendar__year\"\n            [igxCalendarYear]=\"year\"\n            [date]=\"date\"\n            (yearSelection)=\"selectYear($event)\"\n            *ngFor=\"let year of decade; trackBy: yearTracker\">\n\n            {{ formattedYear(year) }}\n        </span>\n    </div>\n</div>\n", dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: IgxCalendarYearDirective, selector: "[igxCalendarYear]", inputs: ["igxCalendarYear", "date"], outputs: ["yearSelection"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxYearsViewComponent, decorators: [{
            type: Component,
            args: [{ providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IgxYearsViewComponent,
                            multi: true
                        },
                        {
                            provide: HAMMER_GESTURE_CONFIG,
                            useClass: CalendarHammerConfig
                        }
                    ], selector: 'igx-years-view', standalone: true, imports: [NgFor, IgxCalendarYearDirective], template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-column\" (wheel)=\"scroll($event)\" (pan)=\"pan($event)\">\n        <span class=\"igx-calendar__year\"\n            [igxCalendarYear]=\"year\"\n            [date]=\"date\"\n            (yearSelection)=\"selectYear($event)\"\n            *ngFor=\"let year of decade; trackBy: yearTracker\">\n\n            {{ formattedYear(year) }}\n        </span>\n    </div>\n</div>\n" }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { formatView: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], selected: [{
                type: Output
            }], styleClass: [{
                type: HostBinding,
                args: ['class.igx-calendar']
            }], calendarDir: [{
                type: ViewChildren,
                args: [IgxCalendarYearDirective, { read: IgxCalendarYearDirective }]
            }], date: [{
                type: Input
            }], yearFormat: [{
                type: Input
            }], locale: [{
                type: Input
            }], onKeydownArrowDown: [{
                type: HostListener,
                args: ['keydown.arrowdown', ['$event']]
            }], onKeydownArrowUp: [{
                type: HostListener,
                args: ['keydown.arrowup', ['$event']]
            }], onKeydownEnter: [{
                type: HostListener,
                args: ['keydown.enter']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhcnMtdmlldy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvY2FsZW5kYXIveWVhcnMtdmlldy95ZWFycy12aWV3LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9jYWxlbmRhci95ZWFycy12aWV3L3llYXJzLXZpZXcuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxNQUFNLEVBQ04sWUFBWSxFQUNaLEtBQUssRUFDTCxXQUFXLEVBQ1gsWUFBWSxFQUVaLFVBQVUsRUFDVixZQUFZLEVBRVosZ0JBQWdCLEVBQ25CLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzlDLE9BQU8sRUFBRSxpQkFBaUIsRUFBd0IsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUscUJBQXFCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN2RixPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNsRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVCLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN4QyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7QUFHekQsTUFBTSxPQUFPLG9CQUFxQixTQUFRLG1CQUFtQjtJQUQ3RDs7UUFFb0IsY0FBUyxHQUFHO1lBQ3hCLEdBQUcsRUFBRSxFQUFFLFNBQVMsRUFBRSxxQkFBcUIsQ0FBQyxNQUFNLEVBQUUsa0JBQWtCLEVBQUUsU0FBUyxFQUFFLENBQUMsRUFBRTtTQUNyRixDQUFD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LFVBQVU7c0JBRGhCLFdBQVc7dUJBQUMsb0JBQW9CO2dCQVExQixXQUFXO3NCQURqQixZQUFZO3VCQUFDLHdCQUF3QixFQUFFLEVBQUUsSUFBSSxFQUFFLHdCQUF3QixFQUFFO2dCQWtEL0QsSUFBSTtzQkFEZCxLQUFLO2dCQW1CSyxVQUFVO3NCQURwQixLQUFLO2dCQTRCSyxNQUFNO3NCQURoQixLQUFLO2dCQWlEQyxrQkFBa0I7c0JBRHhCLFlBQVk7dUJBQUMsbUJBQW1CLEVBQUUsQ0FBQyxRQUFRLENBQUM7Z0JBYXRDLGdCQUFnQjtzQkFEdEIsWUFBWTt1QkFBQyxpQkFBaUIsRUFBRSxDQUFDLFFBQVEsQ0FBQztnQkFhcEMsY0FBYztzQkFEcEIsWUFBWTt1QkFBQyxlQUFlIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgT3V0cHV0LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgRWxlbWVudFJlZixcbiAgICBJbmplY3RhYmxlLFxuICAgIFZpZXdDaGlsZHJlbixcbiAgICBRdWVyeUxpc3QsXG4gICAgYm9vbGVhbkF0dHJpYnV0ZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHJhbmdlLCBDYWxlbmRhciB9IGZyb20gJy4uL2NhbGVuZGFyJztcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SLCBDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEhhbW1lckdlc3R1cmVDb25maWcsIEhBTU1FUl9HRVNUVVJFX0NPTkZJRyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgSWd4Q2FsZW5kYXJZZWFyRGlyZWN0aXZlIH0gZnJvbSAnLi4vY2FsZW5kYXIuZGlyZWN0aXZlcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOZ0ZvciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBIYW1tZXJHZXN0dXJlc01hbmFnZXIgfSBmcm9tICcuLi8uLi9jb3JlL3RvdWNoJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENhbGVuZGFySGFtbWVyQ29uZmlnIGV4dGVuZHMgSGFtbWVyR2VzdHVyZUNvbmZpZyB7XG4gICAgcHVibGljIG92ZXJyaWRlIG92ZXJyaWRlcyA9IHtcbiAgICAgICAgcGFuOiB7IGRpcmVjdGlvbjogSGFtbWVyR2VzdHVyZXNNYW5hZ2VyLkhhbW1lcj8uRElSRUNUSU9OX1ZFUlRJQ0FMLCB0aHJlc2hvbGQ6IDEgfVxuICAgIH07XG59XG5cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBJZ3hZZWFyc1ZpZXdDb21wb25lbnQsXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBIQU1NRVJfR0VTVFVSRV9DT05GSUcsXG4gICAgICAgICAgICB1c2VDbGFzczogQ2FsZW5kYXJIYW1tZXJDb25maWdcbiAgICAgICAgfVxuICAgIF0sXG4gICAgc2VsZWN0b3I6ICdpZ3gteWVhcnMtdmlldycsXG4gICAgdGVtcGxhdGVVcmw6ICd5ZWFycy12aWV3LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtOZ0ZvciwgSWd4Q2FsZW5kYXJZZWFyRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hZZWFyc1ZpZXdDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogR2V0cy9zZXRzIHdoZXRoZXIgdGhlIHZpZXcgc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUgYW5kIHllYXJGb3JtYXQsIGlmIGFueS5cbiAgICAgKi9cbiAgICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgICBwdWJsaWMgZm9ybWF0VmlldzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gYSBzZWxlY3Rpb24gaXMgbWFkZSBpbiB0aGUgeWVhcnMgdmlldy5cbiAgICAgKiBQcm92aWRlcyByZWZlcmVuY2UgdGhlIGBkYXRlYCBwcm9wZXJ0eSBpbiB0aGUgYElneFllYXJzVmlld0NvbXBvbmVudGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gteWVhcnMtdmlldyAoc2VsZWN0ZWQpPVwib25TZWxlY3Rpb24oJGV2ZW50KVwiPjwvaWd4LXllYXJzLXZpZXc+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4WWVhcnNWaWV3Q29tcG9uZW50XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHNlbGVjdGVkID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY3NzIGNsYXNzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jYWxlbmRhcicpXG4gICAgcHVibGljIHN0eWxlQ2xhc3MgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGRyZW4oSWd4Q2FsZW5kYXJZZWFyRGlyZWN0aXZlLCB7IHJlYWQ6IElneENhbGVuZGFyWWVhckRpcmVjdGl2ZSB9KVxuICAgIHB1YmxpYyBjYWxlbmRhckRpcjogUXVlcnlMaXN0PElneENhbGVuZGFyWWVhckRpcmVjdGl2ZT47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZm9ybWF0dGVyWWVhcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgX2xvY2FsZSA9ICdlbic7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfeWVhckZvcm1hdCA9ICdudW1lcmljJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9jYWxlbmRhck1vZGVsOiBDYWxlbmRhcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSBub29wO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgX29uQ2hhbmdlQ2FsbGJhY2s6IChfOiBEYXRlKSA9PiB2b2lkID0gbm9vcDtcblxuICAgIC8qKlxuICAgICAqIEdldHMvc2V0cyB0aGUgc2VsZWN0ZWQgZGF0ZSBvZiB0aGUgeWVhcnMgdmlldy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGlzIHRoZSBjdXJyZW50IGRhdGUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gteWVhcnMtdmlldyBbZGF0ZV09XCJteURhdGVcIj48L2lneC15ZWFycy12aWV3PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZGF0ZSA9ICB0aGlzLnllYXJzVmlldy5kYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneFllYXJzVmlld0NvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGRhdGUodmFsdWU6IERhdGUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB5ZWFyIGZvcm1hdCBvcHRpb24gb2YgdGhlIHllYXJzIHZpZXcuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB5ZWFyRm9ybWF0ID0gdGhpcy55ZWFyc1ZpZXcueWVhckZvcm1hdC5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgeWVhckZvcm1hdCgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5feWVhckZvcm1hdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB5ZWFyIGZvcm1hdCBvcHRpb24gb2YgdGhlIHllYXJzIHZpZXcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gteWVhcnMtdmlldyBbeWVhckZvcm1hdF09XCJudW1lcmljXCI+PC9pZ3gteWVhcnMtdmlldz5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hZZWFyc1ZpZXdDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHllYXJGb3JtYXQodmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLl95ZWFyRm9ybWF0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaW5pdFllYXJGb3JtYXR0ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgbG9jYWxlYCBvZiB0aGUgeWVhcnMgdmlldy5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBcImVuXCJgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgbG9jYWxlID0gIHRoaXMueWVhcnNWaWV3LmxvY2FsZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hZZWFyc1ZpZXdDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgbG9jYWxlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYGxvY2FsZWAgb2YgdGhlIHllYXJzIHZpZXcuXG4gICAgICogRXhwZWN0cyBhIHZhbGlkIEJDUCA0NyBsYW5ndWFnZSB0YWcuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgXCJlblwiYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC15ZWFycy12aWV3IFtsb2NhbGVdPVwiZGVcIj48L2lneC15ZWFycy12aWV3PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneFllYXJzVmlld0NvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgbG9jYWxlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaW5pdFllYXJGb3JtYXR0ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRhdGUgb2JqZWN0cyB3aGljaCBhcmUgdGhlbiB1c2VkIHRvIHByb3Blcmx5XG4gICAgICogcmVuZGVyIHRoZSB5ZWFycy5cbiAgICAgKlxuICAgICAqIFVzZWQgaW4gdGhlIHRlbXBsYXRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBkZWNhZGUoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogRGF0ZVtdID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5kYXRlLmdldEZ1bGxZZWFyKCkgLSAzO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGUuZ2V0RnVsbFllYXIoKSArIDQ7XG5cbiAgICAgICAgZm9yIChjb25zdCB5ZWFyIG9mIHJhbmdlKHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRGF0ZSh5ZWFyLCB0aGlzLmRhdGUuZ2V0TW9udGgoKSwgdGhpcy5kYXRlLmdldERhdGUoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWw6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5pbml0WWVhckZvcm1hdHRlcigpO1xuICAgICAgICB0aGlzLl9jYWxlbmRhck1vZGVsID0gbmV3IENhbGVuZGFyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uYXJyb3dkb3duJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25LZXlkb3duQXJyb3dEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVZZWFyUmFuZ2UoMSk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJEaXIuZmluZChkYXRlID0+IGRhdGUuaXNDdXJyZW50WWVhcikubmF0aXZlRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5hcnJvd3VwJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25LZXlkb3duQXJyb3dVcChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB0aGlzLmdlbmVyYXRlWWVhclJhbmdlKC0xKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhckRpci5maW5kKGRhdGUgPT4gZGF0ZS5pc0N1cnJlbnRZZWFyKS5uYXRpdmVFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5lbnRlcicpXG4gICAgcHVibGljIG9uS2V5ZG93bkVudGVyKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkLmVtaXQodGhpcy5kYXRlKTtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayh0aGlzLmRhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvY2FsZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgeWVhciBpbiB0aGUgeWVhcnMgdmlldy5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZm9ybWF0dGVkWWVhcih2YWx1ZTogRGF0ZSk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdFZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZXJZZWFyLmZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlLmdldEZ1bGxZZWFyKCl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNlbGVjdFllYXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kYXRlID0gZXZlbnQ7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZC5lbWl0KHRoaXMuZGF0ZSk7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sodGhpcy5kYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhWSA8IDAgPyAtMSA6IDE7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVZZWFyUmFuZ2UoZGVsdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcGFuKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZXZlbnQuZGVsdGFZIDwgMCA/IDEgOiAtMTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVllYXJSYW5nZShkZWx0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyByZWdpc3Rlck9uQ2hhbmdlKGZuOiAodjogRGF0ZSkgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgeWVhclRyYWNrZXIoaW5kZXgsIGl0ZW0pOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7aXRlbS5nZXRGdWxsWWVhcigpfX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgd3JpdGVWYWx1ZSh2YWx1ZTogRGF0ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdFllYXJGb3JtYXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlclllYXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLl9sb2NhbGUsIHsgeWVhcjogdGhpcy55ZWFyRm9ybWF0IH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlWWVhclJhbmdlKGRlbHRhOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgaWYgKChkZWx0YSA+IDAgJiYgdGhpcy5kYXRlLmdldEZ1bGxZZWFyKCkgLSBjdXJyZW50WWVhciA+PSA5NSkgfHxcbiAgICAgICAgICAgIChkZWx0YSA8IDAgJiYgY3VycmVudFllYXIgLSB0aGlzLmRhdGUuZ2V0RnVsbFllYXIoKSA+PSA5NSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGUgPSB0aGlzLl9jYWxlbmRhck1vZGVsLnRpbWVkZWx0YSh0aGlzLmRhdGUsICd5ZWFyJywgZGVsdGEpO1xuICAgIH1cbn1cbiIsIjxkaXYgY2xhc3M9XCJpZ3gtY2FsZW5kYXJfX2JvZHlcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWNhbGVuZGFyX19ib2R5LWNvbHVtblwiICh3aGVlbCk9XCJzY3JvbGwoJGV2ZW50KVwiIChwYW4pPVwicGFuKCRldmVudClcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtY2FsZW5kYXJfX3llYXJcIlxuICAgICAgICAgICAgW2lneENhbGVuZGFyWWVhcl09XCJ5ZWFyXCJcbiAgICAgICAgICAgIFtkYXRlXT1cImRhdGVcIlxuICAgICAgICAgICAgKHllYXJTZWxlY3Rpb24pPVwic2VsZWN0WWVhcigkZXZlbnQpXCJcbiAgICAgICAgICAgICpuZ0Zvcj1cImxldCB5ZWFyIG9mIGRlY2FkZTsgdHJhY2tCeTogeWVhclRyYWNrZXJcIj5cblxuICAgICAgICAgICAge3sgZm9ybWF0dGVkWWVhcih5ZWFyKSB9fVxuICAgICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG48L2Rpdj5cbiJdfQ==