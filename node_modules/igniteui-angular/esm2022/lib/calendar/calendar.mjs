import { DateRangeType } from '../core/dates';
import { mkenum } from '../core/utils';
/**
 * Sets the selection type - single, multi or range.
 */
export const CalendarSelection = /*@__PURE__*/ mkenum({
    SINGLE: 'single',
    MULTI: 'multi',
    RANGE: 'range'
});
export const IgxCalendarView = /*@__PURE__*/ mkenum({
    Month: 'month',
    Year: 'year',
    Decade: 'decade'
});
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;
export const range = (start = 0, stop, step = 1) => {
    const res = [];
    const cur = (stop === undefined) ? 0 : start;
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
};
/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param year
 * @returns
 */
export const isLeap = (year) => (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
export const weekDay = (year, month, day) => new Date(year, month, day).getDay();
/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param year
 * @param month
 * @returns
 */
export const monthRange = (year, month) => {
    if ((month < 0) || (month > 11)) {
        throw new Error('Invalid month specified');
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
};
export const isDateInRanges = (date, ranges) => {
    date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const dateInMs = date.getTime();
    if (!ranges) {
        return false;
    }
    for (const descriptor of ranges) {
        const dRanges = descriptor.dateRange ? descriptor.dateRange.map(r => new Date(r.getFullYear(), r.getMonth(), r.getDate())) : undefined;
        switch (descriptor.type) {
            case (DateRangeType.After):
                if (dateInMs > dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Before):
                if (dateInMs < dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Between):
                const dRange = dRanges.map(d => d.getTime());
                const min = Math.min(dRange[0], dRange[1]);
                const max = Math.max(dRange[0], dRange[1]);
                if (dateInMs >= min && dateInMs <= max) {
                    return true;
                }
                break;
            case (DateRangeType.Specific):
                const datesInMs = dRanges.map(d => d.getTime());
                for (const specificDateInMs of datesInMs) {
                    if (dateInMs === specificDateInMs) {
                        return true;
                    }
                }
                break;
            case (DateRangeType.Weekdays):
                const day = date.getDay();
                if (day % 6 !== 0) {
                    return true;
                }
                break;
            case (DateRangeType.Weekends):
                const weekday = date.getDay();
                if (weekday % 6 === 0) {
                    return true;
                }
                break;
            default:
                return false;
        }
    }
    return false;
};
export var WEEKDAYS;
(function (WEEKDAYS) {
    WEEKDAYS[WEEKDAYS["SUNDAY"] = 0] = "SUNDAY";
    WEEKDAYS[WEEKDAYS["MONDAY"] = 1] = "MONDAY";
    WEEKDAYS[WEEKDAYS["TUESDAY"] = 2] = "TUESDAY";
    WEEKDAYS[WEEKDAYS["WEDNESDAY"] = 3] = "WEDNESDAY";
    WEEKDAYS[WEEKDAYS["THURSDAY"] = 4] = "THURSDAY";
    WEEKDAYS[WEEKDAYS["FRIDAY"] = 5] = "FRIDAY";
    WEEKDAYS[WEEKDAYS["SATURDAY"] = 6] = "SATURDAY";
})(WEEKDAYS || (WEEKDAYS = {}));
export class Calendar {
    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }
    get firstWeekDay() {
        return this._firstWeekDay % 7;
    }
    set firstWeekDay(value) {
        this._firstWeekDay = value;
    }
    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns
     *
     * @memberof Calendar
     */
    weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }
    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param year
     * @param month
     * @param boolean
     * @returns
     *
     * @memberof Calendar
     */
    monthdates(year, month, extraWeek = false) {
        let date = new Date(year, month, 1);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, 'day', -days);
        const res = [];
        let value;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, 'day', 1);
            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const _ of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, 'day', 1);
                    }
                }
                break;
            }
        }
        return res;
    }
    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param year
     * @param month
     * @returns
     *
     * @memberof Calendar
     */
    monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }
    timedelta(date, interval, units) {
        const ret = new Date(date);
        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };
        switch (interval.toLowerCase()) {
            case 'year':
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case 'quarter':
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case 'month':
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case 'week':
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case 'day':
                ret.setDate(ret.getDate() + units);
                break;
            case 'hour':
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case 'minute':
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case 'second':
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error('Invalid interval specifier');
        }
        return ret;
    }
    formatToParts(date, locale, options, parts) {
        const formatter = new Intl.DateTimeFormat(locale, options);
        const result = {
            date,
            full: formatter.format(date)
        };
        if (formatter.formatToParts) {
            const formattedParts = formatter.formatToParts(date);
            const toType = (partType) => {
                const index = formattedParts.findIndex(({ type }) => type === partType);
                const o = { value: '', literal: '', combined: '' };
                if (partType === 'era' && index > -1) {
                    o.value = formattedParts[index].value;
                    return o;
                }
                else if (partType === 'era' && index === -1) {
                    return o;
                }
                o.value = formattedParts[index].value;
                o.literal = formattedParts[index + 1] ? formattedParts[index + 1].value : '';
                o.combined = [o.value, o.literal].join('');
                return o;
            };
            for (const each of parts) {
                result[each] = toType(each);
            }
        }
        else {
            for (const each of parts) {
                result[each] = { value: '', literal: '', combined: '' };
            }
        }
        return result;
    }
    getFirstViewDate(date, interval, activeViewIdx) {
        return this.timedelta(date, interval, -activeViewIdx);
    }
    getDateByView(date, interval, activeViewIdx) {
        return this.timedelta(date, interval, activeViewIdx);
    }
    getNextMonth(date) {
        return this.timedelta(date, "month" /* TimeDeltaInterval.Month */, 1);
    }
    getPrevMonth(date) {
        return this.timedelta(date, "month" /* TimeDeltaInterval.Month */, -1);
    }
    getNextYear(date) {
        return this.timedelta(date, "year" /* TimeDeltaInterval.Year */, 1);
    }
    getPrevYear(date) {
        return this.timedelta(date, "year" /* TimeDeltaInterval.Year */, -1);
    }
    getWeekNumber(date, weekStart) {
        // current year
        const yearStart = new Date(date.getFullYear(), 0, 1);
        // first day number of the current year
        let firstDayOfTheYear = yearStart.getDay() - weekStart;
        firstDayOfTheYear = firstDayOfTheYear >= 0 ? firstDayOfTheYear : firstDayOfTheYear + 7;
        const dayInMilSeconds = 86400000;
        // day number in the year
        const dayNumber = Math.floor((date.getTime() - yearStart.getTime() -
            (date.getTimezoneOffset() - yearStart.getTimezoneOffset()) * 60000) / dayInMilSeconds) + 1;
        let weekNumber;
        // if 01 Jan is Monday to Thursday, is considered 1st week of the year
        // if 01 Jan starts Friday to Sunday, is considered last week of previous year
        if (firstDayOfTheYear < 4) {
            // when calculating the week number we add 1 for the 1st week
            weekNumber = Math.floor((dayNumber + firstDayOfTheYear - 1) / 7) + 1;
        }
        else {
            // calculating the week number
            weekNumber = Math.floor((dayNumber + firstDayOfTheYear - 1) / 7);
        }
        // if the week number is greater than week 52
        if (weekNumber > 52) {
            // next year
            const nextYear = new Date(date.getFullYear() + 1, 0, 1);
            // first day of the next year
            let nextYearFirstDay = nextYear.getDay() - weekStart;
            nextYearFirstDay = nextYearFirstDay >= 0 ? nextYearFirstDay : nextYearFirstDay + 7;
            // if 01 Jan of the next year is Monday to Thursday, is considered 1st week of the next year
            // if 01 Jan is Friday to Sunday, is considered 53rd week of the current year
            weekNumber = nextYearFirstDay < 4 ? 1 : 53;
        }
        return weekNumber;
    }
    generateICalendarDate(date, year, month) {
        return {
            date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month)
        };
    }
    isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }
    isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvY2FsZW5kYXIvY2FsZW5kYXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUF1QixhQUFhLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV2Qzs7R0FFRztBQUNILE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFHLGFBQWEsQ0FBQSxNQUFNLENBQUM7SUFDakQsTUFBTSxFQUFFLFFBQVE7SUFDaEIsS0FBSyxFQUFFLE9BQU87SUFDZCxLQUFLLEVBQUUsT0FBTztDQUNqQixDQUFDLENBQUM7QUFjSCxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsYUFBYSxDQUFBLE1BQU0sQ0FBQztJQUMvQyxLQUFLLEVBQUUsT0FBTztJQUNkLElBQUksRUFBRSxNQUFNO0lBQ1osTUFBTSxFQUFFLFFBQVE7Q0FDbkIsQ0FBQyxDQUFDO0FBZUgsTUFBTSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQy9ELE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQztBQUVuQixNQUFNLENBQUMsTUFBTSxLQUFLLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEdBQUcsQ0FBQyxFQUFFLEVBQUU7SUFDL0MsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQ2YsTUFBTSxHQUFHLEdBQUcsQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFD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QUFDLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDO1lBQ2hELFdBQVcsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDO1NBQ3ZELENBQUM7SUFDTixDQUFDO0lBRU8sZUFBZSxDQUFDLElBQVUsRUFBRSxJQUFZLEVBQUUsS0FBYTtRQUMzRCxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDN0IsT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsS0FBSyxDQUFDO1NBQ2xDO1FBQ0QsT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQ3JDLENBQUM7SUFFTyxXQUFXLENBQUMsSUFBVSxFQUFFLElBQVksRUFBRSxLQUFhO1FBQ3ZELElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLElBQUksRUFBRTtZQUM3QixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUM7U0FDbEM7UUFFRCxPQUFPLElBQUksQ0FBQyxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUM7SUFDckMsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0ZVJhbmdlRGVzY3JpcHRvciwgRGF0ZVJhbmdlVHlwZSB9IGZyb20gJy4uL2NvcmUvZGF0ZXMnO1xuaW1wb3J0IHsgbWtlbnVtIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5cbi8qKlxuICogU2V0cyB0aGUgc2VsZWN0aW9uIHR5cGUgLSBzaW5nbGUsIG11bHRpIG9yIHJhbmdlLlxuICovXG5leHBvcnQgY29uc3QgQ2FsZW5kYXJTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovbWtlbnVtKHtcbiAgICBTSU5HTEU6ICdzaW5nbGUnLFxuICAgIE1VTFRJOiAnbXVsdGknLFxuICAgIFJBTkdFOiAncmFuZ2UnXG59KTtcbmV4cG9ydCB0eXBlIENhbGVuZGFyU2VsZWN0aW9uID0gKHR5cGVvZiBDYWxlbmRhclNlbGVjdGlvbilba2V5b2YgdHlwZW9mIENhbGVuZGFyU2VsZWN0aW9uXTtcblxuZXhwb3J0IGNvbnN0IGVudW0gU2Nyb2xsTW9udGgge1xuICAgIFBSRVYgPSAncHJldicsXG4gICAgTkVYVCA9ICduZXh0JyxcbiAgICBOT05FID0gJ25vbmUnXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZpZXdEYXRlQ2hhbmdlRXZlbnRBcmdzIHtcbiAgICBwcmV2aW91c1ZhbHVlOiBEYXRlO1xuICAgIGN1cnJlbnRWYWx1ZTogRGF0ZTtcbn1cblxuZXhwb3J0IGNvbnN0IElneENhbGVuZGFyVmlldyA9IC8qQF9fUFVSRV9fKi9ta2VudW0oe1xuICAgIE1vbnRoOiAnbW9udGgnLFxuICAgIFllYXI6ICd5ZWFyJyxcbiAgICBEZWNhZGU6ICdkZWNhZGUnXG59KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBDYWxlbmRhciBhY3RpdmUgdmlldyAtIGRheXMsIG1vbnRocyBvciB5ZWFycy5cbiAqL1xuZXhwb3J0IHR5cGUgSWd4Q2FsZW5kYXJWaWV3ID0gKHR5cGVvZiBJZ3hDYWxlbmRhclZpZXcpW2tleW9mIHR5cGVvZiBJZ3hDYWxlbmRhclZpZXddO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZW51bSBUaW1lRGVsdGFJbnRlcnZhbCB7XG4gICAgTW9udGggPSAnbW9udGgnLFxuICAgIFllYXIgPSAneWVhcidcbn1cblxuY29uc3QgTURBWVMgPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5jb25zdCBGRUJSVUFSWSA9IDE7XG5cbmV4cG9ydCBjb25zdCByYW5nZSA9IChzdGFydCA9IDAsIHN0b3AsIHN0ZXAgPSAxKSA9PiB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgY3VyID0gKHN0b3AgPT09IHVuZGVmaW5lZCkgPyAwIDogc3RhcnQ7XG4gICAgY29uc3QgbWF4ID0gKHN0b3AgPT09IHVuZGVmaW5lZCkgPyBzdGFydCA6IHN0b3A7XG4gICAgZm9yIChsZXQgaSA9IGN1cjsgc3RlcCA8IDAgPyBpID4gbWF4IDogaSA8IG1heDsgaSArPSBzdGVwKSB7XG4gICAgICAgIHJlcy5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgZm9yIGxlYXAgeWVhcnMsIGZhbHNlIGZvciBub24tbGVhcCB5ZWFycy5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0geWVhclxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTGVhcCA9ICh5ZWFyOiBudW1iZXIpOiBib29sZWFuID0+ICh5ZWFyICUgNCA9PT0gMCkgJiYgKCh5ZWFyICUgMTAwICE9PSAwKSB8fCAoeWVhciAlIDQwMCA9PT0gMCkpO1xuXG5leHBvcnQgY29uc3Qgd2Vla0RheSA9ICh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyKTogbnVtYmVyID0+IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpLmdldERheSgpO1xuXG4vKipcbiAqIFJldHVybiB3ZWVrZGF5IGFuZCBudW1iZXIgb2YgZGF5cyBmb3IgeWVhciwgbW9udGguXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHllYXJcbiAqIEBwYXJhbSBtb250aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGNvbnN0IG1vbnRoUmFuZ2UgPSAoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xuICAgIGlmICgobW9udGggPCAwKSB8fCAobW9udGggPiAxMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vbnRoIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICBjb25zdCBkYXkgPSB3ZWVrRGF5KHllYXIsIG1vbnRoLCAxKTtcbiAgICBsZXQgbkRheXMgPSBNREFZU1ttb250aF07XG4gICAgaWYgKChtb250aCA9PT0gRkVCUlVBUlkpICYmIChpc0xlYXAoeWVhcikpKSB7XG4gICAgICAgIG5EYXlzKys7XG4gICAgfVxuICAgIHJldHVybiBbZGF5LCBuRGF5c107XG59O1xuXG5leHBvcnQgY29uc3QgaXNEYXRlSW5SYW5nZXMgPSAoZGF0ZTogRGF0ZSwgcmFuZ2VzOiBEYXRlUmFuZ2VEZXNjcmlwdG9yW10pOiBib29sZWFuID0+IHtcbiAgICBkYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICBjb25zdCBkYXRlSW5NcyA9IGRhdGUuZ2V0VGltZSgpO1xuXG4gICAgaWYgKCFyYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiByYW5nZXMpIHtcbiAgICAgICAgY29uc3QgZFJhbmdlcyA9IGRlc2NyaXB0b3IuZGF0ZVJhbmdlID8gZGVzY3JpcHRvci5kYXRlUmFuZ2UubWFwKFxuICAgICAgICAgICAgciA9PiBuZXcgRGF0ZShyLmdldEZ1bGxZZWFyKCksIHIuZ2V0TW9udGgoKSwgci5nZXREYXRlKCkpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgc3dpdGNoIChkZXNjcmlwdG9yLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgKERhdGVSYW5nZVR5cGUuQWZ0ZXIpOlxuICAgICAgICAgICAgICAgIGlmIChkYXRlSW5NcyA+IGRSYW5nZXNbMF0uZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoRGF0ZVJhbmdlVHlwZS5CZWZvcmUpOlxuICAgICAgICAgICAgICAgIGlmIChkYXRlSW5NcyA8IGRSYW5nZXNbMF0uZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoRGF0ZVJhbmdlVHlwZS5CZXR3ZWVuKTpcbiAgICAgICAgICAgICAgICBjb25zdCBkUmFuZ2UgPSBkUmFuZ2VzLm1hcChkID0+IGQuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihkUmFuZ2VbMF0sIGRSYW5nZVsxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoZFJhbmdlWzBdLCBkUmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgIGlmIChkYXRlSW5NcyA+PSBtaW4gJiYgZGF0ZUluTXMgPD0gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoRGF0ZVJhbmdlVHlwZS5TcGVjaWZpYyk6XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZXNJbk1zID0gZFJhbmdlcy5tYXAoZCA9PiBkLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpY0RhdGVJbk1zIG9mIGRhdGVzSW5Ncykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZUluTXMgPT09IHNwZWNpZmljRGF0ZUluTXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIChEYXRlUmFuZ2VUeXBlLldlZWtkYXlzKTpcbiAgICAgICAgICAgICAgICBjb25zdCBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXkgJSA2ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoRGF0ZVJhbmdlVHlwZS5XZWVrZW5kcyk6XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Vla2RheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgJSA2ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIElDYWxlbmRhckRhdGUge1xuICAgIGRhdGU6IERhdGU7XG4gICAgaXNDdXJyZW50TW9udGg6IGJvb2xlYW47XG4gICAgaXNQcmV2TW9udGg6IGJvb2xlYW47XG4gICAgaXNOZXh0TW9udGg6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZvcm1hdHRlZFBhcnRzIHtcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGxpdGVyYWw/OiBzdHJpbmc7XG4gICAgY29tYmluZWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRm9ybWF0dGluZ09wdGlvbnMge1xuICAgIGRheT86ICdudW1lcmljJyB8ICcyLWRpZ2l0JztcbiAgICBtb250aD86ICdudW1lcmljJyB8ICcyLWRpZ2l0JyB8ICdsb25nJyB8ICdzaG9ydCcgfCAnbmFycm93JztcbiAgICB3ZWVrZGF5PzogJ2xvbmcnIHwgJ3Nob3J0JyB8ICduYXJyb3cnO1xuICAgIHllYXI/OiAnbnVtZXJpYycgfCAnMi1kaWdpdCc7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBJRm9ybWF0dGluZ1ZpZXdzIHtcbiAgICBkYXk/OiBib29sZWFuO1xuICAgIG1vbnRoPzogYm9vbGVhbjtcbiAgICB5ZWFyPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGVudW0gV0VFS0RBWVMge1xuICAgIFNVTkRBWSxcbiAgICBNT05EQVksXG4gICAgVFVFU0RBWSxcbiAgICBXRURORVNEQVksXG4gICAgVEhVUlNEQVksXG4gICAgRlJJREFZLFxuICAgIFNBVFVSREFZXG59XG5cbmV4cG9ydCBjbGFzcyBDYWxlbmRhciB7XG5cbiAgICBwcml2YXRlIF9maXJzdFdlZWtEYXk6IFdFRUtEQVlTIHwgbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IoZmlyc3RXZWVrRGF5OiBXRUVLREFZUyA9IFdFRUtEQVlTLlNVTkRBWSkge1xuICAgICAgICB0aGlzLl9maXJzdFdlZWtEYXkgPSBmaXJzdFdlZWtEYXk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBmaXJzdFdlZWtEYXkoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0V2Vla0RheSAlIDc7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBmaXJzdFdlZWtEYXkodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9maXJzdFdlZWtEYXkgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHdlZWtkYXlzIGZvciBvbmUgd2VlayBzdGFydGluZ1xuICAgICAqIHdpdGggdGhlIGN1cnJlbnRseSBzZXQgYGZpcnN0V2Vla0RheWBcbiAgICAgKlxuICAgICAqIHRoaXMuZmlyc3RXZWVrRGF5ID0gMCAoU3VuZGF5KSAtLT4gWzAsIDEsIDIsIDMsIDQsIDUsIDZdXG4gICAgICogdGhpcy5maXJzdFdlZWtEYXkgPSAxIChNb25kYXkpIC0tPiBbMSwgMiwgMywgNCwgNSwgNiwgMF1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ2FsZW5kYXJcbiAgICAgKi9cbiAgICBwdWJsaWMgd2Vla2RheXMoKTogbnVtYmVyW10ge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKHRoaXMuZmlyc3RXZWVrRGF5LCB0aGlzLmZpcnN0V2Vla0RheSArIDcpKSB7XG4gICAgICAgICAgICByZXMucHVzaChpICUgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRlIHZhbHVlcyBmb3Igb25lIG1vbnRoLiBJdCB3aWxsIGFsd2F5cyBpdGVyYXRlIHRocm91Z2h0XG4gICAgICogY29tcGxldGUgd2Vla3MsIHNvIGl0IHdpbGwgY29udGFpbiBkYXRlcyBvdXRzaWRlIHRoZSBzcGVjaWZpZWQgbW9udGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhclxuICAgICAqIEBwYXJhbSBtb250aFxuICAgICAqIEBwYXJhbSBib29sZWFuXG4gICAgICogQHJldHVybnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDYWxlbmRhclxuICAgICAqL1xuICAgIHB1YmxpYyBtb250aGRhdGVzKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZXh0cmFXZWVrID0gZmFsc2UpOiBJQ2FsZW5kYXJEYXRlW10ge1xuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgICAgICAgbGV0IGRheXMgPSAoZGF0ZS5nZXREYXkoKSAtIHRoaXMuZmlyc3RXZWVrRGF5KSAlIDc7XG4gICAgICAgIGlmIChkYXlzIDwgMCkge1xuICAgICAgICAgICAgZGF5cyA9IDcgLSBNYXRoLmFicyhkYXlzKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRlID0gdGhpcy50aW1lZGVsdGEoZGF0ZSwgJ2RheScsIC1kYXlzKTtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGxldCB2YWx1ZTogSUNhbGVuZGFyRGF0ZTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZW5lcmF0ZUlDYWxlbmRhckRhdGUoZGF0ZSwgeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgcmVzLnB1c2godmFsdWUpO1xuXG4gICAgICAgICAgICBkYXRlID0gdGhpcy50aW1lZGVsdGEoZGF0ZSwgJ2RheScsIDEpO1xuXG4gICAgICAgICAgICBpZiAoKGRhdGUuZ2V0TW9udGgoKSAhPT0gbW9udGgpICYmIChkYXRlLmdldERheSgpID09PSB0aGlzLmZpcnN0V2Vla0RheSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFXZWVrICYmIHJlcy5sZW5ndGggPD0gMzUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBfIG9mIHJhbmdlKDAsIDcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2VuZXJhdGVJQ2FsZW5kYXJEYXRlKGRhdGUsIHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSB0aGlzLnRpbWVkZWx0YShkYXRlLCAnZGF5JywgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IChhcnJheSBvZiBhcnJheXMpIHJlcHJlc2VudGluZyBhIG1vbnRoJ3MgY2FsZW5kYXIuXG4gICAgICogRWFjaCByb3cgcmVwcmVzZW50cyBhIGZ1bGwgd2Vlazsgd2VlayBlbnRyaWVzIGFyZSBJQ2FsZW5kYXJEYXRlIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhclxuICAgICAqIEBwYXJhbSBtb250aFxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ2FsZW5kYXJcbiAgICAgKi9cbiAgICBwdWJsaWMgbW9udGhkYXRlc2NhbGVuZGFyKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZXh0cmFXZWVrID0gZmFsc2UpOiBJQ2FsZW5kYXJEYXRlW11bXSB7XG4gICAgICAgIGNvbnN0IGRhdGVzID0gdGhpcy5tb250aGRhdGVzKHllYXIsIG1vbnRoLCBleHRyYVdlZWspO1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKDAsIGRhdGVzLmxlbmd0aCwgNykpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGRhdGVzLnNsaWNlKGksIGkgKyA3KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgdGltZWRlbHRhKGRhdGU6IERhdGUsIGludGVydmFsOiBzdHJpbmcsIHVuaXRzOiBudW1iZXIpOiBEYXRlIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IERhdGUoZGF0ZSk7XG5cbiAgICAgICAgY29uc3QgY2hlY2tSb2xsb3ZlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXQuZ2V0RGF0ZSgpICE9PSBkYXRlLmdldERhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldC5zZXREYXRlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAoaW50ZXJ2YWwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgcmV0LnNldEZ1bGxZZWFyKHJldC5nZXRGdWxsWWVhcigpICsgdW5pdHMpO1xuICAgICAgICAgICAgICAgIGNoZWNrUm9sbG92ZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHJldC5zZXRNb250aChyZXQuZ2V0TW9udGgoKSArIDMgKiB1bml0cyk7XG4gICAgICAgICAgICAgICAgY2hlY2tSb2xsb3ZlcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHJldC5zZXRNb250aChyZXQuZ2V0TW9udGgoKSArIHVuaXRzKTtcbiAgICAgICAgICAgICAgICBjaGVja1JvbGxvdmVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICByZXQuc2V0RGF0ZShyZXQuZ2V0RGF0ZSgpICsgNyAqIHVuaXRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgcmV0LnNldERhdGUocmV0LmdldERhdGUoKSArIHVuaXRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHJldC5zZXRUaW1lKHJldC5nZXRUaW1lKCkgKyB1bml0cyAqIDM2MDAwMDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICByZXQuc2V0VGltZShyZXQuZ2V0VGltZSgpICsgdW5pdHMgKiA2MDAwMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHJldC5zZXRUaW1lKHJldC5nZXRUaW1lKCkgKyB1bml0cyAqIDEwMDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZXJ2YWwgc3BlY2lmaWVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZm9ybWF0VG9QYXJ0cyhkYXRlOiBEYXRlLCBsb2NhbGU6IHN0cmluZywgb3B0aW9uczogYW55LCBwYXJ0czogc3RyaW5nW10pIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGZ1bGw6IGZvcm1hdHRlci5mb3JtYXQoZGF0ZSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoKGZvcm1hdHRlciBhcyBhbnkpLmZvcm1hdFRvUGFydHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFBhcnRzID0gKGZvcm1hdHRlciBhcyBhbnkpLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRvVHlwZSA9IChwYXJ0VHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBmb3JtYXR0ZWRQYXJ0cy5maW5kSW5kZXgoKHsgdHlwZSB9KSA9PiB0eXBlID09PSBwYXJ0VHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbzogSUZvcm1hdHRlZFBhcnRzID0geyB2YWx1ZTogJycsIGxpdGVyYWw6ICcnLCBjb21iaW5lZDogJycgfTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJ0VHlwZSA9PT0gJ2VyYScgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvLnZhbHVlID0gZm9ybWF0dGVkUGFydHNbaW5kZXhdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRUeXBlID09PSAnZXJhJyAmJiBpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgby52YWx1ZSA9IGZvcm1hdHRlZFBhcnRzW2luZGV4XS52YWx1ZTtcbiAgICAgICAgICAgICAgICBvLmxpdGVyYWwgPSBmb3JtYXR0ZWRQYXJ0c1tpbmRleCArIDFdID8gZm9ybWF0dGVkUGFydHNbaW5kZXggKyAxXS52YWx1ZSA6ICcnO1xuICAgICAgICAgICAgICAgIG8uY29tYmluZWQgPSBbby52YWx1ZSwgby5saXRlcmFsXS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZWFjaCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtlYWNoXSA9IHRvVHlwZShlYWNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWFjaCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtlYWNoXSA9IHsgdmFsdWU6ICcnLCBsaXRlcmFsOiAnJywgY29tYmluZWQ6ICcnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Rmlyc3RWaWV3RGF0ZShkYXRlOiBEYXRlLCBpbnRlcnZhbDogc3RyaW5nLCBhY3RpdmVWaWV3SWR4OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZWRlbHRhKGRhdGUsIGludGVydmFsLCAtYWN0aXZlVmlld0lkeCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldERhdGVCeVZpZXcoZGF0ZTogRGF0ZSwgaW50ZXJ2YWw6IHN0cmluZywgYWN0aXZlVmlld0lkeDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVkZWx0YShkYXRlLCBpbnRlcnZhbCwgYWN0aXZlVmlld0lkeCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE5leHRNb250aChkYXRlOiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVkZWx0YShkYXRlLCBUaW1lRGVsdGFJbnRlcnZhbC5Nb250aCwgMSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFByZXZNb250aChkYXRlOiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVkZWx0YShkYXRlLCBUaW1lRGVsdGFJbnRlcnZhbC5Nb250aCwgLTEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXROZXh0WWVhcihkYXRlOiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVkZWx0YShkYXRlLCBUaW1lRGVsdGFJbnRlcnZhbC5ZZWFyLCAxKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UHJldlllYXIoZGF0ZTogRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lZGVsdGEoZGF0ZSwgVGltZURlbHRhSW50ZXJ2YWwuWWVhciwgLTEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRXZWVrTnVtYmVyKGRhdGU6IERhdGUsIHdlZWtTdGFydDogV0VFS0RBWVMgfCBudW1iZXIpIHtcbiAgICAgICAgLy8gY3VycmVudCB5ZWFyXG4gICAgICAgIGNvbnN0IHllYXJTdGFydCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICAgIC8vIGZpcnN0IGRheSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgeWVhclxuICAgICAgICBsZXQgZmlyc3REYXlPZlRoZVllYXIgPSB5ZWFyU3RhcnQuZ2V0RGF5KCkgLSB3ZWVrU3RhcnQ7XG4gICAgICAgIGZpcnN0RGF5T2ZUaGVZZWFyID0gZmlyc3REYXlPZlRoZVllYXIgPj0gMCA/IGZpcnN0RGF5T2ZUaGVZZWFyIDogZmlyc3REYXlPZlRoZVllYXIgKyA3O1xuICAgICAgICBjb25zdCBkYXlJbk1pbFNlY29uZHMgPSA4NjQwMDAwMDtcbiAgICAgICAgLy8gZGF5IG51bWJlciBpbiB0aGUgeWVhclxuICAgICAgICBjb25zdCBkYXlOdW1iZXIgPSBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIHllYXJTdGFydC5nZXRUaW1lKCkgLVxuICAgICAgICAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC0geWVhclN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNjAwMDApIC8gZGF5SW5NaWxTZWNvbmRzKSArIDE7XG4gICAgICAgIGxldCB3ZWVrTnVtYmVyO1xuICAgICAgICAvLyBpZiAwMSBKYW4gaXMgTW9uZGF5IHRvIFRodXJzZGF5LCBpcyBjb25zaWRlcmVkIDFzdCB3ZWVrIG9mIHRoZSB5ZWFyXG4gICAgICAgIC8vIGlmIDAxIEphbiBzdGFydHMgRnJpZGF5IHRvIFN1bmRheSwgaXMgY29uc2lkZXJlZCBsYXN0IHdlZWsgb2YgcHJldmlvdXMgeWVhclxuICAgICAgICBpZiAoZmlyc3REYXlPZlRoZVllYXIgPCA0KSB7XG4gICAgICAgICAgICAvLyB3aGVuIGNhbGN1bGF0aW5nIHRoZSB3ZWVrIG51bWJlciB3ZSBhZGQgMSBmb3IgdGhlIDFzdCB3ZWVrXG4gICAgICAgICAgICB3ZWVrTnVtYmVyID0gTWF0aC5mbG9vcigoZGF5TnVtYmVyICsgZmlyc3REYXlPZlRoZVllYXIgLSAxKSAvIDcpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0aW5nIHRoZSB3ZWVrIG51bWJlclxuICAgICAgICAgICAgd2Vla051bWJlciA9IE1hdGguZmxvb3IoKGRheU51bWJlciArIGZpcnN0RGF5T2ZUaGVZZWFyIC0gMSkgLyA3KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgd2VlayBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIHdlZWsgNTJcbiAgICAgICAgaWYgKHdlZWtOdW1iZXIgPiA1Mikge1xuICAgICAgICAgICAgLy8gbmV4dCB5ZWFyXG4gICAgICAgICAgICBjb25zdCBuZXh0WWVhciA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSArIDEsIDAsIDEpO1xuICAgICAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBuZXh0IHllYXJcbiAgICAgICAgICAgIGxldCBuZXh0WWVhckZpcnN0RGF5ID0gbmV4dFllYXIuZ2V0RGF5KCkgLSB3ZWVrU3RhcnQ7XG4gICAgICAgICAgICBuZXh0WWVhckZpcnN0RGF5ID0gbmV4dFllYXJGaXJzdERheSA+PSAwID8gbmV4dFllYXJGaXJzdERheSA6IG5leHRZZWFyRmlyc3REYXkgKyA3O1xuICAgICAgICAgICAgLy8gaWYgMDEgSmFuIG9mIHRoZSBuZXh0IHllYXIgaXMgTW9uZGF5IHRvIFRodXJzZGF5LCBpcyBjb25zaWRlcmVkIDFzdCB3ZWVrIG9mIHRoZSBuZXh0IHllYXJcbiAgICAgICAgICAgIC8vIGlmIDAxIEphbiBpcyBGcmlkYXkgdG8gU3VuZGF5LCBpcyBjb25zaWRlcmVkIDUzcmQgd2VlayBvZiB0aGUgY3VycmVudCB5ZWFyXG4gICAgICAgICAgICB3ZWVrTnVtYmVyID0gbmV4dFllYXJGaXJzdERheSA8IDQgPyAxIDogNTM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlZWtOdW1iZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUlDYWxlbmRhckRhdGUoZGF0ZTogRGF0ZSwgeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogSUNhbGVuZGFyRGF0ZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgaXNDdXJyZW50TW9udGg6IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0geWVhciAmJiBkYXRlLmdldE1vbnRoKCkgPT09IG1vbnRoLFxuICAgICAgICAgICAgaXNOZXh0TW9udGg6IHRoaXMuaXNOZXh0TW9udGgoZGF0ZSwgeWVhciwgbW9udGgpLFxuICAgICAgICAgICAgaXNQcmV2TW9udGg6IHRoaXMuaXNQcmV2aW91c01vbnRoKGRhdGUsIHllYXIsIG1vbnRoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNQcmV2aW91c01vbnRoKGRhdGU6IERhdGUsIHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZGF0ZS5nZXRGdWxsWWVhcigpID09PSB5ZWFyKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpIDwgbW9udGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSA8IHllYXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc05leHRNb250aChkYXRlOiBEYXRlLCB5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0geWVhcikge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSA+IG1vbnRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSA+IHllYXI7XG4gICAgfVxufVxuIl19