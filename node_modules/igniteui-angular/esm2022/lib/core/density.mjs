import { InjectionToken, Input, Output, EventEmitter, Directive, Optional, Inject, } from '@angular/core';
import { mkenum } from './utils';
import * as i0 from "@angular/core";
/**
 * Defines the possible values of the components' display density.
 */
export const DisplayDensity = mkenum({
    comfortable: 'comfortable',
    cosy: 'cosy',
    compact: 'compact',
});
/**
 * Defines the DisplayDensity DI token.
 *
 * @deprecated since version 16.1.0.
 * Please use the `--ig-size` CSS custom property.
 * @see {@link [Update Guide](https://www.infragistics.com/products/ignite-ui-angular/angular/components/general/update-guide#from-160x-to-161x)}
 *
 * @hidden
 */
export const DisplayDensityToken = new InjectionToken('DisplayDensity');
/**
 * @hidden
 * Base class containing all logic required for implementing DisplayDensity.
 */
// eslint-disable-next-line @angular-eslint/directive-class-suffix
export class DisplayDensityBase {
    /**
     * Returns the theme of the component.
     * The default theme is `comfortable`.
     * Available options are `comfortable`, `cosy`, `compact`.
     * ```typescript
     * let componentTheme = this.component.displayDensity;
     * ```
     *
     * @deprecated since version 16.1.0.
     * Please use the `--ig-size` CSS custom property.
     * @see {@link [Update Guide](https://www.infragistics.com/products/ignite-ui-angular/angular/components/general/update-guide#from-160x-to-161x)}
     */
    get displayDensity() {
        return (this._displayDensity ??
            this.displayDensityOptions?.displayDensity ??
            DisplayDensity.comfortable);
    }
    /**
     * Sets the theme of the component.
     */
    set displayDensity(val) {
        const currentDisplayDensity = this._displayDensity;
        this._displayDensity = val;
        if (currentDisplayDensity !== this._displayDensity) {
            const densityChangedArgs = {
                oldDensity: currentDisplayDensity,
                newDensity: this._displayDensity,
            };
            this.densityChanged.emit(densityChangedArgs);
        }
    }
    constructor(displayDensityOptions, _host) {
        this.displayDensityOptions = displayDensityOptions;
        this._host = _host;
        this.densityChanged = new EventEmitter();
        this.oldDisplayDensityOptions = {
            displayDensity: DisplayDensity.comfortable,
        };
        Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        const el = this._host?.nativeElement;
        if (el instanceof Element) {
            const size = globalThis.document?.defaultView
                .getComputedStyle(el)
                .getPropertyValue("--ig-size")
                .trim();
            switch (size) {
                case '1':
                    this._displayDensity = DisplayDensity.compact;
                    break;
                case '2':
                    this._displayDensity = DisplayDensity.cosy;
                    break;
                case '3':
                    this._displayDensity = DisplayDensity.comfortable;
                    break;
            }
        }
        this.initialDensity = this._displayDensity;
    }
    /** @hidden @internal **/
    ngDoCheck() {
        if (!this._displayDensity &&
            this.displayDensityOptions &&
            this.oldDisplayDensityOptions.displayDensity !==
                this.displayDensityOptions.displayDensity) {
            const densityChangedArgs = {
                oldDensity: this.oldDisplayDensityOptions.displayDensity,
                newDensity: this.displayDensityOptions.displayDensity,
            };
            this.densityChanged.emit(densityChangedArgs);
            this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
        }
    }
    /**
     * Given a style class of a component/element returns the modified version of it based
     * on the current display density.
     */
    getComponentDensityClass(baseStyleClass) {
        switch (this._displayDensity || this.oldDisplayDensityOptions.displayDensity) {
            case DisplayDensity.cosy:
                return `${baseStyleClass}--${DisplayDensity.cosy}`;
            case DisplayDensity.compact:
                return `${baseStyleClass}--${DisplayDensity.compact}`;
            default:
                return baseStyleClass;
        }
    }
    /**
     * Sets the `--component-size` CSS variable based on the value of Display Density
     */
    getComponentSizeStyles() {
        switch (this._displayDensity || this.oldDisplayDensityOptions.displayDensity) {
            case DisplayDensity.compact:
                return 'var(--ig-size, var(--ig-size-small))';
            case DisplayDensity.cosy:
                return 'var(--ig-size, var(--ig-size-medium))';
            case DisplayDensity.comfortable:
            default:
                return 'var(--ig-size, var(--ig-size-large))';
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: DisplayDensityBase, deps: [{ token: DisplayDensityToken, optional: true }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.4", type: DisplayDensityBase, isStandalone: true, selector: "[igxDisplayDensityBase]", inputs: { displayDensity: "displayDensity" }, outputs: { densityChanged: "densityChanged" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: DisplayDensityBase, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxDisplayDensityBase]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DisplayDensityToken]
                }] }, { type: i0.ElementRef }], propDecorators: { densityChanged: [{
                type: Output
            }], displayDensity: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVuc2l0eS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9jb3JlL2RlbnNpdHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILGNBQWMsRUFDZCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFHWixTQUFTLEVBQ1QsUUFBUSxFQUNSLE1BQU0sR0FFVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQWtCLE1BQU0sRUFBRSxNQUFNLFNBQVMsQ0FBQzs7QUFFakQ7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDO0lBQ2pDLFdBQVcsRUFBRSxhQUFhO0lBQzFCLElBQUksRUFBRSxNQUFNO0lBQ1osT0FBTyxFQUFFLFNBQVM7Q0FDckIsQ0FBQyxDQUFDO0FBdUJIOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxjQUFjLENBQ2pELGdCQUFnQixDQUNuQixDQUFDO0FBRUY7OztHQUdHO0FBS0gsa0VBQWtFO0FBQ2xFLE1BQU0sT0FBTyxrQkFBa0I7SUFLM0I7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxJQUNXLGNBQWM7UUFDckIsT0FBTyxDQUNILElBQUksQ0FBQyxlQUFlO1lBQ3BCLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxjQUFjO1lBQzFDLGNBQWMsQ0FBQyxXQUFXLENBQzdCLENBQUM7SUFDTixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLGNBQWMsQ0FBQyxHQUFtQjtRQUN6QyxNQUFNLHFCQUFxQixHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDbkQsSUFBSSxDQUFDLGVBQWUsR0FBRyxHQUFxQixDQUFDO1FBRTdDLElBQUkscUJBQXFCLEtBQUssSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUNoRCxNQUFNLGtCQUFrQixHQUE2QjtnQkFDakQsVUFBVSxFQUFFLHFC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YyxDQUFDLElBQUk7Z0JBQ3BCLE9BQU8sdUNBQXVDLENBQUM7WUFDbkQsS0FBSyxjQUFjLENBQUMsV0FBVyxDQUFDO1lBQ2hDO2dCQUNJLE9BQU8sc0NBQXNDLENBQUM7U0FDckQ7SUFDTCxDQUFDOzhHQTVJUSxrQkFBa0Isa0JBd0RmLG1CQUFtQjtrR0F4RHRCLGtCQUFrQjs7MkZBQWxCLGtCQUFrQjtrQkFMOUIsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUseUJBQXlCO29CQUNuQyxVQUFVLEVBQUUsSUFBSTtpQkFDbkI7OzBCQXlEUSxRQUFROzswQkFDUixNQUFNOzJCQUFDLG1CQUFtQjtrRUFyRHhCLGNBQWM7c0JBRHBCLE1BQU07Z0JBZ0JJLGNBQWM7c0JBRHhCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEluamVjdGlvblRva2VuLFxuICAgIElucHV0LFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgRG9DaGVjayxcbiAgICBPbkluaXQsXG4gICAgRGlyZWN0aXZlLFxuICAgIE9wdGlvbmFsLFxuICAgIEluamVjdCxcbiAgICBFbGVtZW50UmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElCYXNlRXZlbnRBcmdzLCBta2VudW0gfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBwb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGNvbXBvbmVudHMnIGRpc3BsYXkgZGVuc2l0eS5cbiAqL1xuZXhwb3J0IGNvbnN0IERpc3BsYXlEZW5zaXR5ID0gbWtlbnVtKHtcbiAgICBjb21mb3J0YWJsZTogJ2NvbWZvcnRhYmxlJyxcbiAgICBjb3N5OiAnY29zeScsXG4gICAgY29tcGFjdDogJ2NvbXBhY3QnLFxufSk7XG4vKipcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMTYuMS4wLlxuICogUGxlYXNlIHVzZSB0aGUgYC0taWctc2l6ZWAgQ1NTIGN1c3RvbSBwcm9wZXJ0eS5cbiAqIEBzZWUge0BsaW5rIFtVcGRhdGUgR3VpZGVdKGh0dHBzOi8vd3d3LmluZnJhZ2lzdGljcy5jb20vcHJvZHVjdHMvaWduaXRlLXVpLWFuZ3VsYXIvYW5ndWxhci9jb21wb25lbnRzL2dlbmVyYWwvdXBkYXRlLWd1aWRlI2Zyb20tMTYweC10by0xNjF4KX1cbiAqL1xuZXhwb3J0IHR5cGUgRGlzcGxheURlbnNpdHkgPVxuICAgICh0eXBlb2YgRGlzcGxheURlbnNpdHkpW2tleW9mIHR5cGVvZiBEaXNwbGF5RGVuc2l0eV07XG5cbi8qKlxuICogRGVzY3JpYmVzIHRoZSBvYmplY3QgdXNlZCB0byBjb25maWd1cmUgdGhlIERpc3BsYXlEZW5zaXR5IGluIEFuZ3VsYXIgREkuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxNi4xLjAuIFBsZWFzZSB1c2UgdGhlIGAtLWlnLXNpemVgIENTUyBjdXN0b20gcHJvcGVydHkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSURpc3BsYXlEZW5zaXR5T3B0aW9ucyB7XG4gICAgZGlzcGxheURlbnNpdHk6IERpc3BsYXlEZW5zaXR5O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEZW5zaXR5Q2hhbmdlZEV2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICBvbGREZW5zaXR5OiBEaXNwbGF5RGVuc2l0eTtcbiAgICBuZXdEZW5zaXR5OiBEaXNwbGF5RGVuc2l0eTtcbn1cblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBEaXNwbGF5RGVuc2l0eSBESSB0b2tlbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDE2LjEuMC5cbiAqIFBsZWFzZSB1c2UgdGhlIGAtLWlnLXNpemVgIENTUyBjdXN0b20gcHJvcGVydHkuXG4gKiBAc2VlIHtAbGluayBbVXBkYXRlIEd1aWRlXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9nZW5lcmFsL3VwZGF0ZS1ndWlkZSNmcm9tLTE2MHgtdG8tMTYxeCl9XG4gKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgRGlzcGxheURlbnNpdHlUb2tlbiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxJRGlzcGxheURlbnNpdHlPcHRpb25zPihcbiAgICAnRGlzcGxheURlbnNpdHknXG4pO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEJhc2UgY2xhc3MgY29udGFpbmluZyBhbGwgbG9naWMgcmVxdWlyZWQgZm9yIGltcGxlbWVudGluZyBEaXNwbGF5RGVuc2l0eS5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4RGlzcGxheURlbnNpdHlCYXNlXScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbn0pXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L2RpcmVjdGl2ZS1jbGFzcy1zdWZmaXhcbmV4cG9ydCBjbGFzcyBEaXNwbGF5RGVuc2l0eUJhc2UgaW1wbGVtZW50cyBEb0NoZWNrLCBPbkluaXQge1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRlbnNpdHlDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxJRGVuc2l0eUNoYW5nZWRFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0aGVtZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIFRoZSBkZWZhdWx0IHRoZW1lIGlzIGBjb21mb3J0YWJsZWAuXG4gICAgICogQXZhaWxhYmxlIG9wdGlvbnMgYXJlIGBjb21mb3J0YWJsZWAsIGBjb3N5YCwgYGNvbXBhY3RgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29tcG9uZW50VGhlbWUgPSB0aGlzLmNvbXBvbmVudC5kaXNwbGF5RGVuc2l0eTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMTYuMS4wLlxuICAgICAqIFBsZWFzZSB1c2UgdGhlIGAtLWlnLXNpemVgIENTUyBjdXN0b20gcHJvcGVydHkuXG4gICAgICogQHNlZSB7QGxpbmsgW1VwZGF0ZSBHdWlkZV0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvZ2VuZXJhbC91cGRhdGUtZ3VpZGUjZnJvbS0xNjB4LXRvLTE2MXgpfVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBkaXNwbGF5RGVuc2l0eSgpOiBEaXNwbGF5RGVuc2l0eSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5RGVuc2l0eSA/P1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5RGVuc2l0eU9wdGlvbnM/LmRpc3BsYXlEZW5zaXR5ID8/XG4gICAgICAgICAgICBEaXNwbGF5RGVuc2l0eS5jb21mb3J0YWJsZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRoZW1lIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHVibGljIHNldCBkaXNwbGF5RGVuc2l0eSh2YWw6IERpc3BsYXlEZW5zaXR5KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREaXNwbGF5RGVuc2l0eSA9IHRoaXMuX2Rpc3BsYXlEZW5zaXR5O1xuICAgICAgICB0aGlzLl9kaXNwbGF5RGVuc2l0eSA9IHZhbCBhcyBEaXNwbGF5RGVuc2l0eTtcblxuICAgICAgICBpZiAoY3VycmVudERpc3BsYXlEZW5zaXR5ICE9PSB0aGlzLl9kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY29uc3QgZGVuc2l0eUNoYW5nZWRBcmdzOiBJRGVuc2l0eUNoYW5nZWRFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgb2xkRGVuc2l0eTogY3VycmVudERpc3BsYXlEZW5zaXR5LFxuICAgICAgICAgICAgICAgIG5ld0RlbnNpdHk6IHRoaXMuX2Rpc3BsYXlEZW5zaXR5LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5kZW5zaXR5Q2hhbmdlZC5lbWl0KGRlbnNpdHlDaGFuZ2VkQXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGluaXRpYWxEZW5zaXR5OiBEaXNwbGF5RGVuc2l0eTtcblxuICAgIHByb3RlY3RlZCBvbGREaXNwbGF5RGVuc2l0eU9wdGlvbnM6IElEaXNwbGF5RGVuc2l0eU9wdGlvbnMgPSB7XG4gICAgICAgIGRpc3BsYXlEZW5zaXR5OiBEaXNwbGF5RGVuc2l0eS5jb21mb3J0YWJsZSxcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2Rpc3BsYXlEZW5zaXR5OiBEaXNwbGF5RGVuc2l0eTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBAT3B0aW9uYWwoKVxuICAgICAgICBASW5qZWN0KERpc3BsYXlEZW5zaXR5VG9rZW4pXG4gICAgICAgIHByb3RlY3RlZCBkaXNwbGF5RGVuc2l0eU9wdGlvbnM6IElEaXNwbGF5RGVuc2l0eU9wdGlvbnMsXG4gICAgICAgIHByb3RlY3RlZCBfaG9zdDogRWxlbWVudFJlZlxuICAgICkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMub2xkRGlzcGxheURlbnNpdHlPcHRpb25zLCBkaXNwbGF5RGVuc2l0eU9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5faG9zdD8ubmF0aXZlRWxlbWVudDtcblxuICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2xvYmFsVGhpcy5kb2N1bWVudD8uZGVmYXVsdFZpZXdcbiAgICAgICAgICAgICAgICAuZ2V0Q29tcHV0ZWRTdHlsZShlbClcbiAgICAgICAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZShcIi0taWctc2l6ZVwiKVxuICAgICAgICAgICAgICAgIC50cmltKCk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5RGVuc2l0eSA9IERpc3BsYXlEZW5zaXR5LmNvbXBhY3Q7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzInOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5RGVuc2l0eSA9IERpc3BsYXlEZW5zaXR5LmNvc3k7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5RGVuc2l0eSA9IERpc3BsYXlEZW5zaXR5LmNvbWZvcnRhYmxlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdGlhbERlbnNpdHkgPSB0aGlzLl9kaXNwbGF5RGVuc2l0eTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKiovXG4gICAgcHVibGljIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRoaXMuX2Rpc3BsYXlEZW5zaXR5ICYmXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlEZW5zaXR5T3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5vbGREaXNwbGF5RGVuc2l0eU9wdGlvbnMuZGlzcGxheURlbnNpdHkgIT09XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5RGVuc2l0eU9wdGlvbnMuZGlzcGxheURlbnNpdHlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBkZW5zaXR5Q2hhbmdlZEFyZ3M6IElEZW5zaXR5Q2hhbmdlZEV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBvbGREZW5zaXR5OiB0aGlzLm9sZERpc3BsYXlEZW5zaXR5T3B0aW9ucy5kaXNwbGF5RGVuc2l0eSxcbiAgICAgICAgICAgICAgICBuZXdEZW5zaXR5OiB0aGlzLmRpc3BsYXlEZW5zaXR5T3B0aW9ucy5kaXNwbGF5RGVuc2l0eSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuZGVuc2l0eUNoYW5nZWQuZW1pdChkZW5zaXR5Q2hhbmdlZEFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5vbGREaXNwbGF5RGVuc2l0eU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgIHRoaXMub2xkRGlzcGxheURlbnNpdHlPcHRpb25zLFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheURlbnNpdHlPcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzdHlsZSBjbGFzcyBvZiBhIGNvbXBvbmVudC9lbGVtZW50IHJldHVybnMgdGhlIG1vZGlmaWVkIHZlcnNpb24gb2YgaXQgYmFzZWRcbiAgICAgKiBvbiB0aGUgY3VycmVudCBkaXNwbGF5IGRlbnNpdHkuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldENvbXBvbmVudERlbnNpdHlDbGFzcyhiYXNlU3R5bGVDbGFzczogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9kaXNwbGF5RGVuc2l0eSB8fCB0aGlzLm9sZERpc3BsYXlEZW5zaXR5T3B0aW9ucy5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb3N5OlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtiYXNlU3R5bGVDbGFzc30tLSR7RGlzcGxheURlbnNpdHkuY29zeX1gO1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtiYXNlU3R5bGVDbGFzc30tLSR7RGlzcGxheURlbnNpdHkuY29tcGFjdH1gO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVN0eWxlQ2xhc3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgLS1jb21wb25lbnQtc2l6ZWAgQ1NTIHZhcmlhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiBEaXNwbGF5IERlbnNpdHlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50U2l6ZVN0eWxlcygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9kaXNwbGF5RGVuc2l0eSB8fCB0aGlzLm9sZERpc3BsYXlEZW5zaXR5T3B0aW9ucy5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAndmFyKC0taWctc2l6ZSwgdmFyKC0taWctc2l6ZS1zbWFsbCkpJztcbiAgICAgICAgICAgIGNhc2UgRGlzcGxheURlbnNpdHkuY29zeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZhcigtLWlnLXNpemUsIHZhcigtLWlnLXNpemUtbWVkaXVtKSknO1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21mb3J0YWJsZTpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd2YXIoLS1pZy1zaXplLCB2YXIoLS1pZy1zaXplLWxhcmdlKSknO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19