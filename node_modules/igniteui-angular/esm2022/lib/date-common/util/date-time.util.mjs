import { DatePart } from '../../directives/date-time-editor/date-time-editor.common';
import { formatDate, FormatWidth, getLocaleDateFormat } from '@angular/common';
import { isDate } from '../../core/utils';
const DATE_CHARS = ['h', 'H', 'm', 's', 'S', 't', 'T'];
const TIME_CHARS = ['d', 'D', 'M', 'y', 'Y'];
/** @hidden */
export class DateTimeUtil {
    static { this.DEFAULT_INPUT_FORMAT = 'MM/dd/yyyy'; }
    static { this.DEFAULT_TIME_INPUT_FORMAT = 'hh:mm tt'; }
    static { this.SEPARATOR = 'literal'; }
    static { this.DEFAULT_LOCALE = 'en'; }
    /**
     * Parse a Date value from masked string input based on determined date parts
     *
     * @param inputData masked value to parse
     * @param dateTimeParts Date parts array for the mask
     */
    static parseValueFromMask(inputData, dateTimeParts, promptChar) {
        const parts = {};
        dateTimeParts.forEach(dp => {
            let value = parseInt(DateTimeUtil.getCleanVal(inputData, dp, promptChar), 10);
            if (!value) {
                value = dp.type === DatePart.Date || dp.type === DatePart.Month ? 1 : 0;
            }
            parts[dp.type] = value;
        });
        parts[DatePart.Month] -= 1;
        if (parts[DatePart.Month] < 0 || 11 < parts[DatePart.Month]) {
            return null;
        }
        // TODO: Century threshold
        if (parts[DatePart.Year] < 50) {
            parts[DatePart.Year] += 2000;
        }
        if (parts[DatePart.Date] > DateTimeUtil.daysInMonth(parts[DatePart.Year], parts[DatePart.Month])) {
            return null;
        }
        if (parts[DatePart.Hours] > 23 || parts[DatePart.Minutes] > 59 || parts[DatePart.Seconds] > 59) {
            return null;
        }
        const amPm = dateTimeParts.find(p => p.type === DatePart.AmPm);
        if (amPm) {
            parts[DatePart.Hours] %= 12;
        }
        if (amPm && DateTimeUtil.getCleanVal(inputData, amPm, promptChar).toLowerCase() === 'pm') {
            parts[DatePart.Hours] += 12;
        }
        return new Date(parts[DatePart.Year] || 2000, parts[DatePart.Month] || 0, parts[DatePart.Date] || 1, parts[DatePart.Hours] || 0, parts[DatePart.Minutes] || 0, parts[DatePart.Seconds] || 0);
    }
    /** Parse the mask into date/time and literal parts */
    static parseDateTimeFormat(mask, locale) {
        const format = mask || DateTimeUtil.getDefaultInputFormat(locale);
        const dateTimeParts = [];
        const formatArray = Array.from(format);
        let currentPart = null;
        let position = 0;
        for (let i = 0; i < formatArray.length; i++, position++) {
            const type = DateTimeUtil.determineDatePart(formatArray[i]);
            if (currentPart) {
                if (currentPart.type === type) {
                    currentPart.format += formatArray[i];
                    if (i < formatArray.length - 1) {
                        continue;
                    }
                }
                DateTimeUtil.addCurrentPart(currentPart, dateTimeParts);
                position = currentPart.end;
            }
            currentPart = {
                start: position,
                end: position + formatArray[i].length,
                type,
                format: formatArray[i]
            };
        }
        // make sure the last member of a format like H:m:s is not omitted
        if (!dateTimeParts.filter(p => p.format.includes(currentPart.format)).length) {
            DateTimeUtil.addCurrentPart(currentPart, dateTimeParts);
        }
        // formats like "y" or "yyy" are treated like "yyyy" while editing
        const yearPart = dateTimeParts.filter(p => p.type === DatePart.Year)[0];
        if (yearPart && yearPart.format !== 'yy') {
            yearPart.end += 4 - yearPart.format.length;
            yearPart.format = 'yyyy';
        }
        return dateTimeParts;
    }
    static getPartValue(value, datePartInfo, partLength) {
        let maskedValue;
        const datePart = datePartInfo.type;
        switch (datePart) {
            case DatePart.Date:
                maskedValue = value.getDate();
                break;
            case DatePart.Month:
                // months are zero based
                maskedValue = value.getMonth() + 1;
                break;
            case DatePart.Year:
                if (partLength === 2) {
                    maskedValue = this.prependValue(parseInt(value.getFullYear().toString().slice(-2), 10), partLength, '0');
                }
                else {
                    maskedValue = value.getFullYear();
                }
                break;
            case DatePart.Hours:
                if (datePartInfo.format.indexOf('h') !== -1) {
                    maskedValue = this.prependValue(this.toTwelveHourFormat(value.getHours().toString()), partLength, '0');
                }
                else {
                    maskedValue = value.getHours();
                }
                break;
            case DatePart.Minutes:
                maskedValue = value.getMinutes();
                break;
            case DatePart.Seconds:
                maskedValue = value.getSeconds();
                break;
            case DatePart.AmPm:
                maskedValue = value.getHours() >= 12 ? 'PM' : 'AM';
                break;
        }
        if (datePartInfo.type !== DatePart.AmPm) {
            return this.prependValue(maskedValue, partLength, '0');
        }
        return maskedValue;
    }
    /** Builds a date-time editor's default input format based on provided locale settings. */
    static getDefaultInputFormat(locale) {
        locale = locale || DateTimeUtil.DEFAULT_LOCALE;
        if (!Intl || !Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.formatToParts) {
            // TODO: fallback with Intl.format for IE?
            return DateTimeUtil.DEFAULT_INPUT_FORMAT;
        }
        const parts = DateTimeUtil.getDefaultLocaleMask(locale);
        parts.forEach(p => {
            if (p.type !== DatePart.Year && p.type !== DateTimeUtil.SEPARATOR) {
                p.formatType = "2-digit" /* FormatDesc.TwoDigits */;
            }
        });
        return DateTimeUtil.getMask(parts);
    }
    /** Tries to format a date using Angular's DatePipe. Fallbacks to `Intl` if no locale settings have been loaded. */
    static formatDate(value, format, locale, timezone) {
        let formattedDate;
        try {
            formattedDate = formatDate(value, format, locale, timezone);
        }
        catch {
            DateTimeUtil.logMissingLocaleSettings(locale);
            const formatter = new Intl.DateTimeFormat(locale);
            formattedDate = formatter.format(value);
        }
        return formattedDate;
    }
    /**
     * Returns the date format based on a provided locale.
     * Supports Angular's DatePipe format options such as `shortDate`, `longDate`.
     */
    static getLocaleDateFormat(locale, displayFormat) {
        const formatKeys = Object.keys(FormatWidth);
        const targetKey = formatKeys.find(k => k.toLowerCase() === displayFormat?.toLowerCase().replace('date', ''));
        if (!targetKey) {
            // if displayFormat is not shortDate, longDate, etc.
            // or if it is not set by the user
            return displayFormat;
        }
        let format;
        try {
            format = getLocaleDateFormat(locale, FormatWidth[targetKey]);
        }
        catch {
            DateTimeUtil.logMissingLocaleSettings(locale);
            format = DateTimeUtil.getDefaultInputFormat(locale);
        }
        return format;
    }
    /** Determines if a given character is `d/M/y` or `h/m/s`. */
    static isDateOrTimeChar(char) {
        return DATE_CHARS.indexOf(char) !== -1 || TIME_CHARS.indexOf(char) !== -1;
    }
    /** Spins the date portion in a date-time editor. */
    static spinDate(delta, newDate, spinLoop) {
        const maxDate = DateTimeUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth());
        let date = newDate.getDate() + delta;
        if (date > maxDate) {
            date = spinLoop ? date % maxDate : maxDate;
        }
        else if (date < 1) {
            date = spinLoop ? maxDate + (date % maxDate) : 1;
        }
        newDate.setDate(date);
    }
    /** Spins the month portion in a date-time editor. */
    static spinMonth(delta, newDate, spinLoop) {
        const maxDate = DateTimeUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth() + delta);
        if (newDate.getDate() > maxDate) {
            newDate.setDate(maxDate);
        }
        const maxMonth = 11;
        const minMonth = 0;
        let month = newDate.getMonth() + delta;
        if (month > maxMonth) {
            month = spinLoop ? (month % maxMonth) - 1 : maxMonth;
        }
        else if (month < minMonth) {
            month = spinLoop ? maxMonth + (month % maxMonth) + 1 : minMonth;
        }
        newDate.setMonth(month);
    }
    /** Spins the year portion in a date-time editor. */
    static spinYear(delta, newDate) {
        const maxDate = DateTimeUtil.daysInMonth(newDate.getFullYear() + delta, newDate.getMonth());
        if (newDate.getDate() > maxDate) {
            // clip to max to avoid leap year change shifting the entire value
            newDate.setDate(maxDate);
        }
        newDate.setFullYear(newDate.getFullYear() + delta);
    }
    /** Spins the hours portion in a date-time editor. */
    static spinHours(delta, newDate, spinLoop) {
        const maxHour = 23;
        const minHour = 0;
        let hours = newDate.getHours() + delta;
        if (hours > maxHour) {
            hours = spinLoop ? hours % maxHour - 1 : maxHour;
        }
        else if (hours < minHour) {
            hours = spinLoop ? maxHour + (hours % maxHour) + 1 : minHour;
        }
        newDate.setHours(hours);
    }
    /** Spins the minutes portion in a date-time editor. */
    static spinMinutes(delta, newDate, spinLoop) {
        const maxMinutes = 59;
        const minMinutes = 0;
        let minutes = newDate.getMinutes() + delta;
        if (minutes > maxMinutes) {
            minutes = spinLoop ? minutes % maxMinutes - 1 : maxMinutes;
        }
        else if (minutes < minMinutes) {
            minutes = spinLoop ? maxMinutes + (minutes % maxMinutes) + 1 : minMinutes;
        }
        newDate.setMinutes(minutes);
    }
    /** Spins the seconds portion in a date-time editor. */
    static spinSeconds(delta, newDate, spinLoop) {
        const maxSeconds = 59;
        const minSeconds = 0;
        let seconds = newDate.getSeconds() + delta;
        if (seconds > maxSeconds) {
            seconds = spinLoop ? seconds % maxSeconds - 1 : maxSeconds;
        }
        else if (seconds < minSeconds) {
            seconds = spinLoop ? maxSeconds + (seconds % maxSeconds) + 1 : minSeconds;
        }
        newDate.setSeconds(seconds);
    }
    /** Spins the AM/PM portion in a date-time editor. */
    static spinAmPm(newDate, currentDate, amPmFromMask) {
        switch (amPmFromMask) {
            case 'AM':
                newDate = new Date(newDate.setHours(newDate.getHours() + 12));
                break;
            case 'PM':
                newDate = new Date(newDate.setHours(newDate.getHours() - 12));
                break;
        }
        if (newDate.getDate() !== currentDate.getDate()) {
            return currentDate;
        }
        return newDate;
    }
    /**
     * Determines whether the provided value is greater than the provided max value.
     *
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is greater than provided maxValue
     */
    static greaterThanMaxValue(value, maxValue, includeTime = true, includeDate = true) {
        if (includeTime && includeDate) {
            return value.getTime() > maxValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _maxValue = new Date(maxValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _maxValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _maxValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() > _maxValue.getTime();
    }
    /**
     * Determines whether the provided value is less than the provided min value.
     *
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is less than provided minValue
     */
    static lessThanMinValue(value, minValue, includeTime = true, includeDate = true) {
        if (includeTime && includeDate) {
            return value.getTime() < minValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _minValue = new Date(minValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _minValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _minValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() < _minValue.getTime();
    }
    /**
     * Validates a value within a given min and max value range.
     *
     * @param value The value to validate
     * @param minValue The lowest possible value that `value` can take
     * @param maxValue The largest possible value that `value` can take
     */
    static validateMinMax(value, minValue, maxValue, includeTime = true, includeDate = true) {
        if (!value) {
            return null;
        }
        const errors = {};
        const min = DateTimeUtil.isValidDate(minValue) ? minValue : DateTimeUtil.parseIsoDate(minValue);
        const max = DateTimeUtil.isValidDate(maxValue) ? maxValue : DateTimeUtil.parseIsoDate(maxValue);
        if (min && value && DateTimeUtil.lessThanMinValue(value, min, includeTime, includeDate)) {
            Object.assign(errors, { minValue: true });
        }
        if (max && value && DateTimeUtil.greaterThanMaxValue(value, max, includeTime, includeDate)) {
            Object.assign(errors, { maxValue: true });
        }
        return errors;
    }
    /** Parse an ISO string to a Date */
    static parseIsoDate(value) {
        let regex = /^\d{4}/g;
        const timeLiteral = 'T';
        if (regex.test(value)) {
            return new Date(value + `${value.indexOf(timeLiteral) === -1 ? 'T00:00:00' : ''}`);
        }
        regex = /^\d{2}/g;
        if (regex.test(value)) {
            const dateNow = new Date().toISOString();
            // eslint-disable-next-line prefer-const
            let [datePart, _timePart] = dateNow.split(timeLiteral);
            return new Date(`${datePart}T${value}`);
        }
        return null;
    }
    /**
     * Returns whether the input is valid date
     *
     * @param value input to check
     * @returns true if provided input is a valid date
     */
    static isValidDate(value) {
        if (isDate(value)) {
            return !isNaN(value.getTime());
        }
        return false;
    }
    static addCurrentPart(currentPart, dateTimeParts) {
        DateTimeUtil.ensureLeadingZero(currentPart);
        currentPart.end = currentPart.start + currentPart.format.length;
        dateTimeParts.push(currentPart);
    }
    static daysInMonth(fullYear, month) {
        return new Date(fullYear, month + 1, 0).getDate();
    }
    static trimEmptyPlaceholders(value, promptChar) {
        const result = value.replace(new RegExp(promptChar || '_', 'g'), '');
        return result;
    }
    static getMask(dateStruct) {
        const mask = [];
        for (const part of dateStruct) {
            switch (part.formatType) {
                case "numeric" /* FormatDesc.Numeric */: {
                    if (part.type === "day" /* DateParts.Day */) {
                        mask.push('d');
                    }
                    else if (part.type === "month" /* DateParts.Month */) {
                        mask.push('M');
                    }
                    else {
                        mask.push('yyyy');
                    }
                    break;
                }
                case "2-digit" /* FormatDesc.TwoDigits */: {
                    if (part.type === "day" /* DateParts.Day */) {
                        mask.push('dd');
                    }
                    else if (part.type === "month" /* DateParts.Month */) {
                        mask.push('MM');
                    }
                    else {
                        mask.push('yy');
                    }
                }
            }
            if (part.type === DateTimeUtil.SEPARATOR) {
                mask.push(part.value);
            }
        }
        return mask.join('');
    }
    static logMissingLocaleSettings(locale) {
        console.warn(`Missing locale data for the locale ${locale}. Please refer to https://angular.io/guide/i18n#i18n-pipes`);
        console.warn('Using default browser locale settings.');
    }
    static prependValue(value, partLength, prependChar) {
        return (prependChar + value.toString()).slice(-partLength);
    }
    static toTwelveHourFormat(value, promptChar = '_') {
        let hour = parseInt(value.replace(new RegExp(promptChar, 'g'), '0'), 10);
        if (hour > 12) {
            hour -= 12;
        }
        else if (hour === 0) {
            hour = 12;
        }
        return hour;
    }
    static ensureLeadingZero(part) {
        switch (part.type) {
            case DatePart.Date:
            case DatePart.Month:
            case DatePart.Hours:
            case DatePart.Minutes:
            case DatePart.Seconds:
                if (part.format.length === 1) {
                    part.format = part.format.repeat(2);
                }
                break;
        }
    }
    static getCleanVal(inputData, datePart, promptChar) {
        return DateTimeUtil.trimEmptyPlaceholders(inputData.substring(datePart.start, datePart.end), promptChar);
    }
    static determineDatePart(char) {
        switch (char) {
            case 'd':
            case 'D':
                return DatePart.Date;
            case 'M':
                return DatePart.Month;
            case 'y':
            case 'Y':
                return DatePart.Year;
            case 'h':
            case 'H':
                return DatePart.Hours;
            case 'm':
                return DatePart.Minutes;
            case 's':
            case 'S':
                return DatePart.Seconds;
            case 't':
            case 'T':
                return DatePart.AmPm;
            default:
                return DatePart.Literal;
        }
    }
    static getDefaultLocaleMask(locale) {
        const dateStruct = [];
        const formatter = new Intl.DateTimeFormat(locale);
        const formatToParts = formatter.formatToParts(new Date());
        for (const part of formatToParts) {
            if (part.type === DateTimeUtil.SEPARATOR) {
                dateStruct.push({
                    type: DateTimeUtil.SEPARATOR,
                    value: part.value
                });
            }
            else {
                dateStruct.push({
                    type: part.type
                });
            }
        }
        const formatterOptions = formatter.resolvedOptions();
        for (const part of dateStruct) {
            switch (part.type) {
                case "day" /* DateParts.Day */: {
                    part.formatType = formatterOptions.day;
                    break;
                }
                case "month" /* DateParts.Month */: {
                    part.formatType = formatterOptions.month;
                    break;
                }
                case "year" /* DateParts.Year */: {
                    part.formatType = formatterOptions.year;
                    break;
                }
            }
        }
        DateTimeUtil.fillDatePartsPositions(dateStruct);
        return dateStruct;
    }
    static fillDatePartsPositions(dateArray) {
        let currentPos = 0;
        for (const part of dateArray) {
            // Day|Month part positions
            if (part.type === "day" /* DateParts.Day */ || part.type === "month" /* DateParts.Month */) {
                // Offset 2 positions for number
                part.position = [currentPos, currentPos + 2];
                currentPos += 2;
            }
            else if (part.type === "year" /* DateParts.Year */) {
                // Year part positions
                switch (part.formatType) {
                    case "numeric" /* FormatDesc.Numeric */: {
                        // Offset 4 positions for full year
                        part.position = [currentPos, currentPos + 4];
                        currentPos += 4;
                        break;
                    }
                    case "2-digit" /* FormatDesc.TwoDigits */: {
                        // Offset 2 positions for short year
                        part.position = [currentPos, currentPos + 2];
                        currentPos += 2;
                        break;
                    }
                }
            }
            else if (part.type === DateTimeUtil.SEPARATOR) {
                // Separator positions
                part.position = [currentPos, currentPos + 1];
                currentPos++;
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLnV0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGF0ZS1jb21tb24vdXRpbC9kYXRlLXRpbWUudXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFnQixNQUFNLDJEQUEyRCxDQUFDO0FBQ25HLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLG1CQUFtQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFL0UsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBUTFDLE1BQU0sVUFBVSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDdkQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFTN0MsY0FBYztBQUNkLE1BQU0sT0FBZ0IsWUFBWTthQUNQLHlCQUFvQixHQUFHLFlBQVksQ0FBQzthQUNwQyw4QkFBeUIsR0FBRyxVQUFVLENBQUM7YUFDdEMsY0FBUyxHQUFHLFNBQVMsQ0FBQzthQUN0QixtQkFBYyxHQUFHLElBQUksQ0FBQztJQUU5Qzs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxTQUFpQixFQUFFLGFBQTZCLEVBQUUsVUFBbUI7UUFDbEcsTUFBTSxLQUFLLEdBQWtDLEVBQVMsQ0FBQztRQUN2RCxhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ3ZCLElBQUksS0FBSyxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxFQUFFLEVBQUUsVUFBVSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFD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LENBQUMsVUFBVSxFQUFFLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQzt3QkFDN0MsVUFBVSxJQUFJLENBQUMsQ0FBQzt3QkFDaEIsTUFBTTtxQkFDVDtpQkFDSjthQUNKO2lCQUFNLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxZQUFZLENBQUMsU0FBUyxFQUFFO2dCQUM3QyxzQkFBc0I7Z0JBQ3RCLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxVQUFVLEVBQUUsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUM3QyxVQUFVLEVBQUUsQ0FBQzthQUNoQjtTQUNKO0lBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGVQYXJ0LCBEYXRlUGFydEluZm8gfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RhdGUtdGltZS1lZGl0b3IvZGF0ZS10aW1lLWVkaXRvci5jb21tb24nO1xuaW1wb3J0IHsgZm9ybWF0RGF0ZSwgRm9ybWF0V2lkdGgsIGdldExvY2FsZURhdGVGb3JtYXQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGlzRGF0ZSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgZW51bSBGb3JtYXREZXNjIHtcbiAgICBOdW1lcmljID0gJ251bWVyaWMnLFxuICAgIFR3b0RpZ2l0cyA9ICcyLWRpZ2l0J1xufVxuXG5jb25zdCBEQVRFX0NIQVJTID0gWydoJywgJ0gnLCAnbScsICdzJywgJ1MnLCAndCcsICdUJ107XG5jb25zdCBUSU1FX0NIQVJTID0gWydkJywgJ0QnLCAnTScsICd5JywgJ1knXTtcblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGVudW0gRGF0ZVBhcnRzIHtcbiAgICBEYXkgPSAnZGF5JyxcbiAgICBNb250aCA9ICdtb250aCcsXG4gICAgWWVhciA9ICd5ZWFyJ1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGVUaW1lVXRpbCB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0lOUFVUX0ZPUk1BVCA9ICdNTS9kZC95eXl5JztcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfVElNRV9JTlBVVF9GT1JNQVQgPSAnaGg6bW0gdHQnO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNFUEFSQVRPUiA9ICdsaXRlcmFsJztcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0xPQ0FMRSA9ICdlbic7XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIERhdGUgdmFsdWUgZnJvbSBtYXNrZWQgc3RyaW5nIGlucHV0IGJhc2VkIG9uIGRldGVybWluZWQgZGF0ZSBwYXJ0c1xuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0RGF0YSBtYXNrZWQgdmFsdWUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0gZGF0ZVRpbWVQYXJ0cyBEYXRlIHBhcnRzIGFycmF5IGZvciB0aGUgbWFza1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VWYWx1ZUZyb21NYXNrKGlucHV0RGF0YTogc3RyaW5nLCBkYXRlVGltZVBhcnRzOiBEYXRlUGFydEluZm9bXSwgcHJvbXB0Q2hhcj86IHN0cmluZyk6IERhdGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcGFydHM6IHsgW2tleSBpbiBEYXRlUGFydF06IG51bWJlciB9ID0ge30gYXMgYW55O1xuICAgICAgICBkYXRlVGltZVBhcnRzLmZvckVhY2goZHAgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VJbnQoRGF0ZVRpbWVVdGlsLmdldENsZWFuVmFsKGlucHV0RGF0YSwgZHAsIHByb21wdENoYXIpLCAxMCk7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkcC50eXBlID09PSBEYXRlUGFydC5EYXRlIHx8IGRwLnR5cGUgPT09IERhdGVQYXJ0Lk1vbnRoID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0c1tkcC50eXBlXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFydHNbRGF0ZVBhcnQuTW9udGhdIC09IDE7XG5cbiAgICAgICAgaWYgKHBhcnRzW0RhdGVQYXJ0Lk1vbnRoXSA8IDAgfHwgMTEgPCBwYXJ0c1tEYXRlUGFydC5Nb250aF0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogQ2VudHVyeSB0aHJlc2hvbGRcbiAgICAgICAgaWYgKHBhcnRzW0RhdGVQYXJ0LlllYXJdIDwgNTApIHtcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0LlllYXJdICs9IDIwMDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydHNbRGF0ZVBhcnQuRGF0ZV0gPiBEYXRlVGltZVV0aWwuZGF5c0luTW9udGgocGFydHNbRGF0ZVBhcnQuWWVhcl0sIHBhcnRzW0RhdGVQYXJ0Lk1vbnRoXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzW0RhdGVQYXJ0LkhvdXJzXSA+IDIzIHx8IHBhcnRzW0RhdGVQYXJ0Lk1pbnV0ZXNdID4gNTkgfHwgcGFydHNbRGF0ZVBhcnQuU2Vjb25kc10gPiA1OSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbVBtID0gZGF0ZVRpbWVQYXJ0cy5maW5kKHAgPT4gcC50eXBlID09PSBEYXRlUGFydC5BbVBtKTtcbiAgICAgICAgaWYgKGFtUG0pIHtcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0LkhvdXJzXSAlPSAxMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbVBtICYmIERhdGVUaW1lVXRpbC5nZXRDbGVhblZhbChpbnB1dERhdGEsIGFtUG0sIHByb21wdENoYXIpLnRvTG93ZXJDYXNlKCkgPT09ICdwbScpIHtcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0LkhvdXJzXSArPSAxMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0LlllYXJdIHx8IDIwMDAsXG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5Nb250aF0gfHwgMCxcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0LkRhdGVdIHx8IDEsXG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5Ib3Vyc10gfHwgMCxcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0Lk1pbnV0ZXNdIHx8IDAsXG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5TZWNvbmRzXSB8fCAwXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqIFBhcnNlIHRoZSBtYXNrIGludG8gZGF0ZS90aW1lIGFuZCBsaXRlcmFsIHBhcnRzICovXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZURhdGVUaW1lRm9ybWF0KG1hc2s6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKTogRGF0ZVBhcnRJbmZvW10ge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBtYXNrIHx8IERhdGVUaW1lVXRpbC5nZXREZWZhdWx0SW5wdXRGb3JtYXQobG9jYWxlKTtcbiAgICAgICAgY29uc3QgZGF0ZVRpbWVQYXJ0czogRGF0ZVBhcnRJbmZvW10gPSBbXTtcbiAgICAgICAgY29uc3QgZm9ybWF0QXJyYXkgPSBBcnJheS5mcm9tKGZvcm1hdCk7XG4gICAgICAgIGxldCBjdXJyZW50UGFydDogRGF0ZVBhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdEFycmF5Lmxlbmd0aDsgaSsrLCBwb3NpdGlvbisrKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gRGF0ZVRpbWVVdGlsLmRldGVybWluZURhdGVQYXJ0KGZvcm1hdEFycmF5W2ldKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFydC50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJ0LmZvcm1hdCArPSBmb3JtYXRBcnJheVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBmb3JtYXRBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIERhdGVUaW1lVXRpbC5hZGRDdXJyZW50UGFydChjdXJyZW50UGFydCwgZGF0ZVRpbWVQYXJ0cyk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBjdXJyZW50UGFydC5lbmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRQYXJ0ID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBlbmQ6IHBvc2l0aW9uICsgZm9ybWF0QXJyYXlbaV0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXRBcnJheVtpXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgbGFzdCBtZW1iZXIgb2YgYSBmb3JtYXQgbGlrZSBIOm06cyBpcyBub3Qgb21pdHRlZFxuICAgICAgICBpZiAoIWRhdGVUaW1lUGFydHMuZmlsdGVyKHAgPT4gcC5mb3JtYXQuaW5jbHVkZXMoY3VycmVudFBhcnQuZm9ybWF0KSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBEYXRlVGltZVV0aWwuYWRkQ3VycmVudFBhcnQoY3VycmVudFBhcnQsIGRhdGVUaW1lUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvcm1hdHMgbGlrZSBcInlcIiBvciBcInl5eVwiIGFyZSB0cmVhdGVkIGxpa2UgXCJ5eXl5XCIgd2hpbGUgZWRpdGluZ1xuICAgICAgICBjb25zdCB5ZWFyUGFydCA9IGRhdGVUaW1lUGFydHMuZmlsdGVyKHAgPT4gcC50eXBlID09PSBEYXRlUGFydC5ZZWFyKVswXTtcbiAgICAgICAgaWYgKHllYXJQYXJ0ICYmIHllYXJQYXJ0LmZvcm1hdCAhPT0gJ3l5Jykge1xuICAgICAgICAgICAgeWVhclBhcnQuZW5kICs9IDQgLSB5ZWFyUGFydC5mb3JtYXQubGVuZ3RoO1xuICAgICAgICAgICAgeWVhclBhcnQuZm9ybWF0ID0gJ3l5eXknO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGVUaW1lUGFydHM7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRQYXJ0VmFsdWUodmFsdWU6IERhdGUsIGRhdGVQYXJ0SW5mbzogRGF0ZVBhcnRJbmZvLCBwYXJ0TGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBsZXQgbWFza2VkVmFsdWU7XG4gICAgICAgIGNvbnN0IGRhdGVQYXJ0ID0gZGF0ZVBhcnRJbmZvLnR5cGU7XG4gICAgICAgIHN3aXRjaCAoZGF0ZVBhcnQpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuRGF0ZTpcbiAgICAgICAgICAgICAgICBtYXNrZWRWYWx1ZSA9IHZhbHVlLmdldERhdGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuTW9udGg6XG4gICAgICAgICAgICAgICAgLy8gbW9udGhzIGFyZSB6ZXJvIGJhc2VkXG4gICAgICAgICAgICAgICAgbWFza2VkVmFsdWUgPSB2YWx1ZS5nZXRNb250aCgpICsgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuWWVhcjpcbiAgICAgICAgICAgICAgICBpZiAocGFydExlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBtYXNrZWRWYWx1ZSA9IHRoaXMucHJlcGVuZFZhbHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQodmFsdWUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpLnNsaWNlKC0yKSwgMTApLCBwYXJ0TGVuZ3RoLCAnMCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc2tlZFZhbHVlID0gdmFsdWUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0LkhvdXJzOlxuICAgICAgICAgICAgICAgIGlmIChkYXRlUGFydEluZm8uZm9ybWF0LmluZGV4T2YoJ2gnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFza2VkVmFsdWUgPSB0aGlzLnByZXBlbmRWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9Ud2VsdmVIb3VyRm9ybWF0KHZhbHVlLmdldEhvdXJzKCkudG9TdHJpbmcoKSksIHBhcnRMZW5ndGgsICcwJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFza2VkVmFsdWUgPSB2YWx1ZS5nZXRIb3VycygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuTWludXRlczpcbiAgICAgICAgICAgICAgICBtYXNrZWRWYWx1ZSA9IHZhbHVlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuU2Vjb25kczpcbiAgICAgICAgICAgICAgICBtYXNrZWRWYWx1ZSA9IHZhbHVlLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuQW1QbTpcbiAgICAgICAgICAgICAgICBtYXNrZWRWYWx1ZSA9IHZhbHVlLmdldEhvdXJzKCkgPj0gMTIgPyAnUE0nIDogJ0FNJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRlUGFydEluZm8udHlwZSAhPT0gRGF0ZVBhcnQuQW1QbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlcGVuZFZhbHVlKG1hc2tlZFZhbHVlLCBwYXJ0TGVuZ3RoLCAnMCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hc2tlZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKiBCdWlsZHMgYSBkYXRlLXRpbWUgZWRpdG9yJ3MgZGVmYXVsdCBpbnB1dCBmb3JtYXQgYmFzZWQgb24gcHJvdmlkZWQgbG9jYWxlIHNldHRpbmdzLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RGVmYXVsdElucHV0Rm9ybWF0KGxvY2FsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgbG9jYWxlID0gbG9jYWxlIHx8IERhdGVUaW1lVXRpbC5ERUZBVUxUX0xPQ0FMRTtcbiAgICAgICAgaWYgKCFJbnRsIHx8ICFJbnRsLkRhdGVUaW1lRm9ybWF0IHx8ICFJbnRsLkRhdGVUaW1lRm9ybWF0LnByb3RvdHlwZS5mb3JtYXRUb1BhcnRzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBmYWxsYmFjayB3aXRoIEludGwuZm9ybWF0IGZvciBJRT9cbiAgICAgICAgICAgIHJldHVybiBEYXRlVGltZVV0aWwuREVGQVVMVF9JTlBVVF9GT1JNQVQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydHMgPSBEYXRlVGltZVV0aWwuZ2V0RGVmYXVsdExvY2FsZU1hc2sobG9jYWxlKTtcbiAgICAgICAgcGFydHMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgIT09IERhdGVQYXJ0LlllYXIgJiYgcC50eXBlICE9PSBEYXRlVGltZVV0aWwuU0VQQVJBVE9SKSB7XG4gICAgICAgICAgICAgICAgcC5mb3JtYXRUeXBlID0gRm9ybWF0RGVzYy5Ud29EaWdpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBEYXRlVGltZVV0aWwuZ2V0TWFzayhwYXJ0cyk7XG4gICAgfVxuXG4gICAgLyoqIFRyaWVzIHRvIGZvcm1hdCBhIGRhdGUgdXNpbmcgQW5ndWxhcidzIERhdGVQaXBlLiBGYWxsYmFja3MgdG8gYEludGxgIGlmIG5vIGxvY2FsZSBzZXR0aW5ncyBoYXZlIGJlZW4gbG9hZGVkLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZm9ybWF0RGF0ZSh2YWx1ZTogbnVtYmVyIHwgRGF0ZSwgZm9ybWF0OiBzdHJpbmcsIGxvY2FsZTogc3RyaW5nLCB0aW1lem9uZT86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGxldCBmb3JtYXR0ZWREYXRlOiBzdHJpbmc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWREYXRlID0gZm9ybWF0RGF0ZSh2YWx1ZSwgZm9ybWF0LCBsb2NhbGUsIHRpbWV6b25lKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBEYXRlVGltZVV0aWwubG9nTWlzc2luZ0xvY2FsZVNldHRpbmdzKGxvY2FsZSk7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUpO1xuICAgICAgICAgICAgZm9ybWF0dGVkRGF0ZSA9IGZvcm1hdHRlci5mb3JtYXQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZERhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0ZSBmb3JtYXQgYmFzZWQgb24gYSBwcm92aWRlZCBsb2NhbGUuXG4gICAgICogU3VwcG9ydHMgQW5ndWxhcidzIERhdGVQaXBlIGZvcm1hdCBvcHRpb25zIHN1Y2ggYXMgYHNob3J0RGF0ZWAsIGBsb25nRGF0ZWAuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRMb2NhbGVEYXRlRm9ybWF0KGxvY2FsZTogc3RyaW5nLCBkaXNwbGF5Rm9ybWF0Pzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZm9ybWF0S2V5cyA9IE9iamVjdC5rZXlzKEZvcm1hdFdpZHRoKSBhcyAoa2V5b2YgRm9ybWF0V2lkdGgpW107XG4gICAgICAgIGNvbnN0IHRhcmdldEtleSA9IGZvcm1hdEtleXMuZmluZChrID0+IGsudG9Mb3dlckNhc2UoKSA9PT0gZGlzcGxheUZvcm1hdD8udG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdkYXRlJywgJycpKTtcbiAgICAgICAgaWYgKCF0YXJnZXRLZXkpIHtcbiAgICAgICAgICAgIC8vIGlmIGRpc3BsYXlGb3JtYXQgaXMgbm90IHNob3J0RGF0ZSwgbG9uZ0RhdGUsIGV0Yy5cbiAgICAgICAgICAgIC8vIG9yIGlmIGl0IGlzIG5vdCBzZXQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5Rm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb3JtYXQ6IHN0cmluZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGdldExvY2FsZURhdGVGb3JtYXQobG9jYWxlLCBGb3JtYXRXaWR0aFt0YXJnZXRLZXldKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBEYXRlVGltZVV0aWwubG9nTWlzc2luZ0xvY2FsZVNldHRpbmdzKGxvY2FsZSk7XG4gICAgICAgICAgICBmb3JtYXQgPSBEYXRlVGltZVV0aWwuZ2V0RGVmYXVsdElucHV0Rm9ybWF0KGxvY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIGBkL00veWAgb3IgYGgvbS9zYC4gKi9cbiAgICBwdWJsaWMgc3RhdGljIGlzRGF0ZU9yVGltZUNoYXIoY2hhcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBEQVRFX0NIQVJTLmluZGV4T2YoY2hhcikgIT09IC0xIHx8IFRJTUVfQ0hBUlMuaW5kZXhPZihjaGFyKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqIFNwaW5zIHRoZSBkYXRlIHBvcnRpb24gaW4gYSBkYXRlLXRpbWUgZWRpdG9yLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc3BpbkRhdGUoZGVsdGE6IG51bWJlciwgbmV3RGF0ZTogRGF0ZSwgc3Bpbkxvb3A6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4RGF0ZSA9IERhdGVUaW1lVXRpbC5kYXlzSW5Nb250aChuZXdEYXRlLmdldEZ1bGxZZWFyKCksIG5ld0RhdGUuZ2V0TW9udGgoKSk7XG4gICAgICAgIGxldCBkYXRlID0gbmV3RGF0ZS5nZXREYXRlKCkgKyBkZWx0YTtcbiAgICAgICAgaWYgKGRhdGUgPiBtYXhEYXRlKSB7XG4gICAgICAgICAgICBkYXRlID0gc3Bpbkxvb3AgPyBkYXRlICUgbWF4RGF0ZSA6IG1heERhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0ZSA8IDEpIHtcbiAgICAgICAgICAgIGRhdGUgPSBzcGluTG9vcCA/IG1heERhdGUgKyAoZGF0ZSAlIG1heERhdGUpIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RhdGUuc2V0RGF0ZShkYXRlKTtcbiAgICB9XG5cbiAgICAvKiogU3BpbnMgdGhlIG1vbnRoIHBvcnRpb24gaW4gYSBkYXRlLXRpbWUgZWRpdG9yLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc3Bpbk1vbnRoKGRlbHRhOiBudW1iZXIsIG5ld0RhdGU6IERhdGUsIHNwaW5Mb29wOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1heERhdGUgPSBEYXRlVGltZVV0aWwuZGF5c0luTW9udGgobmV3RGF0ZS5nZXRGdWxsWWVhcigpLCBuZXdEYXRlLmdldE1vbnRoKCkgKyBkZWx0YSk7XG4gICAgICAgIGlmIChuZXdEYXRlLmdldERhdGUoKSA+IG1heERhdGUpIHtcbiAgICAgICAgICAgIG5ld0RhdGUuc2V0RGF0ZShtYXhEYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heE1vbnRoID0gMTE7XG4gICAgICAgIGNvbnN0IG1pbk1vbnRoID0gMDtcbiAgICAgICAgbGV0IG1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpICsgZGVsdGE7XG4gICAgICAgIGlmIChtb250aCA+IG1heE1vbnRoKSB7XG4gICAgICAgICAgICBtb250aCA9IHNwaW5Mb29wID8gKG1vbnRoICUgbWF4TW9udGgpIC0gMSA6IG1heE1vbnRoO1xuICAgICAgICB9IGVsc2UgaWYgKG1vbnRoIDwgbWluTW9udGgpIHtcbiAgICAgICAgICAgIG1vbnRoID0gc3Bpbkxvb3AgPyBtYXhNb250aCArIChtb250aCAlIG1heE1vbnRoKSArIDEgOiBtaW5Nb250aDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RhdGUuc2V0TW9udGgobW9udGgpO1xuICAgIH1cblxuICAgIC8qKiBTcGlucyB0aGUgeWVhciBwb3J0aW9uIGluIGEgZGF0ZS10aW1lIGVkaXRvci4gKi9cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5ZZWFyKGRlbHRhOiBudW1iZXIsIG5ld0RhdGU6IERhdGUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4RGF0ZSA9IERhdGVUaW1lVXRpbC5kYXlzSW5Nb250aChuZXdEYXRlLmdldEZ1bGxZZWFyKCkgKyBkZWx0YSwgbmV3RGF0ZS5nZXRNb250aCgpKTtcbiAgICAgICAgaWYgKG5ld0RhdGUuZ2V0RGF0ZSgpID4gbWF4RGF0ZSkge1xuICAgICAgICAgICAgLy8gY2xpcCB0byBtYXggdG8gYXZvaWQgbGVhcCB5ZWFyIGNoYW5nZSBzaGlmdGluZyB0aGUgZW50aXJlIHZhbHVlXG4gICAgICAgICAgICBuZXdEYXRlLnNldERhdGUobWF4RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkgKyBkZWx0YSk7XG4gICAgfVxuXG4gICAgLyoqIFNwaW5zIHRoZSBob3VycyBwb3J0aW9uIGluIGEgZGF0ZS10aW1lIGVkaXRvci4gKi9cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5Ib3VycyhkZWx0YTogbnVtYmVyLCBuZXdEYXRlOiBEYXRlLCBzcGluTG9vcDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXhIb3VyID0gMjM7XG4gICAgICAgIGNvbnN0IG1pbkhvdXIgPSAwO1xuICAgICAgICBsZXQgaG91cnMgPSBuZXdEYXRlLmdldEhvdXJzKCkgKyBkZWx0YTtcbiAgICAgICAgaWYgKGhvdXJzID4gbWF4SG91cikge1xuICAgICAgICAgICAgaG91cnMgPSBzcGluTG9vcCA/IGhvdXJzICUgbWF4SG91ciAtIDEgOiBtYXhIb3VyO1xuICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgbWluSG91cikge1xuICAgICAgICAgICAgaG91cnMgPSBzcGluTG9vcCA/IG1heEhvdXIgKyAoaG91cnMgJSBtYXhIb3VyKSArIDEgOiBtaW5Ib3VyO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGF0ZS5zZXRIb3Vycyhob3Vycyk7XG4gICAgfVxuXG4gICAgLyoqIFNwaW5zIHRoZSBtaW51dGVzIHBvcnRpb24gaW4gYSBkYXRlLXRpbWUgZWRpdG9yLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc3Bpbk1pbnV0ZXMoZGVsdGE6IG51bWJlciwgbmV3RGF0ZTogRGF0ZSwgc3Bpbkxvb3A6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4TWludXRlcyA9IDU5O1xuICAgICAgICBjb25zdCBtaW5NaW51dGVzID0gMDtcbiAgICAgICAgbGV0IG1pbnV0ZXMgPSBuZXdEYXRlLmdldE1pbnV0ZXMoKSArIGRlbHRhO1xuICAgICAgICBpZiAobWludXRlcyA+IG1heE1pbnV0ZXMpIHtcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBzcGluTG9vcCA/IG1pbnV0ZXMgJSBtYXhNaW51dGVzIC0gMSA6IG1heE1pbnV0ZXM7XG4gICAgICAgIH0gZWxzZSBpZiAobWludXRlcyA8IG1pbk1pbnV0ZXMpIHtcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBzcGluTG9vcCA/IG1heE1pbnV0ZXMgKyAobWludXRlcyAlIG1heE1pbnV0ZXMpICsgMSA6IG1pbk1pbnV0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdEYXRlLnNldE1pbnV0ZXMobWludXRlcyk7XG4gICAgfVxuXG4gICAgLyoqIFNwaW5zIHRoZSBzZWNvbmRzIHBvcnRpb24gaW4gYSBkYXRlLXRpbWUgZWRpdG9yLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc3BpblNlY29uZHMoZGVsdGE6IG51bWJlciwgbmV3RGF0ZTogRGF0ZSwgc3Bpbkxvb3A6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4U2Vjb25kcyA9IDU5O1xuICAgICAgICBjb25zdCBtaW5TZWNvbmRzID0gMDtcbiAgICAgICAgbGV0IHNlY29uZHMgPSBuZXdEYXRlLmdldFNlY29uZHMoKSArIGRlbHRhO1xuICAgICAgICBpZiAoc2Vjb25kcyA+IG1heFNlY29uZHMpIHtcbiAgICAgICAgICAgIHNlY29uZHMgPSBzcGluTG9vcCA/IHNlY29uZHMgJSBtYXhTZWNvbmRzIC0gMSA6IG1heFNlY29uZHM7XG4gICAgICAgIH0gZWxzZSBpZiAoc2Vjb25kcyA8IG1pblNlY29uZHMpIHtcbiAgICAgICAgICAgIHNlY29uZHMgPSBzcGluTG9vcCA/IG1heFNlY29uZHMgKyAoc2Vjb25kcyAlIG1heFNlY29uZHMpICsgMSA6IG1pblNlY29uZHM7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdEYXRlLnNldFNlY29uZHMoc2Vjb25kcyk7XG4gICAgfVxuXG4gICAgLyoqIFNwaW5zIHRoZSBBTS9QTSBwb3J0aW9uIGluIGEgZGF0ZS10aW1lIGVkaXRvci4gKi9cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5BbVBtKG5ld0RhdGU6IERhdGUsIGN1cnJlbnREYXRlOiBEYXRlLCBhbVBtRnJvbU1hc2s6IHN0cmluZyk6IERhdGUge1xuICAgICAgICBzd2l0Y2ggKGFtUG1Gcm9tTWFzaykge1xuICAgICAgICAgICAgY2FzZSAnQU0nOlxuICAgICAgICAgICAgICAgIG5ld0RhdGUgPSBuZXcgRGF0ZShuZXdEYXRlLnNldEhvdXJzKG5ld0RhdGUuZ2V0SG91cnMoKSArIDEyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQTSc6XG4gICAgICAgICAgICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGUuc2V0SG91cnMobmV3RGF0ZS5nZXRIb3VycygpIC0gMTIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3RGF0ZS5nZXREYXRlKCkgIT09IGN1cnJlbnREYXRlLmdldERhdGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld0RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHByb3ZpZGVkIG1heCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmNsdWRlVGltZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZXhjbHVkZSB0aW1lIHBvcnRpb24gb2YgdGhlIHR3byBkYXRlc1xuICAgICAqIEBwYXJhbSBpbmNsdWRlRGF0ZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZXhjbHVkZSB0aGUgZGF0ZSBwb3J0aW9uIG9mIHRoZSB0d28gZGF0ZXNcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBwcm92aWRlZCBtYXhWYWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ3JlYXRlclRoYW5NYXhWYWx1ZSh2YWx1ZTogRGF0ZSwgbWF4VmFsdWU6IERhdGUsIGluY2x1ZGVUaW1lID0gdHJ1ZSwgaW5jbHVkZURhdGUgPSB0cnVlKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChpbmNsdWRlVGltZSAmJiBpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKSA+IG1heFZhbHVlLmdldFRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IG5ldyBEYXRlKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGNvbnN0IF9tYXhWYWx1ZSA9IG5ldyBEYXRlKG1heFZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGlmICghaW5jbHVkZVRpbWUpIHtcbiAgICAgICAgICAgIF92YWx1ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIF9tYXhWYWx1ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICBfdmFsdWUuc2V0RnVsbFllYXIoMCwgMCwgMCk7XG4gICAgICAgICAgICBfbWF4VmFsdWUuc2V0RnVsbFllYXIoMCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3ZhbHVlLmdldFRpbWUoKSA+IF9tYXhWYWx1ZS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHByb3ZpZGVkIG1pbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmNsdWRlVGltZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZXhjbHVkZSB0aW1lIHBvcnRpb24gb2YgdGhlIHR3byBkYXRlc1xuICAgICAqIEBwYXJhbSBpbmNsdWRlRGF0ZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZXhjbHVkZSB0aGUgZGF0ZSBwb3J0aW9uIG9mIHRoZSB0d28gZGF0ZXNcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiBwcm92aWRlZCBtaW5WYWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgbGVzc1RoYW5NaW5WYWx1ZSh2YWx1ZTogRGF0ZSwgbWluVmFsdWU6IERhdGUsIGluY2x1ZGVUaW1lID0gdHJ1ZSwgaW5jbHVkZURhdGUgPSB0cnVlKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChpbmNsdWRlVGltZSAmJiBpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKSA8IG1pblZhbHVlLmdldFRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IG5ldyBEYXRlKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGNvbnN0IF9taW5WYWx1ZSA9IG5ldyBEYXRlKG1pblZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGlmICghaW5jbHVkZVRpbWUpIHtcbiAgICAgICAgICAgIF92YWx1ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIF9taW5WYWx1ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICBfdmFsdWUuc2V0RnVsbFllYXIoMCwgMCwgMCk7XG4gICAgICAgICAgICBfbWluVmFsdWUuc2V0RnVsbFllYXIoMCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3ZhbHVlLmdldFRpbWUoKSA8IF9taW5WYWx1ZS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGEgdmFsdWUgd2l0aGluIGEgZ2l2ZW4gbWluIGFuZCBtYXggdmFsdWUgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHZhbGlkYXRlXG4gICAgICogQHBhcmFtIG1pblZhbHVlIFRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUgdGhhdCBgdmFsdWVgIGNhbiB0YWtlXG4gICAgICogQHBhcmFtIG1heFZhbHVlIFRoZSBsYXJnZXN0IHBvc3NpYmxlIHZhbHVlIHRoYXQgYHZhbHVlYCBjYW4gdGFrZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgdmFsaWRhdGVNaW5NYXgodmFsdWU6IERhdGUsIG1pblZhbHVlOiBEYXRlIHwgc3RyaW5nLCBtYXhWYWx1ZTogRGF0ZSB8IHN0cmluZyxcbiAgICAgICAgaW5jbHVkZVRpbWUgPSB0cnVlLCBpbmNsdWRlRGF0ZSA9IHRydWUpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IG1pbiA9IERhdGVUaW1lVXRpbC5pc1ZhbGlkRGF0ZShtaW5WYWx1ZSkgPyBtaW5WYWx1ZSA6IERhdGVUaW1lVXRpbC5wYXJzZUlzb0RhdGUobWluVmFsdWUpO1xuICAgICAgICBjb25zdCBtYXggPSBEYXRlVGltZVV0aWwuaXNWYWxpZERhdGUobWF4VmFsdWUpID8gbWF4VmFsdWUgOiBEYXRlVGltZVV0aWwucGFyc2VJc29EYXRlKG1heFZhbHVlKTtcbiAgICAgICAgaWYgKG1pbiAmJiB2YWx1ZSAmJiBEYXRlVGltZVV0aWwubGVzc1RoYW5NaW5WYWx1ZSh2YWx1ZSwgbWluLCBpbmNsdWRlVGltZSwgaW5jbHVkZURhdGUpKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVycm9ycywgeyBtaW5WYWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ICYmIHZhbHVlICYmIERhdGVUaW1lVXRpbC5ncmVhdGVyVGhhbk1heFZhbHVlKHZhbHVlLCBtYXgsIGluY2x1ZGVUaW1lLCBpbmNsdWRlRGF0ZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZXJyb3JzLCB7IG1heFZhbHVlOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbiAgICAvKiogUGFyc2UgYW4gSVNPIHN0cmluZyB0byBhIERhdGUgKi9cbiAgICBwdWJsaWMgc3RhdGljIHBhcnNlSXNvRGF0ZSh2YWx1ZTogc3RyaW5nKTogRGF0ZSB8IG51bGwge1xuICAgICAgICBsZXQgcmVnZXggPSAvXlxcZHs0fS9nO1xuICAgICAgICBjb25zdCB0aW1lTGl0ZXJhbCA9ICdUJztcbiAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUgKyBgJHt2YWx1ZS5pbmRleE9mKHRpbWVMaXRlcmFsKSA9PT0gLTEgPyAnVDAwOjAwOjAwJyA6ICcnfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnZXggPSAvXlxcZHsyfS9nO1xuICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVOb3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgICAgICAgICBsZXQgW2RhdGVQYXJ0LCBfdGltZVBhcnRdID0gZGF0ZU5vdy5zcGxpdCh0aW1lTGl0ZXJhbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoYCR7ZGF0ZVBhcnR9VCR7dmFsdWV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGlucHV0IGlzIHZhbGlkIGRhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBpbnB1dCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgaW5wdXQgaXMgYSB2YWxpZCBkYXRlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBpc1ZhbGlkRGF0ZSh2YWx1ZTogYW55KTogdmFsdWUgaXMgRGF0ZSB7XG4gICAgICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzTmFOKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgYWRkQ3VycmVudFBhcnQoY3VycmVudFBhcnQ6IERhdGVQYXJ0SW5mbywgZGF0ZVRpbWVQYXJ0czogRGF0ZVBhcnRJbmZvW10pOiB2b2lkIHtcbiAgICAgICAgRGF0ZVRpbWVVdGlsLmVuc3VyZUxlYWRpbmdaZXJvKGN1cnJlbnRQYXJ0KTtcbiAgICAgICAgY3VycmVudFBhcnQuZW5kID0gY3VycmVudFBhcnQuc3RhcnQgKyBjdXJyZW50UGFydC5mb3JtYXQubGVuZ3RoO1xuICAgICAgICBkYXRlVGltZVBhcnRzLnB1c2goY3VycmVudFBhcnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGRheXNJbk1vbnRoKGZ1bGxZZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZnVsbFllYXIsIG1vbnRoICsgMSwgMCkuZ2V0RGF0ZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHRyaW1FbXB0eVBsYWNlaG9sZGVycyh2YWx1ZTogc3RyaW5nLCBwcm9tcHRDaGFyPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKHByb21wdENoYXIgfHwgJ18nLCAnZycpLCAnJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TWFzayhkYXRlU3RydWN0OiBhbnlbXSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGRhdGVTdHJ1Y3QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC5mb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLk51bWVyaWM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gRGF0ZVBhcnRzLkRheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCdkJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBEYXRlUGFydHMuTW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sucHVzaCgnTScpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCd5eXl5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgRm9ybWF0RGVzYy5Ud29EaWdpdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gRGF0ZVBhcnRzLkRheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCdkZCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gRGF0ZVBhcnRzLk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLnB1c2goJ01NJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLnB1c2goJ3l5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IERhdGVUaW1lVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICBtYXNrLnB1c2gocGFydC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFzay5qb2luKCcnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBsb2dNaXNzaW5nTG9jYWxlU2V0dGluZ3MobG9jYWxlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBNaXNzaW5nIGxvY2FsZSBkYXRhIGZvciB0aGUgbG9jYWxlICR7bG9jYWxlfS4gUGxlYXNlIHJlZmVyIHRvIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9pMThuI2kxOG4tcGlwZXNgKTtcbiAgICAgICAgY29uc29sZS53YXJuKCdVc2luZyBkZWZhdWx0IGJyb3dzZXIgbG9jYWxlIHNldHRpbmdzLicpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHByZXBlbmRWYWx1ZSh2YWx1ZTogbnVtYmVyLCBwYXJ0TGVuZ3RoOiBudW1iZXIsIHByZXBlbmRDaGFyOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gKHByZXBlbmRDaGFyICsgdmFsdWUudG9TdHJpbmcoKSkuc2xpY2UoLXBhcnRMZW5ndGgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHRvVHdlbHZlSG91ckZvcm1hdCh2YWx1ZTogc3RyaW5nLCBwcm9tcHRDaGFyID0gJ18nKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGhvdXIgPSBwYXJzZUludCh2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAocHJvbXB0Q2hhciwgJ2cnKSwgJzAnKSwgMTApO1xuICAgICAgICBpZiAoaG91ciA+IDEyKSB7XG4gICAgICAgICAgICBob3VyIC09IDEyO1xuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPT09IDApIHtcbiAgICAgICAgICAgIGhvdXIgPSAxMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGVuc3VyZUxlYWRpbmdaZXJvKHBhcnQ6IERhdGVQYXJ0SW5mbykge1xuICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5EYXRlOlxuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5Nb250aDpcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuSG91cnM6XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0Lk1pbnV0ZXM6XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0LlNlY29uZHM6XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuZm9ybWF0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LmZvcm1hdCA9IHBhcnQuZm9ybWF0LnJlcGVhdCgyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRDbGVhblZhbChpbnB1dERhdGE6IHN0cmluZywgZGF0ZVBhcnQ6IERhdGVQYXJ0SW5mbywgcHJvbXB0Q2hhcj86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBEYXRlVGltZVV0aWwudHJpbUVtcHR5UGxhY2Vob2xkZXJzKGlucHV0RGF0YS5zdWJzdHJpbmcoZGF0ZVBhcnQuc3RhcnQsIGRhdGVQYXJ0LmVuZCksIHByb21wdENoYXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGRldGVybWluZURhdGVQYXJ0KGNoYXI6IHN0cmluZyk6IERhdGVQYXJ0IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5EYXRlO1xuICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0Lk1vbnRoO1xuICAgICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuWWVhcjtcbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0LkhvdXJzO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0Lk1pbnV0ZXM7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5TZWNvbmRzO1xuICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuQW1QbTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0LkxpdGVyYWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXREZWZhdWx0TG9jYWxlTWFzayhsb2NhbGU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBkYXRlU3RydWN0ID0gW107XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdFRvUGFydHMgPSBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgpKTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGZvcm1hdFRvUGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IERhdGVUaW1lVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlVGltZVV0aWwuU0VQQVJBVE9SLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFydC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXJ0LnR5cGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZXJPcHRpb25zID0gZm9ybWF0dGVyLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgZGF0ZVN0cnVjdCkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5EYXk6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5mb3JtYXRUeXBlID0gZm9ybWF0dGVyT3B0aW9ucy5kYXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5Nb250aDoge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LmZvcm1hdFR5cGUgPSBmb3JtYXR0ZXJPcHRpb25zLm1vbnRoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRlUGFydHMuWWVhcjoge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LmZvcm1hdFR5cGUgPSBmb3JtYXR0ZXJPcHRpb25zLnllYXI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBEYXRlVGltZVV0aWwuZmlsbERhdGVQYXJ0c1Bvc2l0aW9ucyhkYXRlU3RydWN0KTtcbiAgICAgICAgcmV0dXJuIGRhdGVTdHJ1Y3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmlsbERhdGVQYXJ0c1Bvc2l0aW9ucyhkYXRlQXJyYXk6IGFueVtdKTogdm9pZCB7XG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gMDtcblxuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgZGF0ZUFycmF5KSB7XG4gICAgICAgICAgICAvLyBEYXl8TW9udGggcGFydCBwb3NpdGlvbnNcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IERhdGVQYXJ0cy5EYXkgfHwgcGFydC50eXBlID09PSBEYXRlUGFydHMuTW9udGgpIHtcbiAgICAgICAgICAgICAgICAvLyBPZmZzZXQgMiBwb3NpdGlvbnMgZm9yIG51bWJlclxuICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDJdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBEYXRlUGFydHMuWWVhcikge1xuICAgICAgICAgICAgICAgIC8vIFllYXIgcGFydCBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcnQuZm9ybWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuTnVtZXJpYzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2Zmc2V0IDQgcG9zaXRpb25zIGZvciBmdWxsIHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcyArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2Zmc2V0IDIgcG9zaXRpb25zIGZvciBzaG9ydCB5ZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uID0gW2N1cnJlbnRQb3MsIGN1cnJlbnRQb3MgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IERhdGVUaW1lVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXBhcmF0b3IgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbiA9IFtjdXJyZW50UG9zLCBjdXJyZW50UG9zICsgMV07XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl19