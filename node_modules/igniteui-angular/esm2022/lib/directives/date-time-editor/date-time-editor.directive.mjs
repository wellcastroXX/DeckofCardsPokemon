/* eslint-disable @angular-eslint/no-conflicting-lifecycle */
import { Directive, Input, Output, EventEmitter, Inject, LOCALE_ID, HostListener, booleanAttribute } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, } from '@angular/forms';
import { DOCUMENT } from '@angular/common';
import { IgxMaskDirective } from '../mask/mask.directive';
import { isDate } from '../../core/utils';
import { DatePart } from './date-time-editor.common';
import { noop } from 'rxjs';
import { DateTimeUtil } from '../../date-common/util/date-time.util';
import * as i0 from "@angular/core";
import * as i1 from "../mask/mask-parsing.service";
import * as i2 from "../../core/utils";
/**
 * Date Time Editor provides a functionality to input, edit and format date and time.
 *
 * @igxModule IgxDateTimeEditorModule
 *
 * @igxParent IgxInputGroup
 *
 * @igxTheme igx-input-theme
 *
 * @igxKeywords date, time, editor
 *
 * @igxGroup Scheduling
 *
 * @remarks
 *
 * The Ignite UI Date Time Editor Directive makes it easy for developers to manipulate date/time user input.
 * It requires input in a specified or default input format which is visible in the input element as a placeholder.
 * It allows the input of only date (ex: 'dd/MM/yyyy'), only time (ex:'HH:mm tt') or both at once, if needed.
 * Supports display format that may differ from the input format.
 * Provides methods to increment and decrement any specific/targeted `DatePart`.
 *
 * @example
 * ```html
 * <igx-input-group>
 *   <input type="text" igxInput [igxDateTimeEditor]="'dd/MM/yyyy'" [displayFormat]="'shortDate'" [(ngModel)]="date"/>
 * </igx-input-group>
 * ```
 */
export class IgxDateTimeEditorDirective extends IgxMaskDirective {
    /**
     * Minimum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [minValue]="minDate">
     * ```
     */
    get minValue() {
        return this._minValue;
    }
    set minValue(value) {
        this._minValue = value;
        this.onValidatorChange();
    }
    /**
     * Maximum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed in, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [maxValue]="maxDate">
     * ```
     */
    get maxValue() {
        return this._maxValue;
    }
    set maxValue(value) {
        this._maxValue = value;
        this.onValidatorChange();
    }
    /**
     * Expected user input format (and placeholder).
     *
     * @example
     * ```html
     * <input [igxDateTimeEditor]="'dd/MM/yyyy'">
     * ```
     */
    set inputFormat(value) {
        if (value) {
            this.setMask(value);
            this._inputFormat = value;
        }
    }
    get inputFormat() {
        return this._inputFormat || this._defaultInputFormat;
    }
    /**
     * Editor value.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [value]="date">
     * ```
     */
    set value(value) {
        this._value = value;
        this.setDateValue(value);
        this.onChangeCallback(value);
        this.updateMask();
    }
    get value() {
        return this._value;
    }
    get datePartDeltas() {
        return Object.assign({}, this._datePartDeltas, this.spinDelta);
    }
    get emptyMask() {
        return this.maskParser.applyMask(null, this.maskOptions);
    }
    get targetDatePart() {
        // V.K. May 16th, 2022 #11554 Get correct date part in shadow DOM
        if (this.document.activeElement === this.nativeElement ||
            this.document.activeElement?.shadowRoot?.activeElement === this.nativeElement) {
            return this._inputDateParts
                .find(p => p.start <= this.selectionStart && this.selectionStart <= p.end && p.type !== DatePart.Literal)?.type;
        }
        else {
            if (this._inputDateParts.some(p => p.type === DatePart.Date)) {
                return DatePart.Date;
            }
            else if (this._inputDateParts.some(p => p.type === DatePart.Hours)) {
                return DatePart.Hours;
            }
        }
    }
    get hasDateParts() {
        return this._inputDateParts.some(p => p.type === DatePart.Date
            || p.type === DatePart.Month
            || p.type === DatePart.Year);
    }
    get hasTimeParts() {
        return this._inputDateParts.some(p => p.type === DatePart.Hours
            || p.type === DatePart.Minutes
            || p.type === DatePart.Seconds);
    }
    get dateValue() {
        return this._dateValue;
    }
    constructor(renderer, elementRef, maskParser, platform, _document, _locale) {
        super(elementRef, maskParser, renderer, platform);
        this._document = _document;
        this._locale = _locale;
        /**
         * Specify if the currently spun date segment should loop over.
         *
         * @example
         * ```html
         * <input igxDateTimeEditor [spinLoop]="false">
         * ```
         */
        this.spinLoop = true;
        /**
         * Emitted when the editor's value has changed.
         *
         * @example
         * ```html
         * <input igxDateTimeEditor (valueChange)="valueChange($event)"/>
         * ```
         */
        this.valueChange = new EventEmitter();
        /**
         * Emitted when the editor is not within a specified range or when the editor's value is in an invalid state.
         *
         * @example
         * ```html
         * <input igxDateTimeEditor [minValue]="minDate" [maxValue]="maxDate" (validationFailed)="onValidationFailed($event)"/>
         * ```
         */
        this.validationFailed = new EventEmitter();
        this._datePartDeltas = {
            date: 1,
            month: 1,
            year: 1,
            hours: 1,
            minutes: 1,
            seconds: 1
        };
        this.onTouchCallback = noop;
        this.onChangeCallback = noop;
        this.onValidatorChange = noop;
        this.document = this._document;
        this.locale = this.locale || this._locale;
    }
    onWheel(event) {
        if (!this._isFocused) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (event.deltaY > 0) {
            this.decrement();
        }
        else {
            this.increment();
        }
    }
    ngOnInit() {
        this.updateDefaultFormat();
        this.setMask(this.inputFormat);
        this.updateMask();
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['locale'] && !changes['locale'].firstChange) {
            this.updateDefaultFormat();
            if (!this._inputFormat) {
                this.setMask(this.inputFormat);
                this.updateMask();
            }
        }
        if (changes['inputFormat'] && !changes['inputFormat'].firstChange) {
            this.updateMask();
        }
    }
    /** Clear the input element value. */
    clear() {
        this._onClear = true;
        this.updateValue(null);
        this.setSelectionRange(0, this.inputValue.length);
        this._onClear = false;
    }
    /**
     * Increment specified DatePart.
     *
     * @param datePart The optional DatePart to increment. Defaults to Date or Hours (when Date is absent from the inputFormat - ex:'HH:mm').
     * @param delta The optional delta to increment by. Overrides `spinDelta`.
     */
    increment(datePart, delta) {
        const targetPart = datePart || this.targetDatePart;
        if (!targetPart) {
            return;
        }
        const newValue = this.trySpinValue(targetPart, delta);
        this.updateValue(newValue);
    }
    /**
     * Decrement specified DatePart.
     *
     * @param datePart The optional DatePart to decrement. Defaults to Date or Hours (when Date is absent from the inputFormat - ex:'HH:mm').
     * @param delta The optional delta to decrement by. Overrides `spinDelta`.
     */
    decrement(datePart, delta) {
        const targetPart = datePart || this.targetDatePart;
        if (!targetPart) {
            return;
        }
        const newValue = this.trySpinValue(targetPart, delta, true);
        this.updateValue(newValue);
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        this.setDateValue(value);
        this.updateMask();
    }
    /** @hidden @internal */
    validate(control) {
        if (!control.value) {
            return null;
        }
        // InvalidDate handling
        if (isDate(control.value) && !DateTimeUtil.isValidDate(control.value)) {
            return { value: true };
        }
        let errors = {};
        const value = DateTimeUtil.isValidDate(control.value) ? control.value : DateTimeUtil.parseIsoDate(control.value);
        const minValueDate = DateTimeUtil.isValidDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
        const maxValueDate = DateTimeUtil.isValidDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
        if (minValueDate || maxValueDate) {
            errors = DateTimeUtil.validateMinMax(value, minValueDate, maxValueDate, this.hasTimeParts, this.hasDateParts);
        }
        return Object.keys(errors).length > 0 ? errors : null;
    }
    /** @hidden @internal */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this.onTouchCallback = fn;
    }
    /** @hidden @internal */
    setDisabledState(_isDisabled) { }
    /** @hidden @internal */
    onCompositionEnd() {
        super.onCompositionEnd();
        this.updateValue(this.parseDate(this.inputValue));
        this.updateMask();
    }
    /** @hidden @internal */
    onInputChanged(event) {
        super.onInputChanged(event);
        if (this._composing) {
            return;
        }
        if (this.inputIsComplete()) {
            const parsedDate = this.parseDate(this.inputValue);
            if (DateTimeUtil.isValidDate(parsedDate)) {
                this.updateValue(parsedDate);
            }
            else {
                const oldValue = this.value && new Date(this.dateValue.getTime());
                const args = { oldValue, newValue: parsedDate, userInput: this.inputValue };
                this.validationFailed.emit(args);
                if (DateTimeUtil.isValidDate(args.newValue)) {
                    this.updateValue(args.newValue);
                }
                else {
                    this.updateValue(null);
                }
            }
        }
        else {
            this.updateValue(null);
        }
    }
    /** @hidden @internal */
    onKeyDown(event) {
        if (this.nativeElement.readOnly) {
            return;
        }
        super.onKeyDown(event);
        const key = event.key;
        if (event.altKey) {
            return;
        }
        if (key === this.platform.KEYMAP.ARROW_DOWN || key === this.platform.KEYMAP.ARROW_UP) {
            this.spin(event);
            return;
        }
        if (event.ctrlKey && key === this.platform.KEYMAP.SEMICOLON) {
            this.updateValue(new Date());
        }
        this.moveCursor(event);
    }
    /** @hidden @internal */
    onFocus() {
        if (this.nativeElement.readOnly) {
            return;
        }
        this._isFocused = true;
        this.onTouchCallback();
        this.updateMask();
        super.onFocus();
        this.nativeElement.select();
    }
    /** @hidden @internal */
    onBlur(value) {
        this._isFocused = false;
        if (!this.inputIsComplete() && this.inputValue !== this.emptyMask) {
            this.updateValue(this.parseDate(this.inputValue));
        }
        else {
            this.updateMask();
        }
        // TODO: think of a better way to set displayValuePipe in mask directive
        if (this.displayValuePipe) {
            return;
        }
        super.onBlur(value);
    }
    // the date editor sets its own inputFormat as its placeholder if none is provided
    /** @hidden */
    setPlaceholder(_value) { }
    updateDefaultFormat() {
        this._defaultInputFormat = DateTimeUtil.getDefaultInputFormat(this.locale);
    }
    updateMask() {
        if (this._isFocused) {
            // store the cursor position as it will be moved during masking
            const cursor = this.selectionEnd;
            this.inputValue = this.getMaskedValue();
            this.setSelectionRange(cursor);
        }
        else {
            if (!this.dateValue || !DateTimeUtil.isValidDate(this.dateValue)) {
                this.inputValue = '';
                return;
            }
            if (this.displayValuePipe) {
                // TODO: remove when formatter func has been deleted
                this.inputValue = this.displayValuePipe.transform(this.value);
                return;
            }
            const format = this.displayFormat || this.inputFormat;
            if (format) {
                this.inputValue = DateTimeUtil.formatDate(this.dateValue, format.replace('tt', 'aa'), this.locale);
            }
            else {
                this.inputValue = this.dateValue.toLocaleString();
            }
        }
    }
    setMask(inputFormat) {
        const oldFormat = this._inputDateParts?.map(p => p.format).join('');
        this._inputDateParts = DateTimeUtil.parseDateTimeFormat(inputFormat);
        inputFormat = this._inputDateParts.map(p => p.format).join('');
        const mask = (inputFormat || DateTimeUtil.DEFAULT_INPUT_FORMAT)
            .replace(new RegExp(/(?=[^t])[\w]/, 'g'), '0');
        this.mask = mask.indexOf('tt') !== -1 ? mask.replace(new RegExp('tt', 'g'), 'LL') : mask;
        const placeholder = this.nativeElement.placeholder;
        if (!placeholder || oldFormat === placeholder) {
            this.renderer.setAttribute(this.nativeElement, 'placeholder', inputFormat);
        }
    }
    parseDate(val) {
        if (!val) {
            return null;
        }
        return DateTimeUtil.parseValueFromMask(val, this._inputDateParts, this.promptChar);
    }
    getMaskedValue() {
        let mask = this.emptyMask;
        if (DateTimeUtil.isValidDate(this.value)) {
            for (const part of this._inputDateParts) {
                if (part.type === DatePart.Literal) {
                    continue;
                }
                const targetValue = this.getPartValue(part, part.format.length);
                mask = this.maskParser.replaceInMask(mask, targetValue, this.maskOptions, part.start, part.end).value;
            }
            return mask;
        }
        if (!this.inputIsComplete() || !this._onClear) {
            return this.inputValue;
        }
        return mask;
    }
    valueInRange(value) {
        if (!value) {
            return false;
        }
        let errors = {};
        const minValueDate = DateTimeUtil.isValidDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
        const maxValueDate = DateTimeUtil.isValidDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
        if (minValueDate || maxValueDate) {
            errors = DateTimeUtil.validateMinMax(value, this.minValue, this.maxValue, this.hasTimeParts, this.hasDateParts);
        }
        return Object.keys(errors).length === 0;
    }
    spinValue(datePart, delta) {
        if (!this.dateValue || !DateTimeUtil.isValidDate(this.dateValue)) {
            return null;
        }
        const newDate = new Date(this.dateValue.getTime());
        switch (datePart) {
            case DatePart.Date:
                DateTimeUtil.spinDate(delta, newDate, this.spinLoop);
                break;
            case DatePart.Month:
                DateTimeUtil.spinMonth(delta, newDate, this.spinLoop);
                break;
            case DatePart.Year:
                DateTimeUtil.spinYear(delta, newDate);
                break;
            case DatePart.Hours:
                DateTimeUtil.spinHours(delta, newDate, this.spinLoop);
                break;
            case DatePart.Minutes:
                DateTimeUtil.spinMinutes(delta, newDate, this.spinLoop);
                break;
            case DatePart.Seconds:
                DateTimeUtil.spinSeconds(delta, newDate, this.spinLoop);
                break;
            case DatePart.AmPm:
                const formatPart = this._inputDateParts.find(dp => dp.type === DatePart.AmPm);
                const amPmFromMask = this.inputValue.substring(formatPart.start, formatPart.end);
                return DateTimeUtil.spinAmPm(newDate, this.dateValue, amPmFromMask);
        }
        return newDate;
    }
    trySpinValue(datePart, delta, negative = false) {
        if (!delta) {
            // default to 1 if a delta is set to 0 or any other falsy value
            delta = this.datePartDeltas[datePart] || 1;
        }
        const spinValue = negative ? -Math.abs(delta) : Math.abs(delta);
        return this.spinValue(datePart, spinValue) || new Date();
    }
    setDateValue(value) {
        this._dateValue = DateTimeUtil.isValidDate(value)
            ? value
            : DateTimeUtil.parseIsoDate(value);
    }
    updateValue(newDate) {
        this._oldValue = this.dateValue;
        this.value = newDate;
        // TODO: should we emit events here?
        if (this.inputIsComplete() || this.inputValue === this.emptyMask) {
            this.valueChange.emit(this.dateValue);
        }
        if (this.dateValue && !this.valueInRange(this.dateValue)) {
            this.validationFailed.emit({ oldValue: this._oldValue, newValue: this.dateValue, userInput: this.inputValue });
        }
    }
    toTwelveHourFormat(value) {
        let hour = parseInt(value.replace(new RegExp(this.promptChar, 'g'), '0'), 10);
        if (hour > 12) {
            hour -= 12;
        }
        else if (hour === 0) {
            hour = 12;
        }
        return hour;
    }
    getPartValue(datePartInfo, partLength) {
        let maskedValue;
        const datePart = datePartInfo.type;
        switch (datePart) {
            case DatePart.Date:
                maskedValue = this.dateValue.getDate();
                break;
            case DatePart.Month:
                // months are zero based
                maskedValue = this.dateValue.getMonth() + 1;
                break;
            case DatePart.Year:
                if (partLength === 2) {
                    maskedValue = this.prependValue(parseInt(this.dateValue.getFullYear().toString().slice(-2), 10), partLength, '0');
                }
                else {
                    maskedValue = this.dateValue.getFullYear();
                }
                break;
            case DatePart.Hours:
                if (datePartInfo.format.indexOf('h') !== -1) {
                    maskedValue = this.prependValue(this.toTwelveHourFormat(this.dateValue.getHours().toString()), partLength, '0');
                }
                else {
                    maskedValue = this.dateValue.getHours();
                }
                break;
            case DatePart.Minutes:
                maskedValue = this.dateValue.getMinutes();
                break;
            case DatePart.Seconds:
                maskedValue = this.dateValue.getSeconds();
                break;
            case DatePart.AmPm:
                maskedValue = this.dateValue.getHours() >= 12 ? 'PM' : 'AM';
                break;
        }
        if (datePartInfo.type !== DatePart.AmPm) {
            return this.prependValue(maskedValue, partLength, '0');
        }
        return maskedValue;
    }
    prependValue(value, partLength, prependChar) {
        return (prependChar + value.toString()).slice(-partLength);
    }
    spin(event) {
        event.preventDefault();
        switch (event.key) {
            case this.platform.KEYMAP.ARROW_UP:
                this.increment();
                break;
            case this.platform.KEYMAP.ARROW_DOWN:
                this.decrement();
                break;
        }
    }
    inputIsComplete() {
        return this.inputValue.indexOf(this.promptChar) === -1;
    }
    moveCursor(event) {
        const value = event.target.value;
        switch (event.key) {
            case this.platform.KEYMAP.ARROW_LEFT:
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.setSelectionRange(this.getNewPosition(value));
                }
                break;
            case this.platform.KEYMAP.ARROW_RIGHT:
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.setSelectionRange(this.getNewPosition(value, 1));
                }
                break;
        }
    }
    /**
     * Move the cursor in a specific direction until it reaches a date/time separator.
     * Then return its index.
     *
     * @param value The string it operates on.
     * @param direction 0 is left, 1 is right. Default is 0.
     */
    getNewPosition(value, direction = 0) {
        const literals = this._inputDateParts.filter(p => p.type === DatePart.Literal);
        let cursorPos = this.selectionStart;
        if (!direction) {
            do {
                cursorPos = cursorPos > 0 ? --cursorPos : cursorPos;
            } while (!literals.some(l => l.end === cursorPos) && cursorPos > 0);
            return cursorPos;
        }
        else {
            do {
                cursorPos++;
            } while (!literals.some(l => l.start === cursorPos) && cursorPos < value.length);
            return cursorPos;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxDateTimeEditorDirective, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i1.MaskParsingService }, { token: i2.PlatformUtil }, { token: DOCUMENT }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.2.4", type: IgxDateTimeEditorDirective, isStandalone: true, selector: "[igxDateTimeEditor]", inputs: { locale: "locale", minValue: "minValue", maxValue: "maxValue", spinLoop: ["spinLoop", "spinLoop", booleanAttribute], displayFormat: "displayFormat", inputFormat: ["igxDateTimeEditor", "inputFormat"], value: "value", spinDelta: "spinDelta" }, outputs: { valueChange: "valueChange", validationFailed: "validationFailed" }, host: { listeners: { "wheel": "onWheel($event)" } }, providers: [
            { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateTimeEditorDirective, multi: true },
            { provide: NG_VALIDATORS, useExisting: IgxDateTimeEditorDirective, multi: true }
        ], exportAs: ["igxDateTimeEditor"], usesInheritance: true, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxDateTimeEditorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxDateTimeEditor]',
                    exportAs: 'igxDateTimeEditor',
                    providers: [
                        { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateTimeEditorDirective, multi: true },
                        { provide: NG_VALIDATORS, useExisting: IgxDateTimeEditorDirective, multi: true }
                    ],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i1.MaskParsingService }, { type: i2.PlatformUtil }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }], propDecorators: { locale: [{
                type: Input
            }], minValue: [{
                type: Input
            }], maxValue: [{
                type: Input
            }], spinLoop: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], displayFormat: [{
                type: Input
            }], inputFormat: [{
                type: Input,
                args: [`igxDateTimeEditor`]
            }], value: [{
                type: Input
            }], spinDelta: [{
                type: Input
            }], valueChange: [{
                type: Output
            }], validationFailed: [{
                type: Output
            }], onWheel: [{
                type: HostListener,
                args: ['wheel', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLWVkaXRvci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGlyZWN0aXZlcy9kYXRlLXRpbWUtZWRpdG9yL2RhdGUtdGltZS1lZGl0b3IuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZEQUE2RDtBQUM3RCxPQUFPLEVBQ0gsU0FBUyxFQUFFLEtBQUssRUFDTCxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFDdkMsU0FBUyxFQUE0QixZQUFZLEVBQVUsZ0JBQWdCLEVBQzlFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFFMkMsYUFBYSxFQUFFLGlCQUFpQixHQUNqRixNQUFNLGdCQUFnQixDQUFDO0FBQ3hCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUUxRCxPQUFPLEVBQUUsTUFBTSxFQUFnQixNQUFNLGtCQUFrQixDQUFDO0FBQ3hELE9BQU8sRUFBNEMsUUFBUSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDL0YsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU1QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sdUNBQXVDLENBQUM7Ozs7QUFFckU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJCRztBQVVILE1BQU0sT0FBTywwQkFBMkIsU0FBUSxnQkFBZ0I7SUFrQjVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxJQUFXLFFBQVE7UUFDZixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDMUIsQ0FBQztJQUVELElBQ1csUUFBUSxDQUFDLEtBQW9CO1FBQ3BDLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxpQkFBaUIsRUFB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LG1CQUFtQjtvQkFDN0IsU0FBUyxFQUFFO3dCQUNQLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsNEJBQTRCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTt3QkFDcEYsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLFdBQVcsNEJBQTRCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtxQkFDbkY7b0JBQ0QsVUFBVSxFQUFFLElBQUk7aUJBQ25COzswQkFtT1EsTUFBTTsyQkFBQyxRQUFROzswQkFDZixNQUFNOzJCQUFDLFNBQVM7eUNBbk5kLE1BQU07c0JBRFosS0FBSztnQkFtQkssUUFBUTtzQkFEbEIsS0FBSztnQkFzQkssUUFBUTtzQkFEbEIsS0FBSztnQkFlQyxRQUFRO3NCQURkLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBYS9CLGFBQWE7c0JBRG5CLEtBQUs7Z0JBWUssV0FBVztzQkFEckIsS0FBSzt1QkFBQyxtQkFBbUI7Z0JBcUJmLEtBQUs7c0JBRGYsS0FBSztnQkFzQkMsU0FBUztzQkFEZixLQUFLO2dCQVlDLFdBQVc7c0JBRGpCLE1BQU07Z0JBWUEsZ0JBQWdCO3NCQUR0QixNQUFNO2dCQWdGQSxPQUFPO3NCQURiLFlBQVk7dUJBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQGFuZ3VsYXItZXNsaW50L25vLWNvbmZsaWN0aW5nLWxpZmVjeWNsZSAqL1xuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsIElucHV0LCBFbGVtZW50UmVmLFxuICAgIFJlbmRlcmVyMiwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEluamVjdCxcbiAgICBMT0NBTEVfSUQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgSG9zdExpc3RlbmVyLCBPbkluaXQsIGJvb2xlYW5BdHRyaWJ1dGVcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgIFZhbGlkYXRvciwgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBOR19WQUxJREFUT1JTLCBOR19WQUxVRV9BQ0NFU1NPUixcbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSWd4TWFza0RpcmVjdGl2ZSB9IGZyb20gJy4uL21hc2svbWFzay5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWFza1BhcnNpbmdTZXJ2aWNlIH0gZnJvbSAnLi4vbWFzay9tYXNrLXBhcnNpbmcuc2VydmljZSc7XG5pbXBvcnQgeyBpc0RhdGUsIFBsYXRmb3JtVXRpbCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSWd4RGF0ZVRpbWVFZGl0b3JFdmVudEFyZ3MsIERhdGVQYXJ0SW5mbywgRGF0ZVBhcnQgfSBmcm9tICcuL2RhdGUtdGltZS1lZGl0b3IuY29tbW9uJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IERhdGVQYXJ0RGVsdGFzIH0gZnJvbSAnLi9kYXRlLXRpbWUtZWRpdG9yLmNvbW1vbic7XG5pbXBvcnQgeyBEYXRlVGltZVV0aWwgfSBmcm9tICcuLi8uLi9kYXRlLWNvbW1vbi91dGlsL2RhdGUtdGltZS51dGlsJztcblxuLyoqXG4gKiBEYXRlIFRpbWUgRWRpdG9yIHByb3ZpZGVzIGEgZnVuY3Rpb25hbGl0eSB0byBpbnB1dCwgZWRpdCBhbmQgZm9ybWF0IGRhdGUgYW5kIHRpbWUuXG4gKlxuICogQGlneE1vZHVsZSBJZ3hEYXRlVGltZUVkaXRvck1vZHVsZVxuICpcbiAqIEBpZ3hQYXJlbnQgSWd4SW5wdXRHcm91cFxuICpcbiAqIEBpZ3hUaGVtZSBpZ3gtaW5wdXQtdGhlbWVcbiAqXG4gKiBAaWd4S2V5d29yZHMgZGF0ZSwgdGltZSwgZWRpdG9yXG4gKlxuICogQGlneEdyb3VwIFNjaGVkdWxpbmdcbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFRoZSBJZ25pdGUgVUkgRGF0ZSBUaW1lIEVkaXRvciBEaXJlY3RpdmUgbWFrZXMgaXQgZWFzeSBmb3IgZGV2ZWxvcGVycyB0byBtYW5pcHVsYXRlIGRhdGUvdGltZSB1c2VyIGlucHV0LlxuICogSXQgcmVxdWlyZXMgaW5wdXQgaW4gYSBzcGVjaWZpZWQgb3IgZGVmYXVsdCBpbnB1dCBmb3JtYXQgd2hpY2ggaXMgdmlzaWJsZSBpbiB0aGUgaW5wdXQgZWxlbWVudCBhcyBhIHBsYWNlaG9sZGVyLlxuICogSXQgYWxsb3dzIHRoZSBpbnB1dCBvZiBvbmx5IGRhdGUgKGV4OiAnZGQvTU0veXl5eScpLCBvbmx5IHRpbWUgKGV4OidISDptbSB0dCcpIG9yIGJvdGggYXQgb25jZSwgaWYgbmVlZGVkLlxuICogU3VwcG9ydHMgZGlzcGxheSBmb3JtYXQgdGhhdCBtYXkgZGlmZmVyIGZyb20gdGhlIGlucHV0IGZvcm1hdC5cbiAqIFByb3ZpZGVzIG1ldGhvZHMgdG8gaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYW55IHNwZWNpZmljL3RhcmdldGVkIGBEYXRlUGFydGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtaW5wdXQtZ3JvdXA+XG4gKiAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlneElucHV0IFtpZ3hEYXRlVGltZUVkaXRvcl09XCInZGQvTU0veXl5eSdcIiBbZGlzcGxheUZvcm1hdF09XCInc2hvcnREYXRlJ1wiIFsobmdNb2RlbCldPVwiZGF0ZVwiLz5cbiAqIDwvaWd4LWlucHV0LWdyb3VwPlxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneERhdGVUaW1lRWRpdG9yXScsXG4gICAgZXhwb3J0QXM6ICdpZ3hEYXRlVGltZUVkaXRvcicsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBJZ3hEYXRlVGltZUVkaXRvckRpcmVjdGl2ZSwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgeyBwcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogSWd4RGF0ZVRpbWVFZGl0b3JEaXJlY3RpdmUsIG11bHRpOiB0cnVlIH1cbiAgICBdLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4RGF0ZVRpbWVFZGl0b3JEaXJlY3RpdmUgZXh0ZW5kcyBJZ3hNYXNrRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQsIFZhbGlkYXRvciwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIExvY2FsZSBzZXR0aW5ncyB1c2VkIGZvciB2YWx1ZSBmb3JtYXR0aW5nLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBVc2VzIEFuZ3VsYXIncyBgTE9DQUxFX0lEYCBieSBkZWZhdWx0LiBBZmZlY3RzIGJvdGggaW5wdXQgbWFzayBhbmQgZGlzcGxheSBmb3JtYXQgaWYgdGhvc2UgYXJlIG5vdCBzZXQuXG4gICAgICogSWYgYSBgbG9jYWxlYCBpcyBzZXQsIGl0IG11c3QgYmUgcmVnaXN0ZXJlZCB2aWEgYHJlZ2lzdGVyTG9jYWxlRGF0YWAuXG4gICAgICogUGxlYXNlIHJlZmVyIHRvIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9pMThuI2kxOG4tcGlwZXMuXG4gICAgICogSWYgaXQgaXMgbm90IHJlZ2lzdGVyZWQsIGBJbnRsYCB3aWxsIGJlIHVzZWQgZm9yIGZvcm1hdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXQgaWd4RGF0ZVRpbWVFZGl0b3IgW2xvY2FsZV09XCInZW4nXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbG9jYWxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHZhbHVlIHJlcXVpcmVkIGZvciB0aGUgZWRpdG9yIHRvIHJlbWFpbiB2YWxpZC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgYSBgc3RyaW5nYCB2YWx1ZSBpcyBwYXNzZWQsIGl0IG11c3QgYmUgaW4gdGhlIGRlZmluZWQgaW5wdXQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IGlneERhdGVUaW1lRWRpdG9yIFttaW5WYWx1ZV09XCJtaW5EYXRlXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBtaW5WYWx1ZSgpOiBzdHJpbmcgfCBEYXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pblZhbHVlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBtaW5WYWx1ZSh2YWx1ZTogc3RyaW5nIHwgRGF0ZSkge1xuICAgICAgICB0aGlzLl9taW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSB2YWx1ZSByZXF1aXJlZCBmb3IgdGhlIGVkaXRvciB0byByZW1haW4gdmFsaWQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIGEgYHN0cmluZ2AgdmFsdWUgaXMgcGFzc2VkIGluLCBpdCBtdXN0IGJlIGluIHRoZSBkZWZpbmVkIGlucHV0IGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpbnB1dCBpZ3hEYXRlVGltZUVkaXRvciBbbWF4VmFsdWVdPVwibWF4RGF0ZVwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWF4VmFsdWUoKTogc3RyaW5nIHwgRGF0ZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhWYWx1ZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgbWF4VmFsdWUodmFsdWU6IHN0cmluZyB8IERhdGUpIHtcbiAgICAgICAgdGhpcy5fbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgaWYgdGhlIGN1cnJlbnRseSBzcHVuIGRhdGUgc2VnbWVudCBzaG91bGQgbG9vcCBvdmVyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IGlneERhdGVUaW1lRWRpdG9yIFtzcGluTG9vcF09XCJmYWxzZVwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBzcGluTG9vcCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYm90aCBwcmUtZGVmaW5lZCBmb3JtYXQgb3B0aW9ucyBzdWNoIGFzIGBzaG9ydERhdGVgIGFuZCBgbG9uZ0RhdGVgLFxuICAgICAqIGFzIHdlbGwgYXMgY29uc3RydWN0ZWQgZm9ybWF0IHN0cmluZyB1c2luZyBjaGFyYWN0ZXJzIHN1cHBvcnRlZCBieSBgRGF0ZVBpcGVgLCBlLmcuIGBFRS9NTS95eXl5YC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpbnB1dCBpZ3hEYXRlVGltZUVkaXRvciBbZGlzcGxheUZvcm1hdF09XCInc2hvcnREYXRlJ1wiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRpc3BsYXlGb3JtYXQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEV4cGVjdGVkIHVzZXIgaW5wdXQgZm9ybWF0IChhbmQgcGxhY2Vob2xkZXIpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IFtpZ3hEYXRlVGltZUVkaXRvcl09XCInZGQvTU0veXl5eSdcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoYGlneERhdGVUaW1lRWRpdG9yYClcbiAgICBwdWJsaWMgc2V0IGlucHV0Rm9ybWF0KHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1hc2sodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5faW5wdXRGb3JtYXQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaW5wdXRGb3JtYXQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0Rm9ybWF0IHx8IHRoaXMuX2RlZmF1bHRJbnB1dEZvcm1hdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZGl0b3IgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXQgaWd4RGF0ZVRpbWVFZGl0b3IgW3ZhbHVlXT1cImRhdGVcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgdmFsdWUodmFsdWU6IERhdGUgfCBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZXREYXRlVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1hc2soKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHZhbHVlKCk6IERhdGUgfCBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsdGEgdmFsdWVzIHVzZWQgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBlYWNoIGVkaXRvciBkYXRlIHBhcnQgb24gc3BpbiBhY3Rpb25zLlxuICAgICAqIEFsbCB2YWx1ZXMgZGVmYXVsdCB0byBgMWAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXQgaWd4RGF0ZVRpbWVFZGl0b3IgW3NwaW5EZWx0YV09XCJ7ZGF0ZTogNSwgbWludXRlOiAzMH1cIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzcGluRGVsdGE6IERhdGVQYXJ0RGVsdGFzO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBlZGl0b3IncyB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpbnB1dCBpZ3hEYXRlVGltZUVkaXRvciAodmFsdWVDaGFuZ2UpPVwidmFsdWVDaGFuZ2UoJGV2ZW50KVwiLz5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGUgfCBzdHJpbmc+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIGVkaXRvciBpcyBub3Qgd2l0aGluIGEgc3BlY2lmaWVkIHJhbmdlIG9yIHdoZW4gdGhlIGVkaXRvcidzIHZhbHVlIGlzIGluIGFuIGludmFsaWQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXQgaWd4RGF0ZVRpbWVFZGl0b3IgW21pblZhbHVlXT1cIm1pbkRhdGVcIiBbbWF4VmFsdWVdPVwibWF4RGF0ZVwiICh2YWxpZGF0aW9uRmFpbGVkKT1cIm9uVmFsaWRhdGlvbkZhaWxlZCgkZXZlbnQpXCIvPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyB2YWxpZGF0aW9uRmFpbGVkID0gbmV3IEV2ZW50RW1pdHRlcjxJZ3hEYXRlVGltZUVkaXRvckV2ZW50QXJncz4oKTtcblxuICAgIHByaXZhdGUgX2lucHV0Rm9ybWF0OiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfb2xkVmFsdWU6IERhdGU7XG4gICAgcHJpdmF0ZSBfZGF0ZVZhbHVlOiBEYXRlO1xuICAgIHByaXZhdGUgX29uQ2xlYXI6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBkb2N1bWVudDogRG9jdW1lbnQ7XG4gICAgcHJpdmF0ZSBfaXNGb2N1c2VkOiBib29sZWFuO1xuICAgIHByaXZhdGUgX2RlZmF1bHRJbnB1dEZvcm1hdDogc3RyaW5nO1xuICAgIHByaXZhdGUgX3ZhbHVlOiBEYXRlIHwgc3RyaW5nO1xuICAgIHByaXZhdGUgX21pblZhbHVlOiBEYXRlIHwgc3RyaW5nO1xuICAgIHByaXZhdGUgX21heFZhbHVlOiBEYXRlIHwgc3RyaW5nO1xuICAgIHByaXZhdGUgX2lucHV0RGF0ZVBhcnRzOiBEYXRlUGFydEluZm9bXTtcbiAgICBwcml2YXRlIF9kYXRlUGFydERlbHRhczogRGF0ZVBhcnREZWx0YXMgPSB7XG4gICAgICAgIGRhdGU6IDEsXG4gICAgICAgIG1vbnRoOiAxLFxuICAgICAgICB5ZWFyOiAxLFxuICAgICAgICBob3VyczogMSxcbiAgICAgICAgbWludXRlczogMSxcbiAgICAgICAgc2Vjb25kczogMVxuICAgIH07XG4gICAgcHJpdmF0ZSBvblRvdWNoQ2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCA9IG5vb3A7XG4gICAgcHJpdmF0ZSBvbkNoYW5nZUNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQgPSBub29wO1xuICAgIHByaXZhdGUgb25WYWxpZGF0b3JDaGFuZ2U6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCA9IG5vb3A7XG5cbiAgICBwcml2YXRlIGdldCBkYXRlUGFydERlbHRhcygpOiBEYXRlUGFydERlbHRhcyB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9kYXRlUGFydERlbHRhcywgdGhpcy5zcGluRGVsdGEpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IGVtcHR5TWFzaygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXNrUGFyc2VyLmFwcGx5TWFzayhudWxsLCB0aGlzLm1hc2tPcHRpb25zKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCB0YXJnZXREYXRlUGFydCgpOiBEYXRlUGFydCB7XG4gICAgICAgIC8vIFYuSy4gTWF5IDE2dGgsIDIwMjIgIzExNTU0IEdldCBjb3JyZWN0IGRhdGUgcGFydCBpbiBzaGFkb3cgRE9NXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMubmF0aXZlRWxlbWVudCB8fFxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5hY3RpdmVFbGVtZW50Py5zaGFkb3dSb290Py5hY3RpdmVFbGVtZW50ID09PSB0aGlzLm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dERhdGVQYXJ0c1xuICAgICAgICAgICAgICAgIC5maW5kKHAgPT4gcC5zdGFydCA8PSB0aGlzLnNlbGVjdGlvblN0YXJ0ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgPD0gcC5lbmQgJiYgcC50eXBlICE9PSBEYXRlUGFydC5MaXRlcmFsKT8udHlwZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dERhdGVQYXJ0cy5zb21lKHAgPT4gcC50eXBlID09PSBEYXRlUGFydC5EYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5EYXRlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dERhdGVQYXJ0cy5zb21lKHAgPT4gcC50eXBlID09PSBEYXRlUGFydC5Ib3VycykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuSG91cnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBoYXNEYXRlUGFydHMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dERhdGVQYXJ0cy5zb21lKFxuICAgICAgICAgICAgcCA9PiBwLnR5cGUgPT09IERhdGVQYXJ0LkRhdGVcbiAgICAgICAgICAgICAgICB8fCBwLnR5cGUgPT09IERhdGVQYXJ0Lk1vbnRoXG4gICAgICAgICAgICAgICAgfHwgcC50eXBlID09PSBEYXRlUGFydC5ZZWFyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBoYXNUaW1lUGFydHMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dERhdGVQYXJ0cy5zb21lKFxuICAgICAgICAgICAgcCA9PiBwLnR5cGUgPT09IERhdGVQYXJ0LkhvdXJzXG4gICAgICAgICAgICAgICAgfHwgcC50eXBlID09PSBEYXRlUGFydC5NaW51dGVzXG4gICAgICAgICAgICAgICAgfHwgcC50eXBlID09PSBEYXRlUGFydC5TZWNvbmRzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBkYXRlVmFsdWUoKTogRGF0ZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlVmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIG1hc2tQYXJzZXI6IE1hc2tQYXJzaW5nU2VydmljZSxcbiAgICAgICAgcGxhdGZvcm06IFBsYXRmb3JtVXRpbCxcbiAgICAgICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSxcbiAgICAgICAgQEluamVjdChMT0NBTEVfSUQpIHByaXZhdGUgX2xvY2FsZTogYW55KSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnRSZWYsIG1hc2tQYXJzZXIsIHJlbmRlcmVyLCBwbGF0Zm9ybSk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCBhcyBEb2N1bWVudDtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSB0aGlzLmxvY2FsZSB8fCB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignd2hlZWwnLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBvbldoZWVsKGV2ZW50OiBXaGVlbEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5faXNGb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmIChldmVudC5kZWx0YVkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlY3JlbWVudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy51cGRhdGVEZWZhdWx0Rm9ybWF0KCk7XG4gICAgICAgIHRoaXMuc2V0TWFzayh0aGlzLmlucHV0Rm9ybWF0KTtcbiAgICAgICAgdGhpcy51cGRhdGVNYXNrKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xvY2FsZSddICYmICFjaGFuZ2VzWydsb2NhbGUnXS5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVEZWZhdWx0Rm9ybWF0KCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lucHV0Rm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNYXNrKHRoaXMuaW5wdXRGb3JtYXQpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWFzaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydpbnB1dEZvcm1hdCddICYmICFjaGFuZ2VzWydpbnB1dEZvcm1hdCddLmZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hc2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqIENsZWFyIHRoZSBpbnB1dCBlbGVtZW50IHZhbHVlLiAqL1xuICAgIHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25DbGVhciA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgdGhpcy5pbnB1dFZhbHVlLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX29uQ2xlYXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnQgc3BlY2lmaWVkIERhdGVQYXJ0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGVQYXJ0IFRoZSBvcHRpb25hbCBEYXRlUGFydCB0byBpbmNyZW1lbnQuIERlZmF1bHRzIHRvIERhdGUgb3IgSG91cnMgKHdoZW4gRGF0ZSBpcyBhYnNlbnQgZnJvbSB0aGUgaW5wdXRGb3JtYXQgLSBleDonSEg6bW0nKS5cbiAgICAgKiBAcGFyYW0gZGVsdGEgVGhlIG9wdGlvbmFsIGRlbHRhIHRvIGluY3JlbWVudCBieS4gT3ZlcnJpZGVzIGBzcGluRGVsdGFgLlxuICAgICAqL1xuICAgIHB1YmxpYyBpbmNyZW1lbnQoZGF0ZVBhcnQ/OiBEYXRlUGFydCwgZGVsdGE/OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGFydCA9IGRhdGVQYXJ0IHx8IHRoaXMudGFyZ2V0RGF0ZVBhcnQ7XG4gICAgICAgIGlmICghdGFyZ2V0UGFydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy50cnlTcGluVmFsdWUodGFyZ2V0UGFydCwgZGVsdGEpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNyZW1lbnQgc3BlY2lmaWVkIERhdGVQYXJ0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGVQYXJ0IFRoZSBvcHRpb25hbCBEYXRlUGFydCB0byBkZWNyZW1lbnQuIERlZmF1bHRzIHRvIERhdGUgb3IgSG91cnMgKHdoZW4gRGF0ZSBpcyBhYnNlbnQgZnJvbSB0aGUgaW5wdXRGb3JtYXQgLSBleDonSEg6bW0nKS5cbiAgICAgKiBAcGFyYW0gZGVsdGEgVGhlIG9wdGlvbmFsIGRlbHRhIHRvIGRlY3JlbWVudCBieS4gT3ZlcnJpZGVzIGBzcGluRGVsdGFgLlxuICAgICAqL1xuICAgIHB1YmxpYyBkZWNyZW1lbnQoZGF0ZVBhcnQ/OiBEYXRlUGFydCwgZGVsdGE/OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGFydCA9IGRhdGVQYXJ0IHx8IHRoaXMudGFyZ2V0RGF0ZVBhcnQ7XG4gICAgICAgIGlmICghdGFyZ2V0UGFydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy50cnlTcGluVmFsdWUodGFyZ2V0UGFydCwgZGVsdGEsIHRydWUpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2V0RGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVNYXNrKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICAgICAgaWYgKCFjb250cm9sLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnZhbGlkRGF0ZSBoYW5kbGluZ1xuICAgICAgICBpZiAoaXNEYXRlKGNvbnRyb2wudmFsdWUpICYmICFEYXRlVGltZVV0aWwuaXNWYWxpZERhdGUoY29udHJvbC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0cnVlIH07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IHZhbHVlID0gRGF0ZVRpbWVVdGlsLmlzVmFsaWREYXRlKGNvbnRyb2wudmFsdWUpID8gY29udHJvbC52YWx1ZSA6IERhdGVUaW1lVXRpbC5wYXJzZUlzb0RhdGUoY29udHJvbC52YWx1ZSk7XG4gICAgICAgIGNvbnN0IG1pblZhbHVlRGF0ZSA9IERhdGVUaW1lVXRpbC5pc1ZhbGlkRGF0ZSh0aGlzLm1pblZhbHVlKSA/IHRoaXMubWluVmFsdWUgOiB0aGlzLnBhcnNlRGF0ZSh0aGlzLm1pblZhbHVlKTtcbiAgICAgICAgY29uc3QgbWF4VmFsdWVEYXRlID0gRGF0ZVRpbWVVdGlsLmlzVmFsaWREYXRlKHRoaXMubWF4VmFsdWUpID8gdGhpcy5tYXhWYWx1ZSA6IHRoaXMucGFyc2VEYXRlKHRoaXMubWF4VmFsdWUpO1xuICAgICAgICBpZiAobWluVmFsdWVEYXRlIHx8IG1heFZhbHVlRGF0ZSkge1xuICAgICAgICAgICAgZXJyb3JzID0gRGF0ZVRpbWVVdGlsLnZhbGlkYXRlTWluTWF4KHZhbHVlLFxuICAgICAgICAgICAgICAgIG1pblZhbHVlRGF0ZSwgbWF4VmFsdWVEYXRlLFxuICAgICAgICAgICAgICAgIHRoaXMuaGFzVGltZVBhcnRzLCB0aGlzLmhhc0RhdGVQYXJ0cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZXJyb3JzKS5sZW5ndGggPiAwID8gZXJyb3JzIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZT8oZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSA9IGZuO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG92ZXJyaWRlIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblRvdWNoQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgc2V0RGlzYWJsZWRTdGF0ZT8oX2lzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHsgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG92ZXJyaWRlIG9uQ29tcG9zaXRpb25FbmQoKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm9uQ29tcG9zaXRpb25FbmQoKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMucGFyc2VEYXRlKHRoaXMuaW5wdXRWYWx1ZSkpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1hc2soKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25JbnB1dENoYW5nZWQoZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIub25JbnB1dENoYW5nZWQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5fY29tcG9zaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbnB1dElzQ29tcGxldGUoKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IHRoaXMucGFyc2VEYXRlKHRoaXMuaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoRGF0ZVRpbWVVdGlsLmlzVmFsaWREYXRlKHBhcnNlZERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShwYXJzZWREYXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlICYmIG5ldyBEYXRlKHRoaXMuZGF0ZVZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnczogSWd4RGF0ZVRpbWVFZGl0b3JFdmVudEFyZ3MgPSB7IG9sZFZhbHVlLCBuZXdWYWx1ZTogcGFyc2VkRGF0ZSwgdXNlcklucHV0OiB0aGlzLmlucHV0VmFsdWUgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRpb25GYWlsZWQuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZVRpbWVVdGlsLmlzVmFsaWREYXRlKGFyZ3MubmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUoYXJncy5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG92ZXJyaWRlIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5uYXRpdmVFbGVtZW50LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIub25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgY29uc3Qga2V5ID0gZXZlbnQua2V5O1xuXG4gICAgICAgIGlmIChldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgPT09IHRoaXMucGxhdGZvcm0uS0VZTUFQLkFSUk9XX0RPV04gfHwga2V5ID09PSB0aGlzLnBsYXRmb3JtLktFWU1BUC5BUlJPV19VUCkge1xuICAgICAgICAgICAgdGhpcy5zcGluKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIGtleSA9PT0gdGhpcy5wbGF0Zm9ybS5LRVlNQVAuU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKG5ldyBEYXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25Gb2N1cygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubmF0aXZlRWxlbWVudC5yZWFkT25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub25Ub3VjaENhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTWFzaygpO1xuICAgICAgICBzdXBlci5vbkZvY3VzKCk7XG4gICAgICAgIHRoaXMubmF0aXZlRWxlbWVudC5zZWxlY3QoKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25CbHVyKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dElzQ29tcGxldGUoKSAmJiB0aGlzLmlucHV0VmFsdWUgIT09IHRoaXMuZW1wdHlNYXNrKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMucGFyc2VEYXRlKHRoaXMuaW5wdXRWYWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB0aGluayBvZiBhIGJldHRlciB3YXkgdG8gc2V0IGRpc3BsYXlWYWx1ZVBpcGUgaW4gbWFzayBkaXJlY3RpdmVcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheVZhbHVlUGlwZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIub25CbHVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgZGF0ZSBlZGl0b3Igc2V0cyBpdHMgb3duIGlucHV0Rm9ybWF0IGFzIGl0cyBwbGFjZWhvbGRlciBpZiBub25lIGlzIHByb3ZpZGVkXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgc2V0UGxhY2Vob2xkZXIoX3ZhbHVlOiBzdHJpbmcpOiB2b2lkIHsgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVEZWZhdWx0Rm9ybWF0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9kZWZhdWx0SW5wdXRGb3JtYXQgPSBEYXRlVGltZVV0aWwuZ2V0RGVmYXVsdElucHV0Rm9ybWF0KHRoaXMubG9jYWxlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZU1hc2soKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBjdXJzb3IgcG9zaXRpb24gYXMgaXQgd2lsbCBiZSBtb3ZlZCBkdXJpbmcgbWFza2luZ1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0VmFsdWUgPSB0aGlzLmdldE1hc2tlZFZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblJhbmdlKGN1cnNvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGF0ZVZhbHVlIHx8ICFEYXRlVGltZVV0aWwuaXNWYWxpZERhdGUodGhpcy5kYXRlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheVZhbHVlUGlwZSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB3aGVuIGZvcm1hdHRlciBmdW5jIGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0VmFsdWUgPSB0aGlzLmRpc3BsYXlWYWx1ZVBpcGUudHJhbnNmb3JtKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZGlzcGxheUZvcm1hdCB8fCB0aGlzLmlucHV0Rm9ybWF0O1xuICAgICAgICAgICAgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IERhdGVUaW1lVXRpbC5mb3JtYXREYXRlKHRoaXMuZGF0ZVZhbHVlLCBmb3JtYXQucmVwbGFjZSgndHQnLCAnYWEnKSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0VmFsdWUgPSB0aGlzLmRhdGVWYWx1ZS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRNYXNrKGlucHV0Rm9ybWF0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgb2xkRm9ybWF0ID0gdGhpcy5faW5wdXREYXRlUGFydHM/Lm1hcChwID0+IHAuZm9ybWF0KS5qb2luKCcnKTtcbiAgICAgICAgdGhpcy5faW5wdXREYXRlUGFydHMgPSBEYXRlVGltZVV0aWwucGFyc2VEYXRlVGltZUZvcm1hdChpbnB1dEZvcm1hdCk7XG4gICAgICAgIGlucHV0Rm9ybWF0ID0gdGhpcy5faW5wdXREYXRlUGFydHMubWFwKHAgPT4gcC5mb3JtYXQpLmpvaW4oJycpO1xuICAgICAgICBjb25zdCBtYXNrID0gKGlucHV0Rm9ybWF0IHx8IERhdGVUaW1lVXRpbC5ERUZBVUxUX0lOUFVUX0ZPUk1BVClcbiAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoLyg/PVtedF0pW1xcd10vLCAnZycpLCAnMCcpO1xuICAgICAgICB0aGlzLm1hc2sgPSBtYXNrLmluZGV4T2YoJ3R0JykgIT09IC0xID8gbWFzay5yZXBsYWNlKG5ldyBSZWdFeHAoJ3R0JywgJ2cnKSwgJ0xMJykgOiBtYXNrO1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5uYXRpdmVFbGVtZW50LnBsYWNlaG9sZGVyO1xuICAgICAgICBpZiAoIXBsYWNlaG9sZGVyIHx8IG9sZEZvcm1hdCA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMubmF0aXZlRWxlbWVudCwgJ3BsYWNlaG9sZGVyJywgaW5wdXRGb3JtYXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZURhdGUodmFsOiBzdHJpbmcpOiBEYXRlIHwgbnVsbCB7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEYXRlVGltZVV0aWwucGFyc2VWYWx1ZUZyb21NYXNrKHZhbCwgdGhpcy5faW5wdXREYXRlUGFydHMsIHRoaXMucHJvbXB0Q2hhcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRNYXNrZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBsZXQgbWFzayA9IHRoaXMuZW1wdHlNYXNrO1xuICAgICAgICBpZiAoRGF0ZVRpbWVVdGlsLmlzVmFsaWREYXRlKHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5faW5wdXREYXRlUGFydHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBEYXRlUGFydC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRoaXMuZ2V0UGFydFZhbHVlKHBhcnQsIHBhcnQuZm9ybWF0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbWFzayA9IHRoaXMubWFza1BhcnNlci5yZXBsYWNlSW5NYXNrKG1hc2ssIHRhcmdldFZhbHVlLCB0aGlzLm1hc2tPcHRpb25zLCBwYXJ0LnN0YXJ0LCBwYXJ0LmVuZCkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFzaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRJc0NvbXBsZXRlKCkgfHwgIXRoaXMuX29uQ2xlYXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hc2s7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIHZhbHVlSW5SYW5nZSh2YWx1ZTogRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IG1pblZhbHVlRGF0ZSA9IERhdGVUaW1lVXRpbC5pc1ZhbGlkRGF0ZSh0aGlzLm1pblZhbHVlKSA/IHRoaXMubWluVmFsdWUgOiB0aGlzLnBhcnNlRGF0ZSh0aGlzLm1pblZhbHVlKTtcbiAgICAgICAgY29uc3QgbWF4VmFsdWVEYXRlID0gRGF0ZVRpbWVVdGlsLmlzVmFsaWREYXRlKHRoaXMubWF4VmFsdWUpID8gdGhpcy5tYXhWYWx1ZSA6IHRoaXMucGFyc2VEYXRlKHRoaXMubWF4VmFsdWUpO1xuICAgICAgICBpZiAobWluVmFsdWVEYXRlIHx8IG1heFZhbHVlRGF0ZSkge1xuICAgICAgICAgICAgZXJyb3JzID0gRGF0ZVRpbWVVdGlsLnZhbGlkYXRlTWluTWF4KHZhbHVlLFxuICAgICAgICAgICAgICAgIHRoaXMubWluVmFsdWUsIHRoaXMubWF4VmFsdWUsXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNUaW1lUGFydHMsIHRoaXMuaGFzRGF0ZVBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNwaW5WYWx1ZShkYXRlUGFydDogRGF0ZVBhcnQsIGRlbHRhOiBudW1iZXIpOiBEYXRlIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGVWYWx1ZSB8fCAhRGF0ZVRpbWVVdGlsLmlzVmFsaWREYXRlKHRoaXMuZGF0ZVZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZVZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIHN3aXRjaCAoZGF0ZVBhcnQpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuRGF0ZTpcbiAgICAgICAgICAgICAgICBEYXRlVGltZVV0aWwuc3BpbkRhdGUoZGVsdGEsIG5ld0RhdGUsIHRoaXMuc3Bpbkxvb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5Nb250aDpcbiAgICAgICAgICAgICAgICBEYXRlVGltZVV0aWwuc3Bpbk1vbnRoKGRlbHRhLCBuZXdEYXRlLCB0aGlzLnNwaW5Mb29wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuWWVhcjpcbiAgICAgICAgICAgICAgICBEYXRlVGltZVV0aWwuc3BpblllYXIoZGVsdGEsIG5ld0RhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5Ib3VyczpcbiAgICAgICAgICAgICAgICBEYXRlVGltZVV0aWwuc3BpbkhvdXJzKGRlbHRhLCBuZXdEYXRlLCB0aGlzLnNwaW5Mb29wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuTWludXRlczpcbiAgICAgICAgICAgICAgICBEYXRlVGltZVV0aWwuc3Bpbk1pbnV0ZXMoZGVsdGEsIG5ld0RhdGUsIHRoaXMuc3Bpbkxvb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5TZWNvbmRzOlxuICAgICAgICAgICAgICAgIERhdGVUaW1lVXRpbC5zcGluU2Vjb25kcyhkZWx0YSwgbmV3RGF0ZSwgdGhpcy5zcGluTG9vcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0LkFtUG06XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0UGFydCA9IHRoaXMuX2lucHV0RGF0ZVBhcnRzLmZpbmQoZHAgPT4gZHAudHlwZSA9PT0gRGF0ZVBhcnQuQW1QbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYW1QbUZyb21NYXNrID0gdGhpcy5pbnB1dFZhbHVlLnN1YnN0cmluZyhmb3JtYXRQYXJ0LnN0YXJ0LCBmb3JtYXRQYXJ0LmVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVUaW1lVXRpbC5zcGluQW1QbShuZXdEYXRlLCB0aGlzLmRhdGVWYWx1ZSwgYW1QbUZyb21NYXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdEYXRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgdHJ5U3BpblZhbHVlKGRhdGVQYXJ0OiBEYXRlUGFydCwgZGVsdGE/OiBudW1iZXIsIG5lZ2F0aXZlID0gZmFsc2UpOiBEYXRlIHtcbiAgICAgICAgaWYgKCFkZWx0YSkge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCB0byAxIGlmIGEgZGVsdGEgaXMgc2V0IHRvIDAgb3IgYW55IG90aGVyIGZhbHN5IHZhbHVlXG4gICAgICAgICAgICBkZWx0YSA9IHRoaXMuZGF0ZVBhcnREZWx0YXNbZGF0ZVBhcnRdIHx8IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BpblZhbHVlID0gbmVnYXRpdmUgPyAtTWF0aC5hYnMoZGVsdGEpIDogTWF0aC5hYnMoZGVsdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGluVmFsdWUoZGF0ZVBhcnQsIHNwaW5WYWx1ZSkgfHwgbmV3IERhdGUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldERhdGVWYWx1ZSh2YWx1ZTogRGF0ZSB8IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLl9kYXRlVmFsdWUgPSBEYXRlVGltZVV0aWwuaXNWYWxpZERhdGUodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IERhdGVUaW1lVXRpbC5wYXJzZUlzb0RhdGUodmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVmFsdWUobmV3RGF0ZTogRGF0ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbGRWYWx1ZSA9IHRoaXMuZGF0ZVZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3RGF0ZTtcblxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgZW1pdCBldmVudHMgaGVyZT9cbiAgICAgICAgaWYgKHRoaXMuaW5wdXRJc0NvbXBsZXRlKCkgfHwgdGhpcy5pbnB1dFZhbHVlID09PSB0aGlzLmVtcHR5TWFzaykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuZGF0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRlVmFsdWUgJiYgIXRoaXMudmFsdWVJblJhbmdlKHRoaXMuZGF0ZVZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0aW9uRmFpbGVkLmVtaXQoeyBvbGRWYWx1ZTogdGhpcy5fb2xkVmFsdWUsIG5ld1ZhbHVlOiB0aGlzLmRhdGVWYWx1ZSwgdXNlcklucHV0OiB0aGlzLmlucHV0VmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHRvVHdlbHZlSG91ckZvcm1hdCh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGhvdXIgPSBwYXJzZUludCh2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5wcm9tcHRDaGFyLCAnZycpLCAnMCcpLCAxMCk7XG4gICAgICAgIGlmIChob3VyID4gMTIpIHtcbiAgICAgICAgICAgIGhvdXIgLT0gMTI7XG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgaG91ciA9IDEyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRQYXJ0VmFsdWUoZGF0ZVBhcnRJbmZvOiBEYXRlUGFydEluZm8sIHBhcnRMZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIGxldCBtYXNrZWRWYWx1ZTtcbiAgICAgICAgY29uc3QgZGF0ZVBhcnQgPSBkYXRlUGFydEluZm8udHlwZTtcbiAgICAgICAgc3dpdGNoIChkYXRlUGFydCkge1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5EYXRlOlxuICAgICAgICAgICAgICAgIG1hc2tlZFZhbHVlID0gdGhpcy5kYXRlVmFsdWUuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5Nb250aDpcbiAgICAgICAgICAgICAgICAvLyBtb250aHMgYXJlIHplcm8gYmFzZWRcbiAgICAgICAgICAgICAgICBtYXNrZWRWYWx1ZSA9IHRoaXMuZGF0ZVZhbHVlLmdldE1vbnRoKCkgKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5ZZWFyOlxuICAgICAgICAgICAgICAgIGlmIChwYXJ0TGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc2tlZFZhbHVlID0gdGhpcy5wcmVwZW5kVmFsdWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludCh0aGlzLmRhdGVWYWx1ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAxMCksIHBhcnRMZW5ndGgsICcwJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFza2VkVmFsdWUgPSB0aGlzLmRhdGVWYWx1ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuSG91cnM6XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVQYXJ0SW5mby5mb3JtYXQuaW5kZXhPZignaCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXNrZWRWYWx1ZSA9IHRoaXMucHJlcGVuZFZhbHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b1R3ZWx2ZUhvdXJGb3JtYXQodGhpcy5kYXRlVmFsdWUuZ2V0SG91cnMoKS50b1N0cmluZygpKSwgcGFydExlbmd0aCwgJzAnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXNrZWRWYWx1ZSA9IHRoaXMuZGF0ZVZhbHVlLmdldEhvdXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5NaW51dGVzOlxuICAgICAgICAgICAgICAgIG1hc2tlZFZhbHVlID0gdGhpcy5kYXRlVmFsdWUuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5TZWNvbmRzOlxuICAgICAgICAgICAgICAgIG1hc2tlZFZhbHVlID0gdGhpcy5kYXRlVmFsdWUuZ2V0U2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5BbVBtOlxuICAgICAgICAgICAgICAgIG1hc2tlZFZhbHVlID0gdGhpcy5kYXRlVmFsdWUuZ2V0SG91cnMoKSA+PSAxMiA/ICdQTScgOiAnQU0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGVQYXJ0SW5mby50eXBlICE9PSBEYXRlUGFydC5BbVBtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVwZW5kVmFsdWUobWFza2VkVmFsdWUsIHBhcnRMZW5ndGgsICcwJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFza2VkVmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmVwZW5kVmFsdWUodmFsdWU6IG51bWJlciwgcGFydExlbmd0aDogbnVtYmVyLCBwcmVwZW5kQ2hhcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIChwcmVwZW5kQ2hhciArIHZhbHVlLnRvU3RyaW5nKCkpLnNsaWNlKC1wYXJ0TGVuZ3RoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNwaW4oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5wbGF0Zm9ybS5LRVlNQVAuQVJST1dfVVA6XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5wbGF0Zm9ybS5LRVlNQVAuQVJST1dfRE9XTjpcbiAgICAgICAgICAgICAgICB0aGlzLmRlY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnB1dElzQ29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0VmFsdWUuaW5kZXhPZih0aGlzLnByb21wdENoYXIpID09PSAtMTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVDdXJzb3IoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgY2FzZSB0aGlzLnBsYXRmb3JtLktFWU1BUC5BUlJPV19MRUZUOlxuICAgICAgICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5nZXROZXdQb3NpdGlvbih2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5wbGF0Zm9ybS5LRVlNQVAuQVJST1dfUklHSFQ6XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLmdldE5ld1Bvc2l0aW9uKHZhbHVlLCAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgY3Vyc29yIGluIGEgc3BlY2lmaWMgZGlyZWN0aW9uIHVudGlsIGl0IHJlYWNoZXMgYSBkYXRlL3RpbWUgc2VwYXJhdG9yLlxuICAgICAqIFRoZW4gcmV0dXJuIGl0cyBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIGl0IG9wZXJhdGVzIG9uLlxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb24gMCBpcyBsZWZ0LCAxIGlzIHJpZ2h0LiBEZWZhdWx0IGlzIDAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXROZXdQb3NpdGlvbih2YWx1ZTogc3RyaW5nLCBkaXJlY3Rpb24gPSAwKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSB0aGlzLl9pbnB1dERhdGVQYXJ0cy5maWx0ZXIocCA9PiBwLnR5cGUgPT09IERhdGVQYXJ0LkxpdGVyYWwpO1xuICAgICAgICBsZXQgY3Vyc29yUG9zID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjdXJzb3JQb3MgPSBjdXJzb3JQb3MgPiAwID8gLS1jdXJzb3JQb3MgOiBjdXJzb3JQb3M7XG4gICAgICAgICAgICB9IHdoaWxlICghbGl0ZXJhbHMuc29tZShsID0+IGwuZW5kID09PSBjdXJzb3JQb3MpICYmIGN1cnNvclBvcyA+IDApO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnNvclBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjdXJzb3JQb3MrKztcbiAgICAgICAgICAgIH0gd2hpbGUgKCFsaXRlcmFscy5zb21lKGwgPT4gbC5zdGFydCA9PT0gY3Vyc29yUG9zKSAmJiBjdXJzb3JQb3MgPCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnNvclBvcztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4iXX0=