import { Directive, HostBinding, Input, booleanAttribute } from '@angular/core';
import { mkenum } from '../../core/utils';
import * as i0 from "@angular/core";
export const IgxDividerType = /*@__PURE__*/ mkenum({
    SOLID: 'solid',
    DASHED: 'dashed'
});
let NEXT_ID = 0;
export class IgxDividerDirective {
    constructor() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = `igx-divider-${NEXT_ID++}`;
        /**
         * Sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.SOLID;
        /**
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * Sets the divider in vertical orientation.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
        /**
         * Sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
    }
    get isDashed() {
        return this.type === IgxDividerType.DASHED;
    }
    /**
     * Sets the inset of the divider from the side(s).
     * If the divider attribute `middle` is set to `true`,
     * it will inset the divider on both sides.
     * ```typescript
     * this.divider.inset = '32px';
     * ```
     */
    set inset(value) {
        this._inset = value;
    }
    /**
     * Gets the current divider inset in terms of
     * inset-inline-start representation as applied to the divider.
     * ```typescript
     * const inset = this.divider.inset;
     * ```
     */
    get inset() {
        return this._inset;
    }
    /**
     * A getter that returns `true` if the type of the divider is `default`;
     * ```typescript
     * const isDefault = this.divider.isDefault;
     * ```
     */
    get isSolid() {
        return this.type === IgxDividerType.SOLID;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxDividerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.2.4", type: IgxDividerDirective, isStandalone: true, selector: "igx-divider", inputs: { id: "id", role: "role", type: "type", middle: ["middle", "middle", booleanAttribute], vertical: ["vertical", "vertical", booleanAttribute], _inset: ["inset", "_inset"] }, host: { properties: { "attr.id": "this.id", "attr.role": "this.role", "class.igx-divider": "this.type", "class.igx-divider--dashed": "this.isDashed", "class.igx-divider--inset": "this.middle", "class.igx-divider--vertical": "this.vertical", "style.--inset": "this.inset" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxDividerDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'igx-divider',
                    standalone: true
                }]
        }], propDecorators: { id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }, {
                type: Input
            }], type: [{
                type: HostBinding,
                args: ['class.igx-divider']
            }, {
                type: Input
            }], isDashed: [{
                type: HostBinding,
                args: ['class.igx-divider--dashed']
            }], middle: [{
                type: HostBinding,
                args: ['class.igx-divider--inset']
            }, {
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], vertical: [{
                type: HostBinding,
                args: ['class.igx-divider--vertical']
            }, {
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], inset: [{
                type: HostBinding,
                args: ['style.--inset']
            }], _inset: [{
                type: Input,
                args: ['inset']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGl2aWRlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGlyZWN0aXZlcy9kaXZpZGVyL2RpdmlkZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7O0FBRTFDLE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxhQUFhLENBQUEsTUFBTSxDQUFDO0lBQzlDLEtBQUssRUFBRSxPQUFPO0lBQ2QsTUFBTSxFQUFFLFFBQVE7Q0FDbkIsQ0FBQyxDQUFDO0FBR0gsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBT2hCLE1BQU0sT0FBTyxtQkFBbUI7SUFMaEM7UUFNSTs7Ozs7Ozs7O1dBU0c7UUFHSSxPQUFFLEdBQUcsZUFBZSxPQUFPLEVBQUUsRUFBRSxDQUFDO1FBRXZDOzs7V0FHRztRQUdJLFNBQUksR0FBRyxXQUFXLENBQUM7UUFFMUI7Ozs7OztXQU1HO1FBR0ksU0FBSSxHQUE0QixjQUFjLENBQUMsS0FBSyxDQUFDO1FBTzVEOzs7Ozs7V0FNRztRQUdJLFdBQU0sR0FBRyxLQUFLLENBQUM7UUFFdEI7Ozs7O1dBS0c7UUFHSSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBMEJ4Qjs7Ozs7O1dBTUc7UUFFSyxXQUFNLEdBQUcsR0FBRyxDQUFDO0tBWXhCO0lBdEVHLElBQ1csUUFBUTtRQUNmLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxjQUFjLENBQUMsTUFBTSxDQUFDO0lBQy9DLENBQUM7SUF1QkQ7Ozs7Ozs7T0FPRztJQUNILElBQ1csS0FBSyxDQUFDLEtBQWE7UUFDMUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILElBQVcsS0FBSztRQUNaLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUN2QixDQUFDO0lBWUQ7Ozs7O09BS0c7SUFDSCxJQUFXLE9BQU87UUFDZCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssY0FBYyxDQUFDLEtBQUssQ0FBQztJQUM5QyxDQUFDOzhHQXRHUSxtQkFBbUI7a0dBQW5CLG1CQUFtQiw0SEErQ1IsZ0JBQWdCLHNDQVVoQixnQkFBZ0I7OzJGQXpEM0IsbUJBQW1CO2tCQUwvQixTQUFTO21CQUFDO29CQUNQLDhEQUE4RDtvQkFDOUQsUUFBUSxFQUFFLGFBQWE7b0JBQ3ZCLFVBQVUsRUFBRSxJQUFJO2lCQUNuQjs4QkFjVSxFQUFFO3NCQUZSLFdBQVc7dUJBQUMsU0FBUzs7c0JBQ3JCLEtBQUs7Z0JBU0MsSUFBSTtzQkFGVixXQUFXO3VCQUFDLFdBQVc7O3NCQUN2QixLQUFLO2dCQVlDLElBQUk7c0JBRlYsV0FBVzt1QkFBQyxtQkFBbUI7O3NCQUMvQixLQUFLO2dCQUlLLFFBQVE7c0JBRGxCLFdBQVc7dUJBQUMsMkJBQTJCO2dCQWNqQyxNQUFNO3NCQUZaLFdBQVc7dUJBQUMsMEJBQTBCOztzQkFDdEMsS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRTtnQkFXL0IsUUFBUTtzQkFGZCxXQUFXO3VCQUFDLDZCQUE2Qjs7c0JBQ3pDLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBWTNCLEtBQUs7c0JBRGYsV0FBVzt1QkFBQyxlQUFlO2dCQXdCcEIsTUFBTTtzQkFEYixLQUFLO3VCQUFDLE9BQU8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RCaW5kaW5nLCBJbnB1dCwgYm9vbGVhbkF0dHJpYnV0ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbWtlbnVtIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5cbmV4cG9ydCBjb25zdCBJZ3hEaXZpZGVyVHlwZSA9IC8qQF9fUFVSRV9fKi9ta2VudW0oe1xuICAgIFNPTElEOiAnc29saWQnLFxuICAgIERBU0hFRDogJ2Rhc2hlZCdcbn0pO1xuZXhwb3J0IHR5cGUgSWd4RGl2aWRlclR5cGUgPSAodHlwZW9mIElneERpdmlkZXJUeXBlKVtrZXlvZiB0eXBlb2YgSWd4RGl2aWRlclR5cGVdO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG5cbkBEaXJlY3RpdmUoe1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvZGlyZWN0aXZlLXNlbGVjdG9yXG4gICAgc2VsZWN0b3I6ICdpZ3gtZGl2aWRlcicsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hEaXZpZGVyRGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGBpZGAgb2YgdGhlIGRpdmlkZXIuXG4gICAgICogSWYgbm90IHNldCwgYGlkYCB3aWxsIGhhdmUgdmFsdWUgYFwiaWd4LWRpdmlkZXItMFwiYDtcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIGlkPVwibXktZGl2aWRlclwiPjwvaWd4LWRpdmlkZXI+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBkaXZpZGVySWQgPSAgdGhpcy5kaXZpZGVyLmlkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LWRpdmlkZXItJHtORVhUX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGByb2xlYCBhdHRyaWJ1dGUuXG4gICAgICogSWYgbm90IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBzZXBhcmF0b3JgIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcm9sZSA9ICdzZXBhcmF0b3InO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdHlwZSBvZiB0aGUgZGl2aWRlci4gVGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBpcyBgZGVmYXVsdGAuIFRoZSBkaXZpZGVyIGNhbiBhbHNvIGJlIGBkYXNoZWRgO1xuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWRpdmlkZXIgdHlwZT1cImRhc2hlZFwiPjwvaWd4LWRpdmlkZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZGl2aWRlcicpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdHlwZTogSWd4RGl2aWRlclR5cGUgfCBzdHJpbmcgPSBJZ3hEaXZpZGVyVHlwZS5TT0xJRDtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWRpdmlkZXItLWRhc2hlZCcpXG4gICAgcHVibGljIGdldCBpc0Rhc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4RGl2aWRlclR5cGUuREFTSEVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byBgdHJ1ZWAgYW5kIGFuIGBpbnNldGAgdmFsdWUgaGFzIGJlZW4gcHJvdmlkZWQsXG4gICAgICogdGhlIGRpdmlkZXIgd2lsbCBzdGFydCBzaHJpbmtpbmcgZnJvbSBib3RoIGVuZHMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZGl2aWRlciBbbWlkZGxlXT1cInRydWVcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWRpdmlkZXItLWluc2V0JylcbiAgICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgICBwdWJsaWMgbWlkZGxlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkaXZpZGVyIGluIHZlcnRpY2FsIG9yaWVudGF0aW9uLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWRpdmlkZXIgW3ZlcnRpY2FsXT1cInRydWVcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWRpdmlkZXItLXZlcnRpY2FsJylcbiAgICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgICBwdWJsaWMgdmVydGljYWwgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluc2V0IG9mIHRoZSBkaXZpZGVyIGZyb20gdGhlIHNpZGUocykuXG4gICAgICogSWYgdGhlIGRpdmlkZXIgYXR0cmlidXRlIGBtaWRkbGVgIGlzIHNldCB0byBgdHJ1ZWAsXG4gICAgICogaXQgd2lsbCBpbnNldCB0aGUgZGl2aWRlciBvbiBib3RoIHNpZGVzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmRpdmlkZXIuaW5zZXQgPSAnMzJweCc7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS4tLWluc2V0JylcbiAgICBwdWJsaWMgc2V0IGluc2V0KHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5faW5zZXQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGRpdmlkZXIgaW5zZXQgaW4gdGVybXMgb2ZcbiAgICAgKiBpbnNldC1pbmxpbmUtc3RhcnQgcmVwcmVzZW50YXRpb24gYXMgYXBwbGllZCB0byB0aGUgZGl2aWRlci5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaW5zZXQgPSB0aGlzLmRpdmlkZXIuaW5zZXQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBpbnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaW5zZXRgIGF0dHJpYnV0ZS5cbiAgICAgKiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBzZXQgdG8gYCcwJ2AuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZGl2aWRlciBpbnNldD1cIjE2cHhcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaW5zZXQnKVxuICAgIHByaXZhdGUgX2luc2V0ID0gJzAnO1xuXG4gICAgLyoqXG4gICAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHlwZSBvZiB0aGUgZGl2aWRlciBpcyBgZGVmYXVsdGA7XG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGlzRGVmYXVsdCA9IHRoaXMuZGl2aWRlci5pc0RlZmF1bHQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBpc1NvbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBJZ3hEaXZpZGVyVHlwZS5TT0xJRDtcbiAgICB9XG5cbn1cblxuXG4iXX0=