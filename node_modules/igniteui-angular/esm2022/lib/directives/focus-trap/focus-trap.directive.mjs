import { Directive, Input, booleanAttribute } from '@angular/core';
import { fromEvent, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../core/utils";
export class IgxFocusTrapDirective {
    /** @hidden */
    get element() {
        return this.elementRef.nativeElement;
    }
    /** @hidden */
    constructor(elementRef, platformUtil) {
        this.elementRef = elementRef;
        this.platformUtil = platformUtil;
        this.destroy$ = new Subject();
        this._focusTrap = true;
    }
    /**
     * Sets whether the Tab key focus is trapped within the element.
     *
     * @example
     * ```html
     * <div igxFocusTrap="true"></div>
     * ```
     */
    set focusTrap(focusTrap) {
        this._focusTrap = focusTrap;
    }
    /** @hidden */
    get focusTrap() {
        return this._focusTrap;
    }
    /** @hidden */
    ngAfterViewInit() {
        fromEvent(this.element, 'keydown')
            .pipe(takeUntil(this.destroy$))
            .subscribe((event) => {
            if (this._focusTrap && event.key === this.platformUtil.KEYMAP.TAB) {
                this.handleTab(event);
            }
        });
    }
    /** @hidden */
    ngOnDestroy() {
        this.destroy$.complete();
    }
    handleTab(event) {
        const elements = this.getFocusableElements(this.element);
        if (elements.length > 0) {
            const focusedElement = this.getFocusedElement();
            const focusedElementIndex = elements.findIndex((element) => element === focusedElement);
            const direction = event.shiftKey ? -1 : 1;
            let nextFocusableElementIndex = focusedElementIndex + direction;
            if (nextFocusableElementIndex < 0) {
                nextFocusableElementIndex = elements.length - 1;
            }
            if (nextFocusableElementIndex >= elements.length) {
                nextFocusableElementIndex = 0;
            }
            elements[nextFocusableElementIndex].focus();
        }
        else {
            this.element.focus();
        }
        event.preventDefault();
    }
    getFocusableElements(element) {
        return Array.from(element.querySelectorAll('a[href], button, input, textarea, select, details,[tabindex]:not([tabindex="-1"])')).filter(el => !el.hasAttribute('disabled') && !el.getAttribute('aria-hidden'));
    }
    getFocusedElement() {
        let activeElement = typeof document !== 'undefined' && document
            ? document.activeElement
            : null;
        while (activeElement && activeElement.shadowRoot) {
            const newActiveElement = activeElement.shadowRoot.activeElement;
            if (newActiveElement === activeElement) {
                break;
            }
            else {
                activeElement = newActiveElement;
            }
        }
        return activeElement;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxFocusTrapDirective, deps: [{ token: i0.ElementRef }, { token: i1.PlatformUtil }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.2.4", type: IgxFocusTrapDirective, isStandalone: true, selector: "[igxFocusTrap]", inputs: { focusTrap: ["igxFocusTrap", "focusTrap", booleanAttribute] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxFocusTrapDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxFocusTrap]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.PlatformUtil }], propDecorators: { focusTrap: [{
                type: Input,
                args: [{ alias: 'igxFocusTrap', transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9jdXMtdHJhcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGlyZWN0aXZlcy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBaUIsU0FBUyxFQUFjLEtBQUssRUFBYSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6RyxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMxQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQU8zQyxNQUFNLE9BQU8scUJBQXFCO0lBQzlCLGNBQWM7SUFDZCxJQUFXLE9BQU87UUFDZCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO0lBQ3pDLENBQUM7SUFLRCxjQUFjO0lBQ2QsWUFDWSxVQUFzQixFQUNwQixZQUEwQjtRQUQ1QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3BCLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBTmhDLGFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQ3pCLGVBQVUsR0FBRyxJQUFJLENBQUM7SUFNMUIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxJQUNXLFNBQVMsQ0FBQyxTQUFrQjtRQUNuQyxJQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztJQUNoQyxDQUFDO0lBRUQsY0FBYztJQUNkLElBQVcsU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDM0IsQ0FBQztJQUVELGNBQWM7SUFDUCxlQUFlO1FBQ2xCLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQzthQUM3QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM5QixT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aXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBPbkRlc3Ryb3ksIGJvb2xlYW5BdHRyaWJ1dGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUGxhdGZvcm1VdGlsIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneEZvY3VzVHJhcF0nLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4Rm9jdXNUcmFwRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBnZXQgZWxlbWVudCgpOiBIVE1MRWxlbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgcHJpdmF0ZSBfZm9jdXNUcmFwID0gdHJ1ZTtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJvdGVjdGVkIHBsYXRmb3JtVXRpbDogUGxhdGZvcm1VdGlsKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBUYWIga2V5IGZvY3VzIGlzIHRyYXBwZWQgd2l0aGluIHRoZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hGb2N1c1RyYXA9XCJ0cnVlXCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KHsgYWxpYXM6ICdpZ3hGb2N1c1RyYXAnLCB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgICBwdWJsaWMgc2V0IGZvY3VzVHJhcChmb2N1c1RyYXA6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZm9jdXNUcmFwID0gZm9jdXNUcmFwO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdldCBmb2N1c1RyYXAoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb2N1c1RyYXA7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBmcm9tRXZlbnQodGhpcy5lbGVtZW50LCAna2V5ZG93bicpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mb2N1c1RyYXAgJiYgZXZlbnQua2V5ID09PSB0aGlzLnBsYXRmb3JtVXRpbC5LRVlNQVAuVEFCKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVGFiKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlVGFiKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5nZXRGb2N1c2FibGVFbGVtZW50cyh0aGlzLmVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZm9jdXNlZEVsZW1lbnQgPSB0aGlzLmdldEZvY3VzZWRFbGVtZW50KCk7XG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkRWxlbWVudEluZGV4ID0gZWxlbWVudHMuZmluZEluZGV4KChlbGVtZW50KSA9PiBlbGVtZW50IGFzIEhUTUxFbGVtZW50ID09PSBmb2N1c2VkRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5zaGlmdEtleSA/IC0xIDogMTtcbiAgICAgICAgICAgIGxldCBuZXh0Rm9jdXNhYmxlRWxlbWVudEluZGV4ID0gZm9jdXNlZEVsZW1lbnRJbmRleCArIGRpcmVjdGlvbjtcbiAgICAgICAgICAgIGlmIChuZXh0Rm9jdXNhYmxlRWxlbWVudEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIG5leHRGb2N1c2FibGVFbGVtZW50SW5kZXggPSBlbGVtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRGb2N1c2FibGVFbGVtZW50SW5kZXggPj0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV4dEZvY3VzYWJsZUVsZW1lbnRJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoZWxlbWVudHNbbmV4dEZvY3VzYWJsZUVsZW1lbnRJbmRleF0gYXMgSFRNTEVsZW1lbnQpLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGb2N1c2FibGVFbGVtZW50cyhlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICAgICdhW2hyZWZdLCBidXR0b24sIGlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0LCBkZXRhaWxzLFt0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKSdcbiAgICAgICAgKSkuZmlsdGVyKGVsID0+ICFlbC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgJiYgIWVsLmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGb2N1c2VkRWxlbWVudCgpOiBIVE1MRWxlbWVudCB8IG51bGwge1xuICAgICAgICBsZXQgYWN0aXZlRWxlbWVudCA9XG4gICAgICAgICAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgPyAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IG51bGwpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIHdoaWxlIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgY29uc3QgbmV3QWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdBY3RpdmVFbGVtZW50ID09PSBhY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBuZXdBY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxufVxuIl19