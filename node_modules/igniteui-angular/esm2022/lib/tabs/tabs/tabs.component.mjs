import { Component, HostBinding, Inject, Input, ViewChild } from '@angular/core';
import { getResizeObserver, mkenum } from '../../core/utils';
import { IgxAngularAnimationService } from '../../services/animation/angular-animation-service';
import { IgxTabsBase } from '../tabs.base';
import { IgxTabsDirective } from '../tabs.directive';
import { NgClass, NgFor, NgTemplateOutlet, NgIf } from '@angular/common';
import { IgxIconComponent } from '../../icon/icon.component';
import { IgxRippleDirective } from '../../directives/ripple/ripple.directive';
import * as i0 from "@angular/core";
import * as i1 from "../../services/direction/directionality";
export const IgxTabsAlignment = /*@__PURE__*/ mkenum({
    start: 'start',
    end: 'end',
    center: 'center',
    justify: 'justify'
});
/** @hidden */
let NEXT_TAB_ID = 0;
/**
 * Tabs component is used to organize or switch between similar data sets.
 *
 * @igxModule IgxTabsModule
 *
 * @igxTheme igx-tabs-theme
 *
 * @igxKeywords tabs
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI for Angular Tabs component places tabs at the top and allows for scrolling when there are multiple tab items on the screen.
 *
 * @example
 * ```html
 * <igx-tabs>
 *     <igx-tab-item>
 *         <igx-tab-header>
 *             <igx-icon igxTabHeaderIcon>folder</igx-icon>
 *             <span igxTabHeaderLabel>Tab 1</span>
 *         </igx-tab-header>
 *         <igx-tab-content>
 *             Content 1
 *         </igx-tab-content>
 *     </igx-tab-item>
 *     ...
 * </igx-tabs>
 * ```
 */
export class IgxTabsComponent extends IgxTabsDirective {
    /**
     * Gets/Sets the tab alignment. Defaults to `start`.
     */
    get tabAlignment() {
        return this._tabAlignment;
    }
    set tabAlignment(value) {
        this._tabAlignment = value;
        requestAnimationFrame(() => {
            this.updateScrollButtons();
            this.realignSelectedIndicator();
        });
    }
    constructor(animationService, cdr, ngZone, dir) {
        super(animationService, cdr, dir);
        this.ngZone = ngZone;
        /** @hidden */
        this.defaultClass = true;
        /**  @hidden */
        this.offset = 0;
        /** @hidden */
        this.componentName = 'igx-tabs';
        this._tabAlignment = 'start';
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver = new (getResizeObserver())(() => {
                this.updateScrollButtons();
                this.realignSelectedIndicator();
            });
            this._resizeObserver.observe(this.headerContainer.nativeElement);
            this._resizeObserver.observe(this.viewPort.nativeElement);
        });
    }
    /** @hidden @internal */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver?.disconnect();
        });
    }
    /** @hidden */
    scrollPrev() {
        this.scroll(false);
    }
    /** @hidden */
    scrollNext() {
        this.scroll(true);
    }
    /** @hidden */
    realignSelectedIndicator() {
        if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {
            const header = this.items.get(this.selectedIndex).headerComponent.nativeElement;
            this.alignSelectedIndicator(header, 0);
        }
    }
    /** @hidden */
    resolveHeaderScrollClasses() {
        return {
            'igx-tabs__header-scroll--start': this.tabAlignment === 'start',
            'igx-tabs__header-scroll--end': this.tabAlignment === 'end',
            'igx-tabs__header-scroll--center': this.tabAlignment === 'center',
            'igx-tabs__header-scroll--justify': this.tabAlignment === 'justify',
        };
    }
    /** @hidden */
    scrollTabHeaderIntoView() {
        if (this.selectedIndex >= 0) {
            const tabItems = this.items.toArray();
            const tabHeaderNativeElement = tabItems[this.selectedIndex].headerComponent.nativeElement;
            // Scroll left if there is need
            if (this.getElementOffset(tabHeaderNativeElement) < this.offset) {
                this.scrollElement(tabHeaderNativeElement, false);
            }
            // Scroll right if there is need
            const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
            const delta = (this.getElementOffset(tabHeaderNativeElement) + tabHeaderNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
            // Fix for IE 11, a difference is accumulated from the widths calculations
            if (delta > 1) {
                this.scrollElement(tabHeaderNativeElement, true);
            }
            this.alignSelectedIndicator(tabHeaderNativeElement);
        }
        else {
            this.hideSelectedIndicator();
        }
    }
    /** @hidden */
    getNextTabId() {
        return NEXT_TAB_ID++;
    }
    /** @hidden */
    onItemChanges() {
        super.onItemChanges();
        Promise.resolve().then(() => {
            this.updateScrollButtons();
        });
    }
    alignSelectedIndicator(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    hideSelectedIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
    scroll(scrollNext) {
        const tabsArray = this.items.toArray();
        for (let index = 0; index < tabsArray.length; index++) {
            const tab = tabsArray[index];
            const element = tab.headerComponent.nativeElement;
            if (scrollNext) {
                if (element.offsetWidth + this.getElementOffset(element) > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollNext);
                    break;
                }
            }
            else {
                if (this.getElementOffset(element) >= this.offset) {
                    this.scrollElement(tabsArray[index - 1].headerComponent.nativeElement, scrollNext);
                    break;
                }
            }
        }
    }
    scrollElement(element, scrollNext) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollNext) ? element.offsetWidth + this.getElementOffset(element) - viewPortWidth : this.getElementOffset(element);
        this.viewPort.nativeElement.scrollLeft = this.getOffset(this.offset);
        this.updateScrollButtons();
    }
    updateScrollButtons() {
        const itemsContainerWidth = this.getTabItemsContainerWidth();
        const scrollPrevButtonStyle = this.resolveLeftScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.scrollPrevButton.nativeElement, scrollPrevButtonStyle);
        const scrollNextButtonStyle = this.resolveRightScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.scrollNextButton.nativeElement, scrollNextButtonStyle);
    }
    setScrollButtonStyle(button, buttonStyle) {
        if (buttonStyle === "enabled" /* TabScrollButtonStyle.Enabled */) {
            button.disabled = false;
            button.style.display = '';
        }
        else if (buttonStyle === "disabled" /* TabScrollButtonStyle.Disabled */) {
            button.disabled = true;
            button.style.display = '';
        }
        else if (buttonStyle === "not_displayed" /* TabScrollButtonStyle.NotDisplayed */) {
            button.style.display = 'none';
        }
    }
    resolveLeftScrollButtonStyle(itemsContainerWidth) {
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return "not_displayed" /* TabScrollButtonStyle.NotDisplayed */;
            }
            return "disabled" /* TabScrollButtonStyle.Disabled */;
        }
        else {
            return "enabled" /* TabScrollButtonStyle.Enabled */;
        }
    }
    resolveRightScrollButtonStyle(itemsContainerWidth) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return "not_displayed" /* TabScrollButtonStyle.NotDisplayed */;
        }
        if (itemsContainerWidth > total) {
            return "enabled" /* TabScrollButtonStyle.Enabled */;
        }
        else {
            return "disabled" /* TabScrollButtonStyle.Disabled */;
        }
    }
    getTabItemsContainerWidth() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 1];
            itemsContainerWidth = this.getElementOffset(lastTab) + lastTab.offsetWidth;
        }
        return itemsContainerWidth;
    }
    getOffset(offset) {
        return this.dir.rtl ? -offset : offset;
    }
    getElementOffset(element) {
        return this.dir.rtl ? this.itemsWrapper.nativeElement.offsetWidth - element.offsetLeft - element.offsetWidth : element.offsetLeft;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTabsComponent, deps: [{ token: IgxAngularAnimationService }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i1.IgxDirectionality }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: IgxTabsComponent, isStandalone: true, selector: "igx-tabs", inputs: { tabAlignment: "tabAlignment" }, host: { properties: { "class.igx-tabs": "this.defaultClass" } }, providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }], viewQueries: [{ propertyName: "headerContainer", first: true, predicate: ["headerContainer"], descendants: true, static: true }, { propertyName: "viewPort", first: true, predicate: ["viewPort"], descendants: true, static: true }, { propertyName: "itemsWrapper", first: true, predicate: ["itemsWrapper"], descendants: true, static: true }, { propertyName: "itemsContainer", first: true, predicate: ["itemsContainer"], descendants: true, static: true }, { propertyName: "selectedIndicator", first: true, predicate: ["selectedIndicator"], descendants: true }, { propertyName: "scrollPrevButton", first: true, predicate: ["scrollPrevButton"], descendants: true }, { propertyName: "scrollNextButton", first: true, predicate: ["scrollNextButton"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<div #headerContainer class=\"igx-tabs__header\">\n    <button #scrollPrevButton type=\"button\" igxIconButton=\"flat\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollPrev()\">\n        <igx-icon>navigate_before</igx-icon>\n    </button>\n    <div #viewPort class=\"igx-tabs__header-content\">\n        <div #itemsWrapper class=\"igx-tabs__header-wrapper\" role=\"tablist\">\n            <div #itemsContainer class=\"igx-tabs__header-scroll\" [ngClass]=\"resolveHeaderScrollClasses()\">\n                <ng-container *ngFor=\"let tab of items; let i = index\">\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\n                </ng-container>\n            </div>\n            <div #selectedIndicator *ngIf=\"items.length > 0\" class=\"igx-tabs__header-active-indicator\">\n            </div>\n        </div>\n    </div>\n    <button #scrollNextButton type=\"button\" igxIconButton=\"flat\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollNext()\">\n        <igx-icon>navigate_next</igx-icon>\n    </button>\n</div>\n<div class=\"igx-tabs__panels\">\n    <ng-container *ngFor=\"let tab of items; let i = index\">\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\n    </ng-container>\n</div>\n", dependencies: [{ kind: "directive", type: IgxRippleDirective, selector: "[igxRipple]", inputs: ["igxRippleTarget", "igxRipple", "igxRippleDuration", "igxRippleCentered", "igxRippleDisabled"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTabsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tabs', providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }], standalone: true, imports: [IgxRippleDirective, IgxIconComponent, NgClass, NgFor, NgTemplateOutlet, NgIf], template: "<div #headerContainer class=\"igx-tabs__header\">\n    <button #scrollPrevButton type=\"button\" igxIconButton=\"flat\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollPrev()\">\n        <igx-icon>navigate_before</igx-icon>\n    </button>\n    <div #viewPort class=\"igx-tabs__header-content\">\n        <div #itemsWrapper class=\"igx-tabs__header-wrapper\" role=\"tablist\">\n            <div #itemsContainer class=\"igx-tabs__header-scroll\" [ngClass]=\"resolveHeaderScrollClasses()\">\n                <ng-container *ngFor=\"let tab of items; let i = index\">\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\n                </ng-container>\n            </div>\n            <div #selectedIndicator *ngIf=\"items.length > 0\" class=\"igx-tabs__header-active-indicator\">\n            </div>\n        </div>\n    </div>\n    <button #scrollNextButton type=\"button\" igxIconButton=\"flat\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollNext()\">\n        <igx-icon>navigate_next</igx-icon>\n    </button>\n</div>\n<div class=\"igx-tabs__panels\">\n    <ng-container *ngFor=\"let tab of items; let i = index\">\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\n    </ng-container>\n</div>\n" }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.IgxDirectionality }], propDecorators: { tabAlignment: [{
                type: Input
            }], headerContainer: [{
                type: ViewChild,
                args: ['headerContainer', { static: true }]
            }], viewPort: [{
                type: ViewChild,
                args: ['viewPort', { static: true }]
            }], itemsWrapper: [{
                type: ViewChild,
                args: ['itemsWrapper', { static: true }]
            }], itemsContainer: [{
                type: ViewChild,
                args: ['itemsContainer', { static: true }]
            }], selectedIndicator: [{
                type: ViewChild,
                args: ['selectedIndicator']
            }], scrollPrevButton: [{
                type: ViewChild,
                args: ['scrollPrevButton']
            }], scrollNextButton: [{
                type: ViewChild,
                args: ['scrollNextButton']
            }], defaultClass: [{
                type: HostBinding,
                args: ['class.igx-tabs']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvdGFicy90YWJzL3RhYnMuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3RhYnMvdGFicy90YWJzLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBb0MsU0FBUyxFQUFjLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFxQixTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEosT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzdELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLG9EQUFvRCxDQUFDO0FBR2hHLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDckQsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sMENBQTBDLENBQUM7OztBQUU5RSxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxhQUFhLENBQUEsTUFBTSxDQUFDO0lBQ2hELEtBQUssRUFBRSxPQUFPO0lBQ2QsR0FBRyxFQUFFLEtBQUs7SUFDVixNQUFNLEVBQUUsUUFBUTtJQUNoQixPQUFPLEVBQUUsU0FBUztDQUNyQixDQUFDLENBQUM7QUFXSCxjQUFjO0FBQ2QsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBRXBCOzs7Ozs7Ozs7Ozs7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LE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBS3BDLGNBQWM7c0JBRHBCLFNBQVM7dUJBQUMsZ0JBQWdCLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUt0QyxpQkFBaUI7c0JBRHZCLFNBQVM7dUJBQUMsbUJBQW1CO2dCQUt2QixnQkFBZ0I7c0JBRHRCLFNBQVM7dUJBQUMsa0JBQWtCO2dCQUt0QixnQkFBZ0I7c0JBRHRCLFNBQVM7dUJBQUMsa0JBQWtCO2dCQUt0QixZQUFZO3NCQURsQixXQUFXO3VCQUFDLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBOZ1pvbmUsIE9uRGVzdHJveSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBnZXRSZXNpemVPYnNlcnZlciwgbWtlbnVtIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJZ3hBbmd1bGFyQW5pbWF0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2FuaW1hdGlvbi9hbmd1bGFyLWFuaW1hdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IEFuaW1hdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9hbmltYXRpb24vYW5pbWF0aW9uJztcbmltcG9ydCB7IElneERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZGlyZWN0aW9uL2RpcmVjdGlvbmFsaXR5JztcbmltcG9ydCB7IElneFRhYnNCYXNlIH0gZnJvbSAnLi4vdGFicy5iYXNlJztcbmltcG9ydCB7IElneFRhYnNEaXJlY3RpdmUgfSBmcm9tICcuLi90YWJzLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOZ0NsYXNzLCBOZ0ZvciwgTmdUZW1wbGF0ZU91dGxldCwgTmdJZiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hJY29uQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hSaXBwbGVEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3JpcHBsZS9yaXBwbGUuZGlyZWN0aXZlJztcblxuZXhwb3J0IGNvbnN0IElneFRhYnNBbGlnbm1lbnQgPSAvKkBfX1BVUkVfXyovbWtlbnVtKHtcbiAgICBzdGFydDogJ3N0YXJ0JyxcbiAgICBlbmQ6ICdlbmQnLFxuICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAganVzdGlmeTogJ2p1c3RpZnknXG59KTtcblxuLyoqIEBoaWRkZW4gKi9cbmNvbnN0IGVudW0gVGFiU2Nyb2xsQnV0dG9uU3R5bGUge1xuICAgIEVuYWJsZWQgPSAnZW5hYmxlZCcsXG4gICAgRGlzYWJsZWQgPSAnZGlzYWJsZWQnLFxuICAgIE5vdERpc3BsYXllZCA9ICdub3RfZGlzcGxheWVkJ1xufVxuXG5leHBvcnQgdHlwZSBJZ3hUYWJzQWxpZ25tZW50ID0gKHR5cGVvZiBJZ3hUYWJzQWxpZ25tZW50KVtrZXlvZiB0eXBlb2YgSWd4VGFic0FsaWdubWVudF07XG5cbi8qKiBAaGlkZGVuICovXG5sZXQgTkVYVF9UQUJfSUQgPSAwO1xuXG4vKipcbiAqIFRhYnMgY29tcG9uZW50IGlzIHVzZWQgdG8gb3JnYW5pemUgb3Igc3dpdGNoIGJldHdlZW4gc2ltaWxhciBkYXRhIHNldHMuXG4gKlxuICogQGlneE1vZHVsZSBJZ3hUYWJzTW9kdWxlXG4gKlxuICogQGlneFRoZW1lIGlneC10YWJzLXRoZW1lXG4gKlxuICogQGlneEtleXdvcmRzIHRhYnNcbiAqXG4gKiBAaWd4R3JvdXAgTGF5b3V0c1xuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgSWduaXRlIFVJIGZvciBBbmd1bGFyIFRhYnMgY29tcG9uZW50IHBsYWNlcyB0YWJzIGF0IHRoZSB0b3AgYW5kIGFsbG93cyBmb3Igc2Nyb2xsaW5nIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHRhYiBpdGVtcyBvbiB0aGUgc2NyZWVuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8aWd4LXRhYnM+XG4gKiAgICAgPGlneC10YWItaXRlbT5cbiAqICAgICAgICAgPGlneC10YWItaGVhZGVyPlxuICogICAgICAgICAgICAgPGlneC1pY29uIGlneFRhYkhlYWRlckljb24+Zm9sZGVyPC9pZ3gtaWNvbj5cbiAqICAgICAgICAgICAgIDxzcGFuIGlneFRhYkhlYWRlckxhYmVsPlRhYiAxPC9zcGFuPlxuICogICAgICAgICA8L2lneC10YWItaGVhZGVyPlxuICogICAgICAgICA8aWd4LXRhYi1jb250ZW50PlxuICogICAgICAgICAgICAgQ29udGVudCAxXG4gKiAgICAgICAgIDwvaWd4LXRhYi1jb250ZW50PlxuICogICAgIDwvaWd4LXRhYi1pdGVtPlxuICogICAgIC4uLlxuICogPC9pZ3gtdGFicz5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC10YWJzJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RhYnMuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogSWd4VGFic0Jhc2UsIHVzZUV4aXN0aW5nOiBJZ3hUYWJzQ29tcG9uZW50IH1dLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW0lneFJpcHBsZURpcmVjdGl2ZSwgSWd4SWNvbkNvbXBvbmVudCwgTmdDbGFzcywgTmdGb3IsIE5nVGVtcGxhdGVPdXRsZXQsIE5nSWZdXG59KVxuXG5leHBvcnQgY2xhc3MgSWd4VGFic0NvbXBvbmVudCBleHRlbmRzIElneFRhYnNEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSB0YWIgYWxpZ25tZW50LiBEZWZhdWx0cyB0byBgc3RhcnRgLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCB0YWJBbGlnbm1lbnQoKTogc3RyaW5nIHwgSWd4VGFic0FsaWdubWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWJBbGlnbm1lbnQ7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCB0YWJBbGlnbm1lbnQodmFsdWU6IHN0cmluZyB8IElneFRhYnNBbGlnbm1lbnQpIHtcbiAgICAgICAgdGhpcy5fdGFiQWxpZ25tZW50ID0gdmFsdWU7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbEJ1dHRvbnMoKTtcbiAgICAgICAgICAgIHRoaXMucmVhbGlnblNlbGVjdGVkSW5kaWNhdG9yKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgnaGVhZGVyQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgaGVhZGVyQ29udGFpbmVyOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgndmlld1BvcnQnLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyB2aWV3UG9ydDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ2l0ZW1zV3JhcHBlcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGl0ZW1zV3JhcHBlcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ2l0ZW1zQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgaXRlbXNDb250YWluZXI6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdzZWxlY3RlZEluZGljYXRvcicpXG4gICAgcHVibGljIHNlbGVjdGVkSW5kaWNhdG9yOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgnc2Nyb2xsUHJldkJ1dHRvbicpXG4gICAgcHVibGljIHNjcm9sbFByZXZCdXR0b246IEVsZW1lbnRSZWY8SFRNTEJ1dHRvbkVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdzY3JvbGxOZXh0QnV0dG9uJylcbiAgICBwdWJsaWMgc2Nyb2xsTmV4dEJ1dHRvbjogRWxlbWVudFJlZjxIVE1MQnV0dG9uRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRhYnMnKVxuICAgIHB1YmxpYyBkZWZhdWx0Q2xhc3MgPSB0cnVlO1xuXG4gICAgLyoqICBAaGlkZGVuICovXG4gICAgcHVibGljIG9mZnNldCA9IDA7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByb3RlY3RlZCBvdmVycmlkZSBjb21wb25lbnROYW1lID0gJ2lneC10YWJzJztcblxuICAgIHByaXZhdGUgX3RhYkFsaWdubWVudDogc3RyaW5nIHwgSWd4VGFic0FsaWdubWVudCA9ICdzdGFydCc7XG4gICAgcHJpdmF0ZSBfcmVzaXplT2JzZXJ2ZXI6IFJlc2l6ZU9ic2VydmVyO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoSWd4QW5ndWxhckFuaW1hdGlvblNlcnZpY2UpIGFuaW1hdGlvblNlcnZpY2U6IEFuaW1hdGlvblNlcnZpY2UsXG4gICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmUsXG4gICAgICAgIGRpcjogSWd4RGlyZWN0aW9uYWxpdHkpIHtcbiAgICAgICAgc3VwZXIoYW5pbWF0aW9uU2VydmljZSwgY2RyLCBkaXIpO1xuICAgIH1cblxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG92ZXJyaWRlIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIubmdBZnRlclZpZXdJbml0KCk7XG5cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBuZXcgKGdldFJlc2l6ZU9ic2VydmVyKCkpKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbEJ1dHRvbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWxpZ25TZWxlY3RlZEluZGljYXRvcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuaGVhZGVyQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG5cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgc2Nyb2xsUHJldigpIHtcbiAgICAgICAgdGhpcy5zY3JvbGwoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIHNjcm9sbE5leHQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsKHRydWUpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIHJlYWxpZ25TZWxlY3RlZEluZGljYXRvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA+PSAwICYmIHRoaXMuc2VsZWN0ZWRJbmRleCA8IHRoaXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLml0ZW1zLmdldCh0aGlzLnNlbGVjdGVkSW5kZXgpLmhlYWRlckNvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5hbGlnblNlbGVjdGVkSW5kaWNhdG9yKGhlYWRlciwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyByZXNvbHZlSGVhZGVyU2Nyb2xsQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZ3gtdGFic19faGVhZGVyLXNjcm9sbC0tc3RhcnQnOiB0aGlzLnRhYkFsaWdubWVudCA9PT0gJ3N0YXJ0JyxcbiAgICAgICAgICAgICdpZ3gtdGFic19faGVhZGVyLXNjcm9sbC0tZW5kJzogdGhpcy50YWJBbGlnbm1lbnQgPT09ICdlbmQnLFxuICAgICAgICAgICAgJ2lneC10YWJzX19oZWFkZXItc2Nyb2xsLS1jZW50ZXInOiB0aGlzLnRhYkFsaWdubWVudCA9PT0gJ2NlbnRlcicsXG4gICAgICAgICAgICAnaWd4LXRhYnNfX2hlYWRlci1zY3JvbGwtLWp1c3RpZnknOiB0aGlzLnRhYkFsaWdubWVudCA9PT0gJ2p1c3RpZnknLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIHNjcm9sbFRhYkhlYWRlckludG9WaWV3KCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhYkl0ZW1zID0gdGhpcy5pdGVtcy50b0FycmF5KCk7XG4gICAgICAgICAgICBjb25zdCB0YWJIZWFkZXJOYXRpdmVFbGVtZW50ID0gdGFiSXRlbXNbdGhpcy5zZWxlY3RlZEluZGV4XS5oZWFkZXJDb21wb25lbnQubmF0aXZlRWxlbWVudDtcblxuICAgICAgICAgICAgLy8gU2Nyb2xsIGxlZnQgaWYgdGhlcmUgaXMgbmVlZFxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0RWxlbWVudE9mZnNldCh0YWJIZWFkZXJOYXRpdmVFbGVtZW50KSA8IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50KHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2Nyb2xsIHJpZ2h0IGlmIHRoZXJlIGlzIG5lZWRcbiAgICAgICAgICAgIGNvbnN0IHZpZXdQb3J0T2Zmc2V0V2lkdGggPSB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9ICh0aGlzLmdldEVsZW1lbnRPZmZzZXQodGFiSGVhZGVyTmF0aXZlRWxlbWVudCkgKyB0YWJIZWFkZXJOYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoKSAtICh2aWV3UG9ydE9mZnNldFdpZHRoICsgdGhpcy5vZmZzZXQpO1xuXG4gICAgICAgICAgICAvLyBGaXggZm9yIElFIDExLCBhIGRpZmZlcmVuY2UgaXMgYWNjdW11bGF0ZWQgZnJvbSB0aGUgd2lkdGhzIGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgaWYgKGRlbHRhID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCh0YWJIZWFkZXJOYXRpdmVFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hbGlnblNlbGVjdGVkSW5kaWNhdG9yKHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlU2VsZWN0ZWRJbmRpY2F0b3IoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHJvdGVjdGVkIGdldE5leHRUYWJJZCgpIHtcbiAgICAgICAgcmV0dXJuIE5FWFRfVEFCX0lEKys7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgb25JdGVtQ2hhbmdlcygpIHtcbiAgICAgICAgc3VwZXIub25JdGVtQ2hhbmdlcygpO1xuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWxpZ25TZWxlY3RlZEluZGljYXRvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgZHVyYXRpb24gPSAwLjMpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uID4gMCA/IGAke2R1cmF0aW9ufXNgIDogJ2luaXRpYWwnO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLndpZHRoID0gYCR7ZWxlbWVudC5vZmZzZXRXaWR0aH1weGA7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2VsZW1lbnQub2Zmc2V0TGVmdH1weClgO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoaWRlU2VsZWN0ZWRJbmRpY2F0b3IoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kaWNhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzY3JvbGwoc2Nyb2xsTmV4dDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCB0YWJzQXJyYXkgPSB0aGlzLml0ZW1zLnRvQXJyYXkoKTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGFic0FycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgdGFiID0gdGFic0FycmF5W2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0YWIuaGVhZGVyQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsTmV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFdpZHRoICsgdGhpcy5nZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpID4gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoICsgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50KGVsZW1lbnQsIHNjcm9sbE5leHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkgPj0gdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50KHRhYnNBcnJheVtpbmRleCAtIDFdLmhlYWRlckNvbXBvbmVudC5uYXRpdmVFbGVtZW50LCBzY3JvbGxOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzY3JvbGxFbGVtZW50KGVsZW1lbnQ6IGFueSwgc2Nyb2xsTmV4dDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCB2aWV3UG9ydFdpZHRoID0gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gKHNjcm9sbE5leHQpID8gZWxlbWVudC5vZmZzZXRXaWR0aCArIHRoaXMuZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KSAtIHZpZXdQb3J0V2lkdGggOiB0aGlzLmdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0ID0gdGhpcy5nZXRPZmZzZXQodGhpcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbEJ1dHRvbnMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVNjcm9sbEJ1dHRvbnMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zQ29udGFpbmVyV2lkdGggPSB0aGlzLmdldFRhYkl0ZW1zQ29udGFpbmVyV2lkdGgoKTtcblxuICAgICAgICBjb25zdCBzY3JvbGxQcmV2QnV0dG9uU3R5bGUgPSB0aGlzLnJlc29sdmVMZWZ0U2Nyb2xsQnV0dG9uU3R5bGUoaXRlbXNDb250YWluZXJXaWR0aCk7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsQnV0dG9uU3R5bGUodGhpcy5zY3JvbGxQcmV2QnV0dG9uLm5hdGl2ZUVsZW1lbnQsIHNjcm9sbFByZXZCdXR0b25TdHlsZSk7XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsTmV4dEJ1dHRvblN0eWxlID0gdGhpcy5yZXNvbHZlUmlnaHRTY3JvbGxCdXR0b25TdHlsZShpdGVtc0NvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxCdXR0b25TdHlsZSh0aGlzLnNjcm9sbE5leHRCdXR0b24ubmF0aXZlRWxlbWVudCwgc2Nyb2xsTmV4dEJ1dHRvblN0eWxlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFNjcm9sbEJ1dHRvblN0eWxlKGJ1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQsIGJ1dHRvblN0eWxlOiBUYWJTY3JvbGxCdXR0b25TdHlsZSkge1xuICAgICAgICBpZiAoYnV0dG9uU3R5bGUgPT09IFRhYlNjcm9sbEJ1dHRvblN0eWxlLkVuYWJsZWQpIHtcbiAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChidXR0b25TdHlsZSA9PT0gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBidXR0b24uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1dHRvblN0eWxlID09PSBUYWJTY3JvbGxCdXR0b25TdHlsZS5Ob3REaXNwbGF5ZWQpIHtcbiAgICAgICAgICAgIGJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgcmVzb2x2ZUxlZnRTY3JvbGxCdXR0b25TdHlsZShpdGVtc0NvbnRhaW5lcldpZHRoOiBudW1iZXIpOiBUYWJTY3JvbGxCdXR0b25TdHlsZSB7XG4gICAgICAgIGNvbnN0IGhlYWRlckNvbnRhaW5lcldpZHRoID0gdGhpcy5oZWFkZXJDb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG5cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRml4IGZvciBJRSAxMSwgYSBkaWZmZXJlbmNlIGlzIGFjY3VtdWxhdGVkIGZyb20gdGhlIHdpZHRocyBjYWxjdWxhdGlvbnMuXG4gICAgICAgICAgICBpZiAoaXRlbXNDb250YWluZXJXaWR0aCAtIGhlYWRlckNvbnRhaW5lcldpZHRoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuTm90RGlzcGxheWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLkRpc2FibGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLkVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlc29sdmVSaWdodFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGg6IG51bWJlcik6IFRhYlNjcm9sbEJ1dHRvblN0eWxlIHtcbiAgICAgICAgY29uc3Qgdmlld1BvcnRXaWR0aCA9IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3QgaGVhZGVyQ29udGFpbmVyV2lkdGggPSB0aGlzLmhlYWRlckNvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgY29uc3QgdG90YWwgPSBvZmZzZXQgKyB2aWV3UG9ydFdpZHRoO1xuXG4gICAgICAgIC8vIEZpeCBmb3IgSUUgMTEsIGEgZGlmZmVyZW5jZSBpcyBhY2N1bXVsYXRlZCBmcm9tIHRoZSB3aWR0aHMgY2FsY3VsYXRpb25zLlxuICAgICAgICBpZiAoaXRlbXNDb250YWluZXJXaWR0aCAtIGhlYWRlckNvbnRhaW5lcldpZHRoIDw9IDEgJiYgb2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuTm90RGlzcGxheWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1zQ29udGFpbmVyV2lkdGggPiB0b3RhbCkge1xuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLkVuYWJsZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuRGlzYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRhYkl0ZW1zQ29udGFpbmVyV2lkdGgoKSB7XG4gICAgICAgIC8vIFdlIHVzZSB0aGlzIGhhY2t5IHdheSB0byBnZXQgdGhlIHdpZHRoIG9mIHRoZSBpdGVtc0NvbnRhaW5lcixcbiAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBpbmNvbnNpc3RlbmN5IGluIElFIHdlIGNhbm5vdCB1c2Ugb2Zmc2V0V2lkdGggb3Igc2Nyb2xsT2Zmc2V0LlxuICAgICAgICBjb25zdCBpdGVtc0NvbnRhaW5lckNoaWxkcmVuQ291bnQgPSB0aGlzLml0ZW1zQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBsZXQgaXRlbXNDb250YWluZXJXaWR0aCA9IDA7XG5cbiAgICAgICAgaWYgKGl0ZW1zQ29udGFpbmVyQ2hpbGRyZW5Db3VudCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RUYWIgPSB0aGlzLml0ZW1zQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5baXRlbXNDb250YWluZXJDaGlsZHJlbkNvdW50IC0gMV0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBpdGVtc0NvbnRhaW5lcldpZHRoID0gdGhpcy5nZXRFbGVtZW50T2Zmc2V0KGxhc3RUYWIpICsgbGFzdFRhYi5vZmZzZXRXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtc0NvbnRhaW5lcldpZHRoO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0T2Zmc2V0KG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyLnJ0bCA/IC1vZmZzZXQgOiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyLnJ0bCA/IHRoaXMuaXRlbXNXcmFwcGVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggLSBlbGVtZW50Lm9mZnNldExlZnQgLSBlbGVtZW50Lm9mZnNldFdpZHRoIDogZWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgIH1cbn1cblxuIiwiPGRpdiAjaGVhZGVyQ29udGFpbmVyIGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlclwiPlxuICAgIDxidXR0b24gI3Njcm9sbFByZXZCdXR0b24gdHlwZT1cImJ1dHRvblwiIGlneEljb25CdXR0b249XCJmbGF0XCIgaWd4UmlwcGxlIGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlci1idXR0b25cIiAoY2xpY2spPVwic2Nyb2xsUHJldigpXCI+XG4gICAgICAgIDxpZ3gtaWNvbj5uYXZpZ2F0ZV9iZWZvcmU8L2lneC1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgIDxkaXYgI3ZpZXdQb3J0IGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlci1jb250ZW50XCI+XG4gICAgICAgIDxkaXYgI2l0ZW1zV3JhcHBlciBjbGFzcz1cImlneC10YWJzX19oZWFkZXItd3JhcHBlclwiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICAgICAgICA8ZGl2ICNpdGVtc0NvbnRhaW5lciBjbGFzcz1cImlneC10YWJzX19oZWFkZXItc2Nyb2xsXCIgW25nQ2xhc3NdPVwicmVzb2x2ZUhlYWRlclNjcm9sbENsYXNzZXMoKVwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHRhYiBvZiBpdGVtczsgbGV0IGkgPSBpbmRleFwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwidGFiLmhlYWRlclRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgI3NlbGVjdGVkSW5kaWNhdG9yICpuZ0lmPVwiaXRlbXMubGVuZ3RoID4gMFwiIGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlci1hY3RpdmUtaW5kaWNhdG9yXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGJ1dHRvbiAjc2Nyb2xsTmV4dEJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaWd4SWNvbkJ1dHRvbj1cImZsYXRcIiBpZ3hSaXBwbGUgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyLWJ1dHRvblwiIChjbGljayk9XCJzY3JvbGxOZXh0KClcIj5cbiAgICAgICAgPGlneC1pY29uPm5hdmlnYXRlX25leHQ8L2lneC1pY29uPlxuICAgIDwvYnV0dG9uPlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwiaWd4LXRhYnNfX3BhbmVsc1wiPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHRhYiBvZiBpdGVtczsgbGV0IGkgPSBpbmRleFwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwidGFiLnBhbmVsVGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvZGl2PlxuIl19