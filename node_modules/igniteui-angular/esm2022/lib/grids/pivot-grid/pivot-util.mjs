import { DataUtil, GridColumnDataType } from '../../data-operations/data-util';
import { FilteringLogic } from '../../data-operations/filtering-expression.interface';
import { FilteringExpressionsTree } from '../../data-operations/filtering-expressions-tree';
import { IgxSorting } from '../common/strategy';
import { IgxPivotAggregate, IgxPivotDateAggregate, IgxPivotNumericAggregate, IgxPivotTimeAggregate } from './pivot-grid-aggregate';
import { PivotDimensionType } from './pivot-grid.interface';
export class PivotUtil {
    // go through all children and apply new dimension groups as child
    static processGroups(recs, dimension, pivotKeys, cloneStrategy) {
        for (const rec of recs) {
            // process existing children
            if (rec.children && rec.children.size > 0) {
                // process hierarchy in dept
                rec.children.forEach((values) => {
                    this.processGroups(values, dimension, pivotKeys, cloneStrategy);
                });
            }
            // add children for current dimension
            const hierarchyFields = PivotUtil
                .getFieldsHierarchy(rec.records, [dimension], PivotDimensionType.Row, pivotKeys, cloneStrategy);
            const siblingData = PivotUtil
                .processHierarchy(hierarchyFields, pivotKeys, 0);
            rec.children.set(dimension.memberName, siblingData);
        }
    }
    static flattenGroups(data, dimension, expansionStates, defaultExpand, parent, parentRec) {
        for (let i = 0; i < data.length; i++) {
            const rec = data[i];
            const field = dimension.memberName;
            if (!field) {
                continue;
            }
            let recordsData = rec.children.get(field);
            if (!recordsData && parent) {
                // check parent
                recordsData = rec.children.get(parent.memberName);
                if (recordsData) {
                    dimension = parent;
                }
            }
            if (parentRec) {
                parentRec.dimensionValues.forEach((value, key) => {
                    if (parent.memberName !== key) {
                        rec.dimensionValues.set(key, value);
                        const dim = parentRec.dimensions.find(x => x.memberName === key);
                        rec.dimensions.unshift(dim);
                    }
                });
            }
            const expansionRowKey = PivotUtil.getRecordKey(rec, dimension);
            const isExpanded = expansionStates.get(expansionRowKey) === undefined ?
                defaultExpand :
                expansionStates.get(expansionRowKey);
            const shouldExpand = isExpanded || !dimension.childLevel || !rec.dimensionValues.get(dimension.memberName);
            if (shouldExpand && recordsData) {
                if (dimension.childLevel) {
                    this.flattenGroups(recordsData, dimension.childLevel, expansionStates, defaultExpand, dimension, rec);
                }
                else {
                    // copy parent values and dims in child
                    recordsData.forEach(x => {
                        rec.dimensionValues.forEach((value, key) => {
                            if (dimension.memberName !== key) {
                                x.dimensionValues.set(key, value);
                                const dim = rec.dimensions.find(y => y.memberName === key);
                                x.dimensions.unshift(dim);
                            }
                        });
                    });
                }
                data.splice(i + 1, 0, ...recordsData);
                i += recordsData.length;
            }
        }
    }
    static assignLevels(dims) {
        for (const dim of dims) {
            let currDim = dim;
            let lvl = 0;
            while (currDim.childLevel) {
                currDim.level = lvl;
                currDim = currDim.childLevel;
                lvl++;
            }
            currDim.level = lvl;
        }
    }
    static getFieldsHierarchy(data, dimensions, dimensionType, pivotKeys, cloneStrategy) {
        const hierarchy = new Map();
        for (const rec of data) {
            const vals = dimensionType === PivotDimensionType.Column ?
                this.extractValuesForColumn(dimensions, rec, pivotKeys) :
                this.extractValuesForRow(dimensions, rec, pivotKeys, cloneStrategy);
            for (const [_key, val] of vals) { // this should go in depth also vals.children
                if (hierarchy.get(val.value) != null) {
                    this.applyHierarchyChildren(hierarchy, val, rec, pivotKeys);
                }
                else {
                    hierarchy.set(val.value, cloneStrategy.clone(val));
                    this.applyHierarchyChildren(hierarchy, val, rec, pivotKeys);
                }
            }
        }
        return hierarchy;
    }
    static sort(data, expressions, sorting = new IgxSorting()) {
        data.forEach(rec => {
            const children = rec.children;
            if (children) {
                children.forEach(x => {
                    this.sort(x, expressions, sorting);
                });
            }
        });
        return DataUtil.sort(data, expressions, sorting);
    }
    static extractValueFromDimension(dim, recData) {
        return dim.memberFunction ? dim.memberFunction.call(null, recData) : recData[dim.memberName];
    }
    static getDimensionDepth(dim) {
        let lvl = 0;
        while (dim.childLevel) {
            lvl++;
            dim = dim.childLevel;
        }
        return lvl;
    }
    static extractValuesForRow(dims, recData, pivotKeys, cloneStrategy) {
        const values = new Map();
        for (const col of dims) {
            if (recData[pivotKeys.level] && recData[pivotKeys.level] > 0) {
                const childData = recData[pivotKeys.records];
                return this.getFieldsHierarchy(childData, [col], PivotDimensionType.Row, pivotKeys, cloneStrategy);
            }
            const value = this.extractValueFromDimension(col, recData);
            const objValue = {};
            objValue['value'] = value;
            objValue['dimension'] = col;
            if (col.childLevel) {
                const childValues = this.extractValuesForRow([col.childLevel], recData, pivotKeys, cloneStrategy);
                objValue[pivotKeys.children] = childValues;
            }
            values.set(value, objValue);
        }
        return values;
    }
    static extractValuesForColumn(dims, recData, pivotKeys, path = []) {
        const vals = new Map();
        let lvlCollection = vals;
        const flattenedDims = this.flatten(dims);
        for (const col of flattenedDims) {
            const value = this.extractValueFromDimension(col, recData);
            path.push(value);
            const newValue = path.join(pivotKeys.columnDimensionSeparator);
            const newObj = { value: newValue, expandable: col.expandable, children: null, dimension: col };
            if (!newObj.children) {
                newObj.children = new Map();
            }
            lvlCollection.set(newValue, newObj);
            lvlCollection = newObj.children;
        }
        return vals;
    }
    static flatten(arr, lvl = 0) {
        const newArr = arr.reduce((acc, item) => {
            if (item) {
                item.level = lvl;
                acc.push(item);
                if (item.childLevel) {
                    item.expandable = true;
                    acc = acc.concat(this.flatten([item.childLevel], lvl + 1));
                }
            }
            return acc;
        }, []);
        return newArr;
    }
    static applyAggregations(rec, hierarchies, values, pivotKeys) {
        if (hierarchies.size === 0) {
            // no column groups
            const aggregationResult = this.aggregate(rec.records, values);
            this.applyAggregationRecordData(aggregationResult, undefined, rec, pivotKeys);
            return;
        }
        hierarchies.forEach((hierarchy) => {
            const children = hierarchy[pivotKeys.children];
            if (children && children.size > 0) {
                this.applyAggregations(rec, children, values, pivotKeys);
                const childRecords = this.collectRecords(children, pivotKeys);
                hierarchy[pivotKeys.aggregations] = this.aggregate(childRecords, values);
                this.applyAggregationRecordData(hierarchy[pivotKeys.aggregations], hierarchy.value, rec, pivotKeys);
            }
            else if (hierarchy[pivotKeys.records]) {
                hierarchy[pivotKeys.aggregations] = this.aggregate(hierarchy[pivotKeys.records], values);
                this.applyAggregationRecordData(hierarchy[pivotKeys.aggregations], hierarchy.value, rec, pivotKeys);
            }
        });
    }
    static applyAggregationRecordData(aggregationData, groupName, rec, pivotKeys) {
        const aggregationKeys = Object.keys(aggregationData);
        if (aggregationKeys.length > 1) {
            aggregationKeys.forEach((key) => {
                const aggregationKey = groupName ? groupName + pivotKeys.columnDimensionSeparator + key : key;
                rec.aggregationValues.set(aggregationKey, aggregationData[key]);
            });
        }
        else if (aggregationKeys.length === 1) {
            const aggregationKey = aggregationKeys[0];
            rec.aggregationValues.set(groupName || aggregationKey, aggregationData[aggregationKey]);
        }
    }
    static aggregate(records, values) {
        const result = {};
        for (const pivotValue of values) {
            const aggregator = PivotUtil.getAggregatorForType(pivotValue.aggregate, pivotValue.dataType);
            if (!aggregator) {
                throw `No valid aggregator found for ${pivotValue.member}. Please set either a valid aggregatorName or aggregator`;
            }
            result[pivotValue.member] = aggregator(records.map(r => r[pivotValue.member]), records);
        }
        return result;
    }
    static getAggregatorForType(aggregate, dataType) {
        let aggregator = aggregate.aggregator;
        if (aggregate.aggregatorName) {
            let aggregators = IgxPivotNumericAggregate.aggregators();
            if (!dataType || dataType === 'date' || dataType === 'dateTime') {
                aggregators = aggregators.concat(IgxPivotDateAggregate.aggregators());
            }
            else if (dataType === 'time') {
                aggregators = aggregators.concat(IgxPivotTimeAggregate.aggregators());
            }
            aggregator = aggregators.find(x => x.key === aggregate.aggregatorName)?.aggregator;
        }
        return aggregator;
    }
    static processHierarchy(hierarchies, pivotKeys, level = 0, rootData = false) {
        const flatData = [];
        hierarchies.forEach((h, key) => {
            const field = h.dimension.memberName;
            const rec = {
                dimensionValues: new Map(),
                aggregationValues: new Map(),
                children: new Map(),
                dimensions: [h.dimension]
            };
            rec.dimensionValues.set(field, key);
            if (h[pivotKeys.records]) {
                rec.records = this.getDirectLeafs(h[pivotKeys.records]);
            }
            rec.level = level;
            flatData.push(rec);
            if (h[pivotKeys.children] && h[pivotKeys.children].size > 0) {
                const nestedData = this.processHierarchy(h[pivotKeys.children], pivotKeys, level + 1, rootData);
                rec.records = this.getDirectLeafs(nestedData);
                rec.children.set(field, nestedData);
            }
        });
        return flatData;
    }
    static getDirectLeafs(records) {
        let leafs = [];
        for (const rec of records) {
            if (rec.records) {
                const data = rec.records.filter(x => !x.records && leafs.indexOf(x) === -1);
                leafs = leafs.concat(data);
            }
            else {
                leafs.push(rec);
            }
        }
        return leafs;
    }
    static getRecordKey(rec, currentDim) {
        const parentFields = [];
        const currentDimIndex = rec.dimensions.findIndex(x => x.memberName === currentDim.memberName) + 1;
        const prevDims = rec.dimensions.slice(0, currentDimIndex);
        for (const prev of prevDims) {
            const prevValue = rec.dimensionValues.get(prev.memberName);
            parentFields.push(prevValue);
        }
        return parentFields.join('-');
    }
    static buildExpressionTree(config) {
        const allDimensions = (config?.rows || []).concat((config?.columns || [])).concat(config?.filters || []).filter(x => x !== null && x !== undefined);
        const enabledDimensions = allDimensions.filter(x => x && x.enabled);
        const expressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
        // add expression trees from all filters
        PivotUtil.flatten(enabledDimensions).forEach((x) => {
            if (x.filter && x.filter.filteringOperands) {
                expressionsTree.filteringOperands.push(...x.filter.filteringOperands);
            }
        });
        return expressionsTree;
    }
    static collectRecords(children, pivotKeys) {
        let result = [];
        children.forEach(value => result = result.concat(value[pivotKeys.records]));
        return result;
    }
    static applyHierarchyChildren(hierarchy, val, rec, pivotKeys) {
        const recordsKey = pivotKeys.records;
        const childKey = pivotKeys.children;
        const childCollection = val[childKey];
        const hierarchyValue = hierarchy.get(val.value);
        if (Array.isArray(hierarchyValue[childKey])) {
            hierarchyValue[childKey] = new Map();
        }
        if (!childCollection || childCollection.size === 0) {
            const dim = hierarchyValue.dimension;
            const isValid = this.extractValueFromDimension(dim, rec) === val.value;
            if (isValid) {
                if (hierarchyValue[recordsKey]) {
                    hierarchyValue[recordsKey].push(rec);
                }
                else {
                    hierarchyValue[recordsKey] = [rec];
                }
            }
        }
        else {
            const hierarchyChild = hierarchyValue[childKey];
            for (const [_key, child] of childCollection) {
                let hierarchyChildValue = hierarchyChild.get(child.value);
                if (!hierarchyChildValue) {
                    hierarchyChild.set(child.value, child);
                    hierarchyChildValue = child;
                }
                if (hierarchyChildValue[recordsKey]) {
                    const copy = Object.assign({}, rec);
                    if (rec[recordsKey]) {
                        // not all nested children are valid
                        const nestedValue = hierarchyChildValue.value;
                        const dimension = hierarchyChildValue.dimension;
                        const validRecs = rec[recordsKey].filter(x => this.extractValueFromDimension(dimension, x) === nestedValue);
                        copy[recordsKey] = validRecs;
                    }
                    hierarchyChildValue[recordsKey].push(copy);
                }
                else {
                    hierarchyChildValue[recordsKey] = [rec];
                }
                if (child[childKey] && child[childKey].size > 0) {
                    this.applyHierarchyChildren(hierarchyChild, child, rec, pivotKeys);
                }
            }
        }
    }
    static getAggregateList(val, grid) {
        if (!val.aggregateList) {
            let defaultAggr = this.getAggregatorsForValue(val, grid);
            const isDefault = defaultAggr.find((x) => x.key === val.aggregate.key);
            // resolve custom aggregations
            if (!isDefault && grid.data[0][val.member] !== undefined) {
                // if field exists, then we can apply default aggregations and add the custom one.
                defaultAggr.unshift(val.aggregate);
            }
            else if (!isDefault) {
                // otherwise this is a custom aggregation that is not compatible
                // with the defaults, since it operates on field that is not in the data
                // leave only the custom one.
                defaultAggr = [val.aggregate];
            }
            val.aggregateList = defaultAggr;
        }
        return val.aggregateList;
    }
    static getAggregatorsForValue(value, grid) {
        const dataType = value.dataType || grid.resolveDataTypes(grid.data[0][value.member]);
        switch (dataType) {
            case GridColumnDataType.Number:
            case GridColumnDataType.Currency:
                return IgxPivotNumericAggregate.aggregators();
            case GridColumnDataType.Date:
            case GridColumnDataType.DateTime:
                return IgxPivotDateAggregate.aggregators();
            case GridColumnDataType.Time:
                return IgxPivotTimeAggregate.aggregators();
            default:
                return IgxPivotAggregate.aggregators();
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3QtdXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LXV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFFBQVEsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQy9FLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxzREFBc0QsQ0FBQztBQUN0RixPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxrREFBa0QsQ0FBQztBQUc1RixPQUFPLEVBQXdCLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxxQkFBcUIsRUFBRSx3QkFBd0IsRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ25JLE9BQU8sRUFBcUcsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUUvSixNQUFNLE9BQU8sU0FBUztJQUVsQixrRUFBa0U7SUFDM0QsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUF3QixFQUFFLFNBQTBCLEVBQUUsU0FBcUIsRUFBRSxhQUFpQztRQUN0SSxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtZQUNwQiw0QkFBNEI7WUFDNUIsSUFBSSxHQUFHLENBQUMsUUFBUSxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRTtnQkFDdkMsNEJBQTRCO2dCQUM1QixHQUFHLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO29CQUM1QixJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDO2dCQUNwRSxDQUFDLENBQUMsQ0FBQzthQUNOO1lBQ0QscUNBQXFDO1lBQ3JDLE1BQU0sZUFB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SUFBbUI7UUFDeEUsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNyRixRQUFRLFFBQVEsRUFBRTtZQUNkLEtBQUssa0JBQWtCLENBQUMsTUFBTSxDQUFDO1lBQy9CLEtBQUssa0JBQWtCLENBQUMsUUFBUTtnQkFDNUIsT0FBTyx3QkFBd0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNsRCxLQUFLLGtCQUFrQixDQUFDLElBQUksQ0FBQztZQUM3QixLQUFLLGtCQUFrQixDQUFDLFFBQVE7Z0JBQzVCLE9BQU8scUJBQXFCLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDL0MsS0FBSyxrQkFBa0IsQ0FBQyxJQUFJO2dCQUN4QixPQUFPLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQy9DO2dCQUNJLE9BQU8saUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDOUM7SUFDTCxDQUFDO0NBR0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJRGF0YUNsb25lU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZGF0YS1jbG9uZS1zdHJhdGVneSc7XG5pbXBvcnQgeyBEYXRhVXRpbCwgR3JpZENvbHVtbkRhdGFUeXBlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2RhdGEtdXRpbCc7XG5pbXBvcnQgeyBGaWx0ZXJpbmdMb2dpYyB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9maWx0ZXJpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9ucy10cmVlJztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IFBpdm90R3JpZFR5cGUgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyaWRTb3J0aW5nU3RyYXRlZ3ksIElneFNvcnRpbmcgfSBmcm9tICcuLi9jb21tb24vc3RyYXRlZ3knO1xuaW1wb3J0IHsgSWd4UGl2b3RBZ2dyZWdhdGUsIElneFBpdm90RGF0ZUFnZ3JlZ2F0ZSwgSWd4UGl2b3ROdW1lcmljQWdncmVnYXRlLCBJZ3hQaXZvdFRpbWVBZ2dyZWdhdGUgfSBmcm9tICcuL3Bpdm90LWdyaWQtYWdncmVnYXRlJztcbmltcG9ydCB7IElQaXZvdEFnZ3JlZ2F0b3IsIElQaXZvdENvbmZpZ3VyYXRpb24sIElQaXZvdERpbWVuc2lvbiwgSVBpdm90R3JpZFJlY29yZCwgSVBpdm90S2V5cywgSVBpdm90VmFsdWUsIFBpdm90RGltZW5zaW9uVHlwZSB9IGZyb20gJy4vcGl2b3QtZ3JpZC5pbnRlcmZhY2UnO1xuXG5leHBvcnQgY2xhc3MgUGl2b3RVdGlsIHtcblxuICAgIC8vIGdvIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFuZCBhcHBseSBuZXcgZGltZW5zaW9uIGdyb3VwcyBhcyBjaGlsZFxuICAgIHB1YmxpYyBzdGF0aWMgcHJvY2Vzc0dyb3VwcyhyZWNzOiBJUGl2b3RHcmlkUmVjb3JkW10sIGRpbWVuc2lvbjogSVBpdm90RGltZW5zaW9uLCBwaXZvdEtleXM6IElQaXZvdEtleXMsIGNsb25lU3RyYXRlZ3k6IElEYXRhQ2xvbmVTdHJhdGVneSkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlYyBvZiByZWNzKSB7XG4gICAgICAgICAgICAvLyBwcm9jZXNzIGV4aXN0aW5nIGNoaWxkcmVuXG4gICAgICAgICAgICBpZiAocmVjLmNoaWxkcmVuICYmIHJlYy5jaGlsZHJlbi5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgaGllcmFyY2h5IGluIGRlcHRcbiAgICAgICAgICAgICAgICByZWMuY2hpbGRyZW4uZm9yRWFjaCgodmFsdWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0dyb3Vwcyh2YWx1ZXMsIGRpbWVuc2lvbiwgcGl2b3RLZXlzLCBjbG9uZVN0cmF0ZWd5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBjaGlsZHJlbiBmb3IgY3VycmVudCBkaW1lbnNpb25cbiAgICAgICAgICAgIGNvbnN0IGhpZXJhcmNoeUZpZWxkcyA9IFBpdm90VXRpbFxuICAgICAgICAgICAgICAgIC5nZXRGaWVsZHNIaWVyYXJjaHkocmVjLnJlY29yZHMsIFtkaW1lbnNpb25dLCBQaXZvdERpbWVuc2lvblR5cGUuUm93LCBwaXZvdEtleXMsIGNsb25lU3RyYXRlZ3kpO1xuICAgICAgICAgICAgY29uc3Qgc2libGluZ0RhdGEgPSBQaXZvdFV0aWxcbiAgICAgICAgICAgICAgICAucHJvY2Vzc0hpZXJhcmNoeShoaWVyYXJjaHlGaWVsZHMsIHBpdm90S2V5cywgMCk7XG4gICAgICAgICAgICByZWMuY2hpbGRyZW4uc2V0KGRpbWVuc2lvbi5tZW1iZXJOYW1lLCBzaWJsaW5nRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGZsYXR0ZW5Hcm91cHMoZGF0YTogSVBpdm90R3JpZFJlY29yZFtdLCBkaW1lbnNpb246IElQaXZvdERpbWVuc2lvbiwgZXhwYW5zaW9uU3RhdGVzLCBkZWZhdWx0RXhwYW5kOiBib29sZWFuLCBwYXJlbnQ/OiBJUGl2b3REaW1lbnNpb24sIHBhcmVudFJlYz86IElQaXZvdEdyaWRSZWNvcmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZWMgPSBkYXRhW2ldO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBkaW1lbnNpb24ubWVtYmVyTmFtZTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlY29yZHNEYXRhID0gcmVjLmNoaWxkcmVuLmdldChmaWVsZCk7XG4gICAgICAgICAgICBpZiAoIXJlY29yZHNEYXRhICYmIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHBhcmVudFxuICAgICAgICAgICAgICAgIHJlY29yZHNEYXRhID0gcmVjLmNoaWxkcmVuLmdldChwYXJlbnQubWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZHNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbiA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRSZWMpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWMuZGltZW5zaW9uVmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5tZW1iZXJOYW1lICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYy5kaW1lbnNpb25WYWx1ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGltID0gcGFyZW50UmVjLmRpbWVuc2lvbnMuZmluZCh4ID0+IHgubWVtYmVyTmFtZSA9PT0ga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYy5kaW1lbnNpb25zLnVuc2hpZnQoZGltKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgY29uc3QgZXhwYW5zaW9uUm93S2V5ID0gUGl2b3RVdGlsLmdldFJlY29yZEtleShyZWMsIGRpbWVuc2lvbik7XG4gICAgICAgICAgICBjb25zdCBpc0V4cGFuZGVkID0gZXhwYW5zaW9uU3RhdGVzLmdldChleHBhbnNpb25Sb3dLZXkpID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIGRlZmF1bHRFeHBhbmQgOlxuICAgICAgICAgICAgICAgIGV4cGFuc2lvblN0YXRlcy5nZXQoZXhwYW5zaW9uUm93S2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEV4cGFuZCA9IGlzRXhwYW5kZWQgfHwgIWRpbWVuc2lvbi5jaGlsZExldmVsIHx8ICFyZWMuZGltZW5zaW9uVmFsdWVzLmdldChkaW1lbnNpb24ubWVtYmVyTmFtZSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRXhwYW5kICYmIHJlY29yZHNEYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbi5jaGlsZExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhdHRlbkdyb3VwcyhyZWNvcmRzRGF0YSwgZGltZW5zaW9uLmNoaWxkTGV2ZWwsIGV4cGFuc2lvblN0YXRlcywgZGVmYXVsdEV4cGFuZCwgZGltZW5zaW9uLCByZWMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgcGFyZW50IHZhbHVlcyBhbmQgZGltcyBpbiBjaGlsZFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRzRGF0YS5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjLmRpbWVuc2lvblZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbi5tZW1iZXJOYW1lICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5kaW1lbnNpb25WYWx1ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaW0gPSByZWMuZGltZW5zaW9ucy5maW5kKHkgPT4geS5tZW1iZXJOYW1lID09PSBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmRpbWVuc2lvbnMudW5zaGlmdChkaW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGkgKyAxLCAwLCAuLi5yZWNvcmRzRGF0YSk7XG4gICAgICAgICAgICAgICAgaSArPSByZWNvcmRzRGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgc3RhdGljIGFzc2lnbkxldmVscyhkaW1zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGltIG9mIGRpbXMpIHtcbiAgICAgICAgICAgIGxldCBjdXJyRGltID0gZGltO1xuICAgICAgICAgICAgbGV0IGx2bCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY3VyckRpbS5jaGlsZExldmVsKSB7XG4gICAgICAgICAgICAgICAgY3VyckRpbS5sZXZlbCA9IGx2bDtcbiAgICAgICAgICAgICAgICBjdXJyRGltID0gY3VyckRpbS5jaGlsZExldmVsO1xuICAgICAgICAgICAgICAgIGx2bCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyckRpbS5sZXZlbCA9IGx2bDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgc3RhdGljIGdldEZpZWxkc0hpZXJhcmNoeShkYXRhOiBhbnlbXSwgZGltZW5zaW9uczogSVBpdm90RGltZW5zaW9uW10sXG4gICAgICAgIGRpbWVuc2lvblR5cGU6IFBpdm90RGltZW5zaW9uVHlwZSwgcGl2b3RLZXlzOiBJUGl2b3RLZXlzLCBjbG9uZVN0cmF0ZWd5OiBJRGF0YUNsb25lU3RyYXRlZ3kpOiBNYXA8c3RyaW5nLCBhbnk+IHtcbiAgICAgICAgY29uc3QgaGllcmFyY2h5ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgICAgZm9yIChjb25zdCByZWMgb2YgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgdmFscyA9IGRpbWVuc2lvblR5cGUgPT09IFBpdm90RGltZW5zaW9uVHlwZS5Db2x1bW4gP1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFjdFZhbHVlc0ZvckNvbHVtbihkaW1lbnNpb25zLCByZWMsIHBpdm90S2V5cykgOlxuICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFjdFZhbHVlc0ZvclJvdyhkaW1lbnNpb25zLCByZWMsIHBpdm90S2V5cywgY2xvbmVTdHJhdGVneSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWxdIG9mIHZhbHMpIHsgLy8gdGhpcyBzaG91bGQgZ28gaW4gZGVwdGggYWxzbyB2YWxzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgaWYgKGhpZXJhcmNoeS5nZXQodmFsLnZhbHVlKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlIaWVyYXJjaHlDaGlsZHJlbihoaWVyYXJjaHksIHZhbCwgcmVjLCBwaXZvdEtleXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoeS5zZXQodmFsLnZhbHVlLCBjbG9uZVN0cmF0ZWd5LmNsb25lKHZhbCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5SGllcmFyY2h5Q2hpbGRyZW4oaGllcmFyY2h5LCB2YWwsIHJlYywgcGl2b3RLZXlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZXJhcmNoeTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNvcnQoZGF0YTogSVBpdm90R3JpZFJlY29yZFtdLCBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sIHNvcnRpbmc6IElHcmlkU29ydGluZ1N0cmF0ZWd5ID0gbmV3IElneFNvcnRpbmcoKSk6IGFueVtdIHtcbiAgICAgICAgZGF0YS5mb3JFYWNoKHJlYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHJlYy5jaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydCh4LCBleHByZXNzaW9ucywgc29ydGluZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRGF0YVV0aWwuc29ydChkYXRhLCBleHByZXNzaW9ucywgc29ydGluZyk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBleHRyYWN0VmFsdWVGcm9tRGltZW5zaW9uKGRpbTogSVBpdm90RGltZW5zaW9uLCByZWNEYXRhOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIGRpbS5tZW1iZXJGdW5jdGlvbiA/IGRpbS5tZW1iZXJGdW5jdGlvbi5jYWxsKG51bGwsIHJlY0RhdGEpIDogcmVjRGF0YVtkaW0ubWVtYmVyTmFtZV07XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXREaW1lbnNpb25EZXB0aChkaW06IElQaXZvdERpbWVuc2lvbik6IG51bWJlciB7XG4gICAgICAgIGxldCBsdmwgPSAwO1xuICAgICAgICB3aGlsZSAoZGltLmNoaWxkTGV2ZWwpIHtcbiAgICAgICAgICAgIGx2bCsrO1xuICAgICAgICAgICAgZGltID0gZGltLmNoaWxkTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGx2bDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGV4dHJhY3RWYWx1ZXNGb3JSb3coZGltczogSVBpdm90RGltZW5zaW9uW10sIHJlY0RhdGE6IGFueSwgcGl2b3RLZXlzOiBJUGl2b3RLZXlzLCBjbG9uZVN0cmF0ZWd5OiBJRGF0YUNsb25lU3RyYXRlZ3kpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgICAgZm9yIChjb25zdCBjb2wgb2YgZGltcykge1xuICAgICAgICAgICAgaWYgKHJlY0RhdGFbcGl2b3RLZXlzLmxldmVsXSAmJiByZWNEYXRhW3Bpdm90S2V5cy5sZXZlbF0gPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGREYXRhID0gcmVjRGF0YVtwaXZvdEtleXMucmVjb3Jkc107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRzSGllcmFyY2h5KGNoaWxkRGF0YSwgW2NvbF0sIFBpdm90RGltZW5zaW9uVHlwZS5Sb3csIHBpdm90S2V5cywgY2xvbmVTdHJhdGVneSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5leHRyYWN0VmFsdWVGcm9tRGltZW5zaW9uKGNvbCwgcmVjRGF0YSk7XG4gICAgICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IHt9O1xuICAgICAgICAgICAgb2JqVmFsdWVbJ3ZhbHVlJ10gPSB2YWx1ZTtcbiAgICAgICAgICAgIG9ialZhbHVlWydkaW1lbnNpb24nXSA9IGNvbDtcbiAgICAgICAgICAgIGlmIChjb2wuY2hpbGRMZXZlbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVmFsdWVzID0gdGhpcy5leHRyYWN0VmFsdWVzRm9yUm93KFtjb2wuY2hpbGRMZXZlbF0sIHJlY0RhdGEsIHBpdm90S2V5cywgY2xvbmVTdHJhdGVneSk7XG4gICAgICAgICAgICAgICAgb2JqVmFsdWVbcGl2b3RLZXlzLmNoaWxkcmVuXSA9IGNoaWxkVmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLnNldCh2YWx1ZSwgb2JqVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGV4dHJhY3RWYWx1ZXNGb3JDb2x1bW4oZGltczogSVBpdm90RGltZW5zaW9uW10sIHJlY0RhdGE6IGFueSwgcGl2b3RLZXlzOiBJUGl2b3RLZXlzLCBwYXRoID0gW10pIHtcbiAgICAgICAgY29uc3QgdmFscyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICAgIGxldCBsdmxDb2xsZWN0aW9uID0gdmFscztcbiAgICAgICAgY29uc3QgZmxhdHRlbmVkRGltcyA9IHRoaXMuZmxhdHRlbihkaW1zKTtcbiAgICAgICAgZm9yIChjb25zdCBjb2wgb2YgZmxhdHRlbmVkRGltcykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmV4dHJhY3RWYWx1ZUZyb21EaW1lbnNpb24oY29sLCByZWNEYXRhKTtcbiAgICAgICAgICAgIHBhdGgucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHBhdGguam9pbihwaXZvdEtleXMuY29sdW1uRGltZW5zaW9uU2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld09iaiA9IHsgdmFsdWU6IG5ld1ZhbHVlLCBleHBhbmRhYmxlOiBjb2wuZXhwYW5kYWJsZSwgY2hpbGRyZW46IG51bGwsIGRpbWVuc2lvbjogY29sIH07XG4gICAgICAgICAgICBpZiAoIW5ld09iai5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIG5ld09iai5jaGlsZHJlbiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsdmxDb2xsZWN0aW9uLnNldChuZXdWYWx1ZSwgbmV3T2JqKTtcbiAgICAgICAgICAgIGx2bENvbGxlY3Rpb24gPSBuZXdPYmouY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBmbGF0dGVuKGFyciwgbHZsID0gMCkge1xuICAgICAgICBjb25zdCBuZXdBcnIgPSBhcnIucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5sZXZlbCA9IGx2bDtcbiAgICAgICAgICAgICAgICBhY2MucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGlsZExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZXhwYW5kYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFjYyA9IGFjYy5jb25jYXQodGhpcy5mbGF0dGVuKFtpdGVtLmNoaWxkTGV2ZWxdLCBsdmwgKyAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gbmV3QXJyO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXBwbHlBZ2dyZWdhdGlvbnMocmVjOiBJUGl2b3RHcmlkUmVjb3JkLCBoaWVyYXJjaGllcywgdmFsdWVzLCBwaXZvdEtleXM6IElQaXZvdEtleXMpIHtcbiAgICAgICAgaWYgKGhpZXJhcmNoaWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIG5vIGNvbHVtbiBncm91cHNcbiAgICAgICAgICAgIGNvbnN0IGFnZ3JlZ2F0aW9uUmVzdWx0ID0gdGhpcy5hZ2dyZWdhdGUocmVjLnJlY29yZHMsIHZhbHVlcyk7XG4gICAgICAgICAgICB0aGlzLmFwcGx5QWdncmVnYXRpb25SZWNvcmREYXRhKGFnZ3JlZ2F0aW9uUmVzdWx0LCB1bmRlZmluZWQsIHJlYywgcGl2b3RLZXlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoaWVyYXJjaGllcy5mb3JFYWNoKChoaWVyYXJjaHkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gaGllcmFyY2h5W3Bpdm90S2V5cy5jaGlsZHJlbl07XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4uc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QWdncmVnYXRpb25zKHJlYywgY2hpbGRyZW4sIHZhbHVlcywgcGl2b3RLZXlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFJlY29yZHMgPSB0aGlzLmNvbGxlY3RSZWNvcmRzKGNoaWxkcmVuLCBwaXZvdEtleXMpO1xuICAgICAgICAgICAgICAgIGhpZXJhcmNoeVtwaXZvdEtleXMuYWdncmVnYXRpb25zXSA9IHRoaXMuYWdncmVnYXRlKGNoaWxkUmVjb3JkcywgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QWdncmVnYXRpb25SZWNvcmREYXRhKGhpZXJhcmNoeVtwaXZvdEtleXMuYWdncmVnYXRpb25zXSwgaGllcmFyY2h5LnZhbHVlLCByZWMsIHBpdm90S2V5cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhpZXJhcmNoeVtwaXZvdEtleXMucmVjb3Jkc10pIHtcbiAgICAgICAgICAgICAgICBoaWVyYXJjaHlbcGl2b3RLZXlzLmFnZ3JlZ2F0aW9uc10gPSB0aGlzLmFnZ3JlZ2F0ZShoaWVyYXJjaHlbcGl2b3RLZXlzLnJlY29yZHNdLCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBZ2dyZWdhdGlvblJlY29yZERhdGEoaGllcmFyY2h5W3Bpdm90S2V5cy5hZ2dyZWdhdGlvbnNdLCBoaWVyYXJjaHkudmFsdWUsIHJlYywgcGl2b3RLZXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBhcHBseUFnZ3JlZ2F0aW9uUmVjb3JkRGF0YShhZ2dyZWdhdGlvbkRhdGE6IGFueSwgZ3JvdXBOYW1lOiBzdHJpbmcsIHJlYzogSVBpdm90R3JpZFJlY29yZCwgcGl2b3RLZXlzOiBJUGl2b3RLZXlzKSB7XG4gICAgICAgIGNvbnN0IGFnZ3JlZ2F0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGFnZ3JlZ2F0aW9uRGF0YSk7XG4gICAgICAgIGlmIChhZ2dyZWdhdGlvbktleXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYWdncmVnYXRpb25LZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFnZ3JlZ2F0aW9uS2V5ID0gZ3JvdXBOYW1lID8gZ3JvdXBOYW1lICsgcGl2b3RLZXlzLmNvbHVtbkRpbWVuc2lvblNlcGFyYXRvciArIGtleSA6IGtleTtcbiAgICAgICAgICAgICAgICByZWMuYWdncmVnYXRpb25WYWx1ZXMuc2V0KGFnZ3JlZ2F0aW9uS2V5LCBhZ2dyZWdhdGlvbkRhdGFba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlICBpZiAoYWdncmVnYXRpb25LZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgYWdncmVnYXRpb25LZXkgPSBhZ2dyZWdhdGlvbktleXNbMF07XG4gICAgICAgICAgICByZWMuYWdncmVnYXRpb25WYWx1ZXMuc2V0KGdyb3VwTmFtZSB8fCBhZ2dyZWdhdGlvbktleSwgYWdncmVnYXRpb25EYXRhW2FnZ3JlZ2F0aW9uS2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGFnZ3JlZ2F0ZShyZWNvcmRzLCB2YWx1ZXM6IElQaXZvdFZhbHVlW10pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGl2b3RWYWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFnZ3JlZ2F0b3IgPSBQaXZvdFV0aWwuZ2V0QWdncmVnYXRvckZvclR5cGUocGl2b3RWYWx1ZS5hZ2dyZWdhdGUsIHBpdm90VmFsdWUuZGF0YVR5cGUpO1xuICAgICAgICAgICAgaWYgKCFhZ2dyZWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYE5vIHZhbGlkIGFnZ3JlZ2F0b3IgZm91bmQgZm9yICR7cGl2b3RWYWx1ZS5tZW1iZXJ9LiBQbGVhc2Ugc2V0IGVpdGhlciBhIHZhbGlkIGFnZ3JlZ2F0b3JOYW1lIG9yIGFnZ3JlZ2F0b3JgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W3Bpdm90VmFsdWUubWVtYmVyXSA9IGFnZ3JlZ2F0b3IocmVjb3Jkcy5tYXAociA9PiByW3Bpdm90VmFsdWUubWVtYmVyXSksIHJlY29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEFnZ3JlZ2F0b3JGb3JUeXBlKGFnZ3JlZ2F0ZTogSVBpdm90QWdncmVnYXRvciwgZGF0YVR5cGU6IEdyaWRDb2x1bW5EYXRhVHlwZSkge1xuICAgICAgICBsZXQgYWdncmVnYXRvciA9IGFnZ3JlZ2F0ZS5hZ2dyZWdhdG9yO1xuICAgICAgICBpZiAoYWdncmVnYXRlLmFnZ3JlZ2F0b3JOYW1lKSB7XG4gICAgICAgICAgICBsZXQgYWdncmVnYXRvcnMgPSBJZ3hQaXZvdE51bWVyaWNBZ2dyZWdhdGUuYWdncmVnYXRvcnMoKTtcbiAgICAgICAgICAgIGlmICghZGF0YVR5cGUgfHwgZGF0YVR5cGUgPT09ICdkYXRlJyB8fCBkYXRhVHlwZSA9PT0gJ2RhdGVUaW1lJykge1xuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0b3JzID0gYWdncmVnYXRvcnMuY29uY2F0KElneFBpdm90RGF0ZUFnZ3JlZ2F0ZS5hZ2dyZWdhdG9ycygpKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICAgICAgYWdncmVnYXRvcnMgPSBhZ2dyZWdhdG9ycy5jb25jYXQoSWd4UGl2b3RUaW1lQWdncmVnYXRlLmFnZ3JlZ2F0b3JzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWdncmVnYXRvciA9IGFnZ3JlZ2F0b3JzLmZpbmQoeCA9PiB4LmtleSA9PT0gYWdncmVnYXRlLmFnZ3JlZ2F0b3JOYW1lKT8uYWdncmVnYXRvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWdncmVnYXRvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHByb2Nlc3NIaWVyYXJjaHkoaGllcmFyY2hpZXMsIHBpdm90S2V5cywgbGV2ZWwgPSAwLCByb290RGF0YSA9IGZhbHNlKTogSVBpdm90R3JpZFJlY29yZFtdIHtcbiAgICAgICAgY29uc3QgZmxhdERhdGE6IElQaXZvdEdyaWRSZWNvcmRbXSA9IFtdO1xuICAgICAgICBoaWVyYXJjaGllcy5mb3JFYWNoKChoLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gaC5kaW1lbnNpb24ubWVtYmVyTmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHJlYzogSVBpdm90R3JpZFJlY29yZCA9IHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25WYWx1ZXM6IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCksXG4gICAgICAgICAgICAgICAgYWdncmVnYXRpb25WYWx1ZXM6IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCksXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IG5ldyBNYXA8c3RyaW5nLCBJUGl2b3RHcmlkUmVjb3JkW10+KCksXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogW2guZGltZW5zaW9uXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlYy5kaW1lbnNpb25WYWx1ZXMuc2V0KGZpZWxkLCBrZXkpO1xuICAgICAgICAgICAgaWYgKGhbcGl2b3RLZXlzLnJlY29yZHNdKSB7XG4gICAgICAgICAgICAgICAgcmVjLnJlY29yZHMgPSB0aGlzLmdldERpcmVjdExlYWZzKGhbcGl2b3RLZXlzLnJlY29yZHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYy5sZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgZmxhdERhdGEucHVzaChyZWMpO1xuICAgICAgICAgICAgaWYgKGhbcGl2b3RLZXlzLmNoaWxkcmVuXSAmJiBoW3Bpdm90S2V5cy5jaGlsZHJlbl0uc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXN0ZWREYXRhID0gdGhpcy5wcm9jZXNzSGllcmFyY2h5KGhbcGl2b3RLZXlzLmNoaWxkcmVuXSxcbiAgICAgICAgICAgICAgICAgICAgcGl2b3RLZXlzLCBsZXZlbCArIDEsIHJvb3REYXRhKTtcbiAgICAgICAgICAgICAgICByZWMucmVjb3JkcyA9IHRoaXMuZ2V0RGlyZWN0TGVhZnMobmVzdGVkRGF0YSk7XG4gICAgICAgICAgICAgICAgcmVjLmNoaWxkcmVuLnNldChmaWVsZCwgbmVzdGVkRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmbGF0RGF0YTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldERpcmVjdExlYWZzKHJlY29yZHM6IElQaXZvdEdyaWRSZWNvcmRbXSkge1xuICAgICAgICBsZXQgbGVhZnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByZWMgb2YgcmVjb3Jkcykge1xuICAgICAgICAgICAgaWYgKHJlYy5yZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlYy5yZWNvcmRzLmZpbHRlcih4ID0+ICF4LnJlY29yZHMgJiYgbGVhZnMuaW5kZXhPZih4KSA9PT0gLTEpO1xuICAgICAgICAgICAgICAgIGxlYWZzID0gbGVhZnMuY29uY2F0KGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZWFmcy5wdXNoKHJlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlYWZzO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0UmVjb3JkS2V5KHJlYzogSVBpdm90R3JpZFJlY29yZCwgY3VycmVudERpbTogSVBpdm90RGltZW5zaW9uLCkge1xuICAgICAgICBjb25zdCBwYXJlbnRGaWVsZHMgPSBbXTtcbiAgICAgICAgY29uc3QgY3VycmVudERpbUluZGV4ID0gcmVjLmRpbWVuc2lvbnMuZmluZEluZGV4KHggPT4geC5tZW1iZXJOYW1lID09PSBjdXJyZW50RGltLm1lbWJlck5hbWUpICsgMTtcbiAgICAgICAgY29uc3QgcHJldkRpbXMgPSByZWMuZGltZW5zaW9ucy5zbGljZSgwLCBjdXJyZW50RGltSW5kZXgpO1xuICAgICAgICBmb3IgKGNvbnN0IHByZXYgb2YgcHJldkRpbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IHJlYy5kaW1lbnNpb25WYWx1ZXMuZ2V0KHByZXYubWVtYmVyTmFtZSk7XG4gICAgICAgICAgICBwYXJlbnRGaWVsZHMucHVzaChwcmV2VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnRGaWVsZHMuam9pbignLScpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYnVpbGRFeHByZXNzaW9uVHJlZShjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgY29uc3QgYWxsRGltZW5zaW9ucyA9IChjb25maWc/LnJvd3MgfHwgW10pLmNvbmNhdCgoY29uZmlnPy5jb2x1bW5zIHx8IFtdKSkuY29uY2F0KGNvbmZpZz8uZmlsdGVycyB8fCBbXSkuZmlsdGVyKHggPT4geCAhPT0gbnVsbCAmJiB4ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBlbmFibGVkRGltZW5zaW9ucyA9IGFsbERpbWVuc2lvbnMuZmlsdGVyKHggPT4geCAmJiB4LmVuYWJsZWQpO1xuXG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zVHJlZSA9IG5ldyBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUoRmlsdGVyaW5nTG9naWMuQW5kKTtcbiAgICAgICAgLy8gYWRkIGV4cHJlc3Npb24gdHJlZXMgZnJvbSBhbGwgZmlsdGVyc1xuICAgICAgICBQaXZvdFV0aWwuZmxhdHRlbihlbmFibGVkRGltZW5zaW9ucykuZm9yRWFjaCgoeDogSVBpdm90RGltZW5zaW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoeC5maWx0ZXIgJiYgeC5maWx0ZXIuZmlsdGVyaW5nT3BlcmFuZHMpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uc1RyZWUuZmlsdGVyaW5nT3BlcmFuZHMucHVzaCguLi54LmZpbHRlci5maWx0ZXJpbmdPcGVyYW5kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBleHByZXNzaW9uc1RyZWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY29sbGVjdFJlY29yZHMoY2hpbGRyZW4sIHBpdm90S2V5czogSVBpdm90S2V5cykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2godmFsdWUgPT4gcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh2YWx1ZVtwaXZvdEtleXMucmVjb3Jkc10pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhcHBseUhpZXJhcmNoeUNoaWxkcmVuKGhpZXJhcmNoeSwgdmFsLCByZWMsIHBpdm90S2V5czogSVBpdm90S2V5cykge1xuICAgICAgICBjb25zdCByZWNvcmRzS2V5ID0gcGl2b3RLZXlzLnJlY29yZHM7XG4gICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGl2b3RLZXlzLmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBjaGlsZENvbGxlY3Rpb24gPSB2YWxbY2hpbGRLZXldO1xuICAgICAgICBjb25zdCBoaWVyYXJjaHlWYWx1ZSA9IGhpZXJhcmNoeS5nZXQodmFsLnZhbHVlKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGllcmFyY2h5VmFsdWVbY2hpbGRLZXldKSkge1xuICAgICAgICAgICAgaGllcmFyY2h5VmFsdWVbY2hpbGRLZXldID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQ29sbGVjdGlvbiB8fCBjaGlsZENvbGxlY3Rpb24uc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZGltID0gaGllcmFyY2h5VmFsdWUuZGltZW5zaW9uO1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuZXh0cmFjdFZhbHVlRnJvbURpbWVuc2lvbihkaW0sIHJlYykgPT09IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpZXJhcmNoeVZhbHVlW3JlY29yZHNLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoeVZhbHVlW3JlY29yZHNLZXldLnB1c2gocmVjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoaWVyYXJjaHlWYWx1ZVtyZWNvcmRzS2V5XSA9IFtyZWNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZXJhcmNoeUNoaWxkID0gaGllcmFyY2h5VmFsdWVbY2hpbGRLZXldO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbX2tleSwgY2hpbGRdIG9mIGNoaWxkQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBoaWVyYXJjaHlDaGlsZFZhbHVlID0gaGllcmFyY2h5Q2hpbGQuZ2V0KGNoaWxkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhpZXJhcmNoeUNoaWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGllcmFyY2h5Q2hpbGQuc2V0KGNoaWxkLnZhbHVlLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoeUNoaWxkVmFsdWUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGllcmFyY2h5Q2hpbGRWYWx1ZVtyZWNvcmRzS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY1tyZWNvcmRzS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGFsbCBuZXN0ZWQgY2hpbGRyZW4gYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXN0ZWRWYWx1ZSA9IGhpZXJhcmNoeUNoaWxkVmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSBoaWVyYXJjaHlDaGlsZFZhbHVlLmRpbWVuc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkUmVjcyA9IHJlY1tyZWNvcmRzS2V5XS5maWx0ZXIoeCA9PiB0aGlzLmV4dHJhY3RWYWx1ZUZyb21EaW1lbnNpb24oZGltZW5zaW9uLCB4KSA9PT0gbmVzdGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weVtyZWNvcmRzS2V5XSA9IHZhbGlkUmVjcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoaWVyYXJjaHlDaGlsZFZhbHVlW3JlY29yZHNLZXldLnB1c2goY29weSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGllcmFyY2h5Q2hpbGRWYWx1ZVtyZWNvcmRzS2V5XSA9IFtyZWNdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZFtjaGlsZEtleV0gJiYgY2hpbGRbY2hpbGRLZXldLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlIaWVyYXJjaHlDaGlsZHJlbihoaWVyYXJjaHlDaGlsZCwgY2hpbGQsIHJlYywgcGl2b3RLZXlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEFnZ3JlZ2F0ZUxpc3QodmFsOiBJUGl2b3RWYWx1ZSwgZ3JpZDogUGl2b3RHcmlkVHlwZSk6IElQaXZvdEFnZ3JlZ2F0b3JbXSB7XG4gICAgICAgIGlmICghdmFsLmFnZ3JlZ2F0ZUxpc3QpIHtcbiAgICAgICAgICAgIGxldCBkZWZhdWx0QWdnciA9IHRoaXMuZ2V0QWdncmVnYXRvcnNGb3JWYWx1ZSh2YWwsIGdyaWQpO1xuICAgICAgICAgICAgY29uc3QgaXNEZWZhdWx0ID0gZGVmYXVsdEFnZ3IuZmluZChcbiAgICAgICAgICAgICAgICAoeCkgPT4geC5rZXkgPT09IHZhbC5hZ2dyZWdhdGUua2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gcmVzb2x2ZSBjdXN0b20gYWdncmVnYXRpb25zXG4gICAgICAgICAgICBpZiAoIWlzRGVmYXVsdCAmJiBncmlkLmRhdGFbMF1bdmFsLm1lbWJlcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGZpZWxkIGV4aXN0cywgdGhlbiB3ZSBjYW4gYXBwbHkgZGVmYXVsdCBhZ2dyZWdhdGlvbnMgYW5kIGFkZCB0aGUgY3VzdG9tIG9uZS5cbiAgICAgICAgICAgICAgICBkZWZhdWx0QWdnci51bnNoaWZ0KHZhbC5hZ2dyZWdhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoaXMgaXMgYSBjdXN0b20gYWdncmVnYXRpb24gdGhhdCBpcyBub3QgY29tcGF0aWJsZVxuICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIGRlZmF1bHRzLCBzaW5jZSBpdCBvcGVyYXRlcyBvbiBmaWVsZCB0aGF0IGlzIG5vdCBpbiB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIC8vIGxlYXZlIG9ubHkgdGhlIGN1c3RvbSBvbmUuXG4gICAgICAgICAgICAgICAgZGVmYXVsdEFnZ3IgPSBbdmFsLmFnZ3JlZ2F0ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWwuYWdncmVnYXRlTGlzdCA9IGRlZmF1bHRBZ2dyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWwuYWdncmVnYXRlTGlzdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEFnZ3JlZ2F0b3JzRm9yVmFsdWUodmFsdWU6IElQaXZvdFZhbHVlLCBncmlkOiBQaXZvdEdyaWRUeXBlKTogSVBpdm90QWdncmVnYXRvcltdIHtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB2YWx1ZS5kYXRhVHlwZSB8fCBncmlkLnJlc29sdmVEYXRhVHlwZXMoZ3JpZC5kYXRhWzBdW3ZhbHVlLm1lbWJlcl0pO1xuICAgICAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5DdXJyZW5jeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gSWd4UGl2b3ROdW1lcmljQWdncmVnYXRlLmFnZ3JlZ2F0b3JzKCk7XG4gICAgICAgICAgICBjYXNlIEdyaWRDb2x1bW5EYXRhVHlwZS5EYXRlOlxuICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuRGF0ZVRpbWU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIElneFBpdm90RGF0ZUFnZ3JlZ2F0ZS5hZ2dyZWdhdG9ycygpO1xuICAgICAgICAgICAgY2FzZSBHcmlkQ29sdW1uRGF0YVR5cGUuVGltZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gSWd4UGl2b3RUaW1lQWdncmVnYXRlLmFnZ3JlZ2F0b3JzKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBJZ3hQaXZvdEFnZ3JlZ2F0ZS5hZ2dyZWdhdG9ycygpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbiJdfQ==