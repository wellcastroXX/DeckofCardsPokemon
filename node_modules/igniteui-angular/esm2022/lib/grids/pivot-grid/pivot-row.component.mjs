import { ChangeDetectionStrategy, Component, forwardRef, HostBinding, Inject, Input } from '@angular/core';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxRowDirective } from '../row.directive';
import { PivotUtil } from './pivot-util';
import { IgxPivotGridCellStyleClassesPipe } from './pivot-grid.pipes';
import { IgxGridNotGroupedPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe, IgxGridTransactionStatePipe } from '../common/pipes';
import { IgxCheckboxComponent } from '../../checkbox/checkbox.component';
import { NgClass, NgStyle } from '@angular/common';
import { IgxGridCellComponent } from '../cell.component';
import { IgxGridForOfDirective } from '../../directives/for-of/for_of.directive';
import * as i0 from "@angular/core";
import * as i1 from "../selection/selection.service";
export class IgxPivotRowComponent extends IgxRowDirective {
    /**
     * @hidden
     */
    get selected() {
        let isSelected = false;
        for (const rowDim of this.data.dimensions) {
            const key = PivotUtil.getRecordKey(this.data, rowDim);
            if (this.selectionService.isPivotRowSelected(key)) {
                isSelected = true;
            }
        }
        return isSelected;
    }
    constructor(grid, selectionService, element, cdr, viewRef) {
        super(grid, selectionService, element, cdr);
        this.grid = grid;
        this.viewRef = viewRef;
        /**
         * @hidden
         * @internal
         */
        this.disabled = false;
    }
    /**
     * @hidden
     * @internal
     */
    get viewIndex() {
        return this.index;
    }
    /**
     * @hidden
     * @internal
     */
    get addRowUI() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    get inEditMode() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    set pinned(_value) {
    }
    get pinned() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    delete() {
    }
    /**
     * @hidden
     * @internal
     */
    beginAddRow() {
    }
    /**
     * @hidden
     * @internal
     */
    update(_value) {
    }
    /**
     * @hidden
     * @internal
     */
    pin() {
        return false;
    }
    /**
    * @hidden
    * @internal
    */
    unpin() {
        return false;
    }
    /**
    *  The pivot record data passed to the row component.
    *
    * ```typescript
    * // get the pivot row data for the first selected row
    * let selectedRowData = this.grid.selectedRows[0].data;
    * ```
    */
    get data() {
        return this._data;
    }
    set data(v) {
        this._data = v;
    }
    /**
     * @hidden
     * @internal
     */
    get pivotAggregationData() {
        const aggregations = this.data.aggregationValues;
        const obj = {};
        aggregations.forEach((value, key) => {
            obj[key] = value;
        });
        return obj;
    }
    getCellClass(col) {
        const values = this.grid.values;
        if (values.length === 1) {
            return values[0].styles;
        }
        const colName = col.field.split(this.grid.pivotKeys.columnDimensionSeparator);
        const measureName = colName[colName.length - 1];
        return values.find(v => v.member === measureName)?.styles;
    }
    isCellActive(visibleColumnIndex) {
        const nav = this.grid.navigation;
        const node = nav.activeNode;
        return node && Object.keys(node).length !== 0 ?
            !nav.isRowHeaderActive &&
                super.isCellActive(visibleColumnIndex) :
            false;
    }
    getColumnData(col) {
        const path = col.field.split(this.grid.pivotKeys.columnDimensionSeparator);
        const keyValueMap = new Map();
        const colDimensions = PivotUtil.flatten(this.grid.columnDimensions);
        for (const dim of colDimensions) {
            keyValueMap.set(dim.memberName, path.shift());
        }
        let pivotValue;
        if (this.grid.hasMultipleValues) {
            pivotValue = this.grid.values.find(x => x.member === path.shift());
        }
        else {
            pivotValue = this.grid.values ? this.grid.values[0] : undefined;
        }
        return {
            field: col.field,
            dimensions: this.grid.columnDimensions,
            dimensionValues: keyValueMap,
            value: pivotValue
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotRowComponent, deps: [{ token: IGX_GRID_BASE }, { token: i1.IgxGridSelectionService }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: IgxPivotRowComponent, isStandalone: true, selector: "igx-pivot-row", inputs: { selected: "selected", data: "data" }, host: { properties: { "attr.aria-selected": "this.selected" } }, providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxPivotRowComponent) }], usesInheritance: true, ngImport: i0, template: "<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\"\n    [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"'\n    [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth'\n    [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-grid-cell #cell class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"key | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.gridAPI.crudService.cell:grid.gridAPI.crudService.row\"\n\n        [class.igx-grid__td--number]=\"col.dataType === 'number' || col.dataType === 'percent' || col.dataType === 'currency'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"this.getCellClass(col) | igxPivotCellStyleClasses:data[col.field]:data:getColumnData(col):viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:pivotAggregationData[col.field]:pivotAggregationData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && this.grid.crudService.targetInEdit(index, col.index)\" [column]=\"col\"\n        [formatter]=\"col.formatter\" [intRow]=\"this\" [active]=\"isCellActive(col.visibleIndex)\"\n        [style.min-height.px]=\"cellHeight\" [rowData]=\"data\" [columnData]='getColumnData(col)'\n        [style.min-width]=\"col.resolvedWidth\" [style.max-width]=\"col.resolvedWidth\"\n        [style.flex-basis]=\"col.resolvedWidth\" [width]=\"col.getCellWidth()\" [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"pivotAggregationData[col.field] | dataMapper:col.field:grid.pipeTrigger:pivotAggregationData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\" [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox [tabindex]=\"-1\" [readonly]=\"true\" [checked]=\"selected\" [disableRipple]=\"true\" [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n", dependencies: [{ kind: "directive", type: IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { kind: "component", type: IgxGridCellComponent, selector: "igx-grid-cell", inputs: ["column", "intRow", "row", "rowData", "columnData", "cellTemplate", "cellValidationErrorTemplate", "pinnedIndicator", "value", "formatter", "visibleColumnIndex", "cellSelectionMode", "lastSearchInfo", "lastPinned", "firstPinned", "editMode", "width", "active", "displayPinnedChip"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: IgxCheckboxComponent, selector: "igx-checkbox", inputs: ["id", "labelId", "value", "name", "tabindex", "labelPosition", "disableRipple", "required", "aria-labelledby", "aria-label", "indeterminate", "checked", "disabled", "invalid", "readonly", "disableTransitions"], outputs: ["change"] }, { kind: "pipe", type: IgxGridNotGroupedPipe, name: "igxNotGrouped" }, { kind: "pipe", type: IgxGridCellStylesPipe, name: "igxCellStyles" }, { kind: "pipe", type: IgxGridDataMapperPipe, name: "dataMapper" }, { kind: "pipe", type: IgxGridTransactionStatePipe, name: "transactionState" }, { kind: "pipe", type: IgxPivotGridCellStyleClassesPipe, name: "igxPivotCellStyleClasses" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotRowComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-pivot-row', providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxPivotRowComponent) }], standalone: true, imports: [IgxGridForOfDirective, IgxGridCellComponent, NgClass, NgStyle, IgxCheckboxComponent, IgxGridNotGroupedPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe, IgxGridTransactionStatePipe, IgxPivotGridCellStyleClassesPipe], template: "<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\"\n    [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"'\n    [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth'\n    [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-grid-cell #cell class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"key | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.gridAPI.crudService.cell:grid.gridAPI.crudService.row\"\n\n        [class.igx-grid__td--number]=\"col.dataType === 'number' || col.dataType === 'percent' || col.dataType === 'currency'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"this.getCellClass(col) | igxPivotCellStyleClasses:data[col.field]:data:getColumnData(col):viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:pivotAggregationData[col.field]:pivotAggregationData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && this.grid.crudService.targetInEdit(index, col.index)\" [column]=\"col\"\n        [formatter]=\"col.formatter\" [intRow]=\"this\" [active]=\"isCellActive(col.visibleIndex)\"\n        [style.min-height.px]=\"cellHeight\" [rowData]=\"data\" [columnData]='getColumnData(col)'\n        [style.min-width]=\"col.resolvedWidth\" [style.max-width]=\"col.resolvedWidth\"\n        [style.flex-basis]=\"col.resolvedWidth\" [width]=\"col.getCellWidth()\" [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"pivotAggregationData[col.field] | dataMapper:col.field:grid.pipeTrigger:pivotAggregationData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\" [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox [tabindex]=\"-1\" [readonly]=\"true\" [checked]=\"selected\" [disableRipple]=\"true\" [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n" }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: i1.IgxGridSelectionService }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.ViewContainerRef }], propDecorators: { selected: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.aria-selected']
            }], data: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3Qtcm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LXJvdy5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvcGl2b3QtZ3JpZC9waXZvdC1yb3cuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBRVQsVUFBVSxFQUNWLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUM3QixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsYUFBYSxFQUFpQixNQUFNLDBCQUEwQixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUduRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxnQ0FBZ0MsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25JLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbkQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDekQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sMENBQTBDLENBQUM7OztBQVVqRixNQUFNLE9BQU8sb0JBQXFCLFNBQVEsZUFBZTtJQUNyRDs7T0FFRztJQUNILElBRW9CLFFBQVE7UUFDeEIsSUFBSSxVQUFV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O3VCQUFDLG9CQUFvQjtnQkE2R2IsSUFBSTtzQkFEdkIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgZm9yd2FyZFJlZixcbiAgICBIb3N0QmluZGluZywgSW5qZWN0LCBJbnB1dCwgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4uL2NvbHVtbnMvY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJR1hfR1JJRF9CQVNFLCBQaXZvdEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneFJvd0RpcmVjdGl2ZSB9IGZyb20gJy4uL3Jvdy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuLi9zZWxlY3Rpb24vc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSVBpdm90R3JpZENvbHVtbiwgSVBpdm90R3JpZFJlY29yZCB9IGZyb20gJy4vcGl2b3QtZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUGl2b3RVdGlsIH0gZnJvbSAnLi9waXZvdC11dGlsJztcbmltcG9ydCB7IElneFBpdm90R3JpZENlbGxTdHlsZUNsYXNzZXNQaXBlIH0gZnJvbSAnLi9waXZvdC1ncmlkLnBpcGVzJztcbmltcG9ydCB7IElneEdyaWROb3RHcm91cGVkUGlwZSwgSWd4R3JpZENlbGxTdHlsZXNQaXBlLCBJZ3hHcmlkRGF0YU1hcHBlclBpcGUsIElneEdyaWRUcmFuc2FjdGlvblN0YXRlUGlwZSB9IGZyb20gJy4uL2NvbW1vbi9waXBlcyc7XG5pbXBvcnQgeyBJZ3hDaGVja2JveENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOZ0NsYXNzLCBOZ1N0eWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IElneEdyaWRDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi4vY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZEZvck9mRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLmRpcmVjdGl2ZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHNlbGVjdG9yOiAnaWd4LXBpdm90LXJvdycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3Bpdm90LXJvdy5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBJZ3hSb3dEaXJlY3RpdmUsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElneFBpdm90Um93Q29tcG9uZW50KSB9XSxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtJZ3hHcmlkRm9yT2ZEaXJlY3RpdmUsIElneEdyaWRDZWxsQ29tcG9uZW50LCBOZ0NsYXNzLCBOZ1N0eWxlLCBJZ3hDaGVja2JveENvbXBvbmVudCwgSWd4R3JpZE5vdEdyb3VwZWRQaXBlLCBJZ3hHcmlkQ2VsbFN0eWxlc1BpcGUsIElneEdyaWREYXRhTWFwcGVyUGlwZSwgSWd4R3JpZFRyYW5zYWN0aW9uU3RhdGVQaXBlLCBJZ3hQaXZvdEdyaWRDZWxsU3R5bGVDbGFzc2VzUGlwZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4UGl2b3RSb3dDb21wb25lbnQgZXh0ZW5kcyBJZ3hSb3dEaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXNlbGVjdGVkJylcbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IHNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHJvd0RpbSBvZiB0aGlzLmRhdGEuZGltZW5zaW9ucykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gUGl2b3RVdGlsLmdldFJlY29yZEtleSh0aGlzLmRhdGEsIHJvd0RpbSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzUGl2b3RSb3dTZWxlY3RlZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoSUdYX0dSSURfQkFTRSkgcHVibGljIG92ZXJyaWRlIGdyaWQ6IFBpdm90R3JpZFR5cGUsXG4gICAgICAgIHNlbGVjdGlvblNlcnZpY2U6IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBlbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJvdGVjdGVkIHZpZXdSZWY6IFZpZXdDb250YWluZXJSZWZcbiAgICApIHtcbiAgICAgICAgc3VwZXIoZ3JpZCwgc2VsZWN0aW9uU2VydmljZSwgZWxlbWVudCwgY2RyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCB2aWV3SW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgYWRkUm93VUkoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IGluRWRpdE1vZGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIHNldCBwaW5uZWQoX3ZhbHVlOiBib29sZWFuKSB7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCBwaW5uZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGRlbGV0ZSgpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGJlZ2luQWRkUm93KCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdXBkYXRlKF92YWx1ZTogYW55KSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBwaW4oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIHVucGluKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiAgVGhlIHBpdm90IHJlY29yZCBkYXRhIHBhc3NlZCB0byB0aGUgcm93IGNvbXBvbmVudC5cbiAgICAqXG4gICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgKiAvLyBnZXQgdGhlIHBpdm90IHJvdyBkYXRhIGZvciB0aGUgZmlyc3Qgc2VsZWN0ZWQgcm93XG4gICAgKiBsZXQgc2VsZWN0ZWRSb3dEYXRhID0gdGhpcy5ncmlkLnNlbGVjdGVkUm93c1swXS5kYXRhO1xuICAgICogYGBgXG4gICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgZGF0YSgpOiBJUGl2b3RHcmlkUmVjb3JkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHNldCBkYXRhKHY6IElQaXZvdEdyaWRSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcGl2b3RBZ2dyZWdhdGlvbkRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGFnZ3JlZ2F0aW9ucyA9IHRoaXMuZGF0YS5hZ2dyZWdhdGlvblZhbHVlcztcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGFnZ3JlZ2F0aW9ucy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q2VsbENsYXNzKGNvbDogSWd4Q29sdW1uQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuZ3JpZC52YWx1ZXM7XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzWzBdLnN0eWxlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xOYW1lID0gY29sLmZpZWxkLnNwbGl0KHRoaXMuZ3JpZC5waXZvdEtleXMuY29sdW1uRGltZW5zaW9uU2VwYXJhdG9yKTtcbiAgICAgICAgY29uc3QgbWVhc3VyZU5hbWUgPSBjb2xOYW1lW2NvbE5hbWUubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB2YWx1ZXMuZmluZCh2ID0+IHYubWVtYmVyID09PSBtZWFzdXJlTmFtZSk/LnN0eWxlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgaXNDZWxsQWN0aXZlKHZpc2libGVDb2x1bW5JbmRleCkge1xuICAgICAgICBjb25zdCBuYXYgPSB0aGlzLmdyaWQubmF2aWdhdGlvblxuICAgICAgICBjb25zdCBub2RlID0gbmF2LmFjdGl2ZU5vZGU7XG4gICAgICAgIHJldHVybiBub2RlICYmIE9iamVjdC5rZXlzKG5vZGUpLmxlbmd0aCAhPT0gMCA/XG4gICAgICAgICAgICAhbmF2LmlzUm93SGVhZGVyQWN0aXZlICYmXG4gICAgICAgICAgICBzdXBlci5pc0NlbGxBY3RpdmUodmlzaWJsZUNvbHVtbkluZGV4KSA6XG4gICAgICAgICAgICBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q29sdW1uRGF0YShjb2w6IElneENvbHVtbkNvbXBvbmVudCkgOiBJUGl2b3RHcmlkQ29sdW1uIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGNvbC5maWVsZC5zcGxpdCh0aGlzLmdyaWQucGl2b3RLZXlzLmNvbHVtbkRpbWVuc2lvblNlcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGtleVZhbHVlTWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICAgICAgY29uc3QgY29sRGltZW5zaW9ucyA9IFBpdm90VXRpbC5mbGF0dGVuKHRoaXMuZ3JpZC5jb2x1bW5EaW1lbnNpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBkaW0gb2YgY29sRGltZW5zaW9ucykge1xuICAgICAgICAgICAga2V5VmFsdWVNYXAuc2V0KGRpbS5tZW1iZXJOYW1lLCBwYXRoLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwaXZvdFZhbHVlO1xuICAgICAgICBpZiAodGhpcy5ncmlkLmhhc011bHRpcGxlVmFsdWVzKSB7XG4gICAgICAgICAgICBwaXZvdFZhbHVlID0gdGhpcy5ncmlkLnZhbHVlcy5maW5kKHggPT4geC5tZW1iZXIgPT09IHBhdGguc2hpZnQoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwaXZvdFZhbHVlID0gdGhpcy5ncmlkLnZhbHVlcyA/IHRoaXMuZ3JpZC52YWx1ZXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2wuZmllbGQsXG4gICAgICAgICAgICBkaW1lbnNpb25zOiB0aGlzLmdyaWQuY29sdW1uRGltZW5zaW9ucyxcbiAgICAgICAgICAgIGRpbWVuc2lvblZhbHVlczoga2V5VmFsdWVNYXAsXG4gICAgICAgICAgICB2YWx1ZTogcGl2b3RWYWx1ZVxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsIjxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yIGxldC1jb2wgW2lneEdyaWRGb3JPZl09XCJ1bnBpbm5lZENvbHVtbnMgfCBpZ3hOb3RHcm91cGVkXCJcbiAgICBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT1cImdyaWQucGFyZW50VmlydERpclwiIGxldC1jb2xJbmRleD1cImluZGV4XCIgW2lneEZvclNpemVQcm9wTmFtZV09J1wiY2FsY1BpeGVsV2lkdGhcIidcbiAgICBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgW2lneEZvckNvbnRhaW5lclNpemVdPSdncmlkLnVucGlubmVkV2lkdGgnXG4gICAgW2lneEZvclRyYWNrQnldPSdncmlkLnRyYWNrQ29sdW1uQ2hhbmdlcycgI2lneERpclJlZj5cbiAgICA8aWd4LWdyaWQtY2VsbCAjY2VsbCBjbGFzcz1cImlneC1ncmlkX190ZCBpZ3gtZ3JpZF9fdGQtLWZ3XCJcbiAgICAgICAgW2NsYXNzLmlneC1ncmlkX190ZC0tZWRpdGVkXT1cImtleSB8IHRyYW5zYWN0aW9uU3RhdGU6Y29sLmZpZWxkOmdyaWQucm93RWRpdGFibGU6Z3JpZC50cmFuc2FjdGlvbnM6Z3JpZC5waXBlVHJpZ2dlcjpncmlkLmdyaWRBUEkuY3J1ZFNlcnZpY2UuY2VsbDpncmlkLmdyaWRBUEkuY3J1ZFNlcnZpY2Uucm93XCJcblxuICAgICAgICBbY2xhc3MuaWd4LWdyaWRfX3RkLS1udW1iZXJdPVwiY29sLmRhdGFUeXBlID09PSAnbnVtYmVyJyB8fCBjb2wuZGF0YVR5cGUgPT09ICdwZXJjZW50JyB8fCBjb2wuZGF0YVR5cGUgPT09ICdjdXJyZW5jeSdcIlxuICAgICAgICBbY2xhc3MuaWd4LWdyaWRfX3RkLS1ib29sXT1cImNvbC5kYXRhVHlwZSA9PT0gJ2Jvb2xlYW4nXCJcbiAgICAgICAgW25nQ2xhc3NdPVwidGhpcy5nZXRDZWxsQ2xhc3MoY29sKSB8IGlneFBpdm90Q2VsbFN0eWxlQ2xhc3NlczpkYXRhW2NvbC5maWVsZF06ZGF0YTpnZXRDb2x1bW5EYXRhKGNvbCk6dmlld0luZGV4OmdyaWQucGlwZVRyaWdnZXJcIlxuICAgICAgICBbbmdTdHlsZV09XCJjb2wuY2VsbFN0eWxlcyB8IGlneENlbGxTdHlsZXM6cGl2b3RBZ2dyZWdhdGlvbkRhdGFbY29sLmZpZWxkXTpwaXZvdEFnZ3JlZ2F0aW9uRGF0YTpjb2wuZmllbGQ6dmlld0luZGV4OmdyaWQucGlwZVRyaWdnZXJcIlxuICAgICAgICBbZWRpdE1vZGVdPVwiY29sLmVkaXRhYmxlICYmIHRoaXMuZ3JpZC5jcnVkU2VydmljZS50YXJnZXRJbkVkaXQoaW5kZXgsIGNvbC5pbmRleClcIiBbY29sdW1uXT1cImNvbFwiXG4gICAgICAgIFtmb3JtYXR0ZXJdPVwiY29sLmZvcm1hdHRlclwiIFtpbnRSb3ddPVwidGhpc1wiIFthY3RpdmVdPVwiaXNDZWxsQWN0aXZlKGNvbC52aXNpYmxlSW5kZXgpXCJcbiAgICAgICAgW3N0eWxlLm1pbi1oZWlnaHQucHhdPVwiY2VsbEhlaWdodFwiIFtyb3dEYXRhXT1cImRhdGFcIiBbY29sdW1uRGF0YV09J2dldENvbHVtbkRhdGEoY29sKSdcbiAgICAgICAgW3N0eWxlLm1pbi13aWR0aF09XCJjb2wucmVzb2x2ZWRXaWR0aFwiIFtzdHlsZS5tYXgtd2lkdGhdPVwiY29sLnJlc29sdmVkV2lkdGhcIlxuICAgICAgICBbc3R5bGUuZmxleC1iYXNpc109XCJjb2wucmVzb2x2ZWRXaWR0aFwiIFt3aWR0aF09XCJjb2wuZ2V0Q2VsbFdpZHRoKClcIiBbdmlzaWJsZUNvbHVtbkluZGV4XT1cImNvbC52aXNpYmxlSW5kZXhcIlxuICAgICAgICBbdmFsdWVdPVwicGl2b3RBZ2dyZWdhdGlvbkRhdGFbY29sLmZpZWxkXSB8IGRhdGFNYXBwZXI6Y29sLmZpZWxkOmdyaWQucGlwZVRyaWdnZXI6cGl2b3RBZ2dyZWdhdGlvbkRhdGFbY29sLmZpZWxkXTpjb2wuaGFzTmVzdGVkUGF0aFwiXG4gICAgICAgIFtjZWxsVGVtcGxhdGVdPVwiY29sLmJvZHlUZW1wbGF0ZVwiIFtsYXN0U2VhcmNoSW5mb109XCJncmlkLmxhc3RTZWFyY2hJbmZvXCJcbiAgICAgICAgW2NlbGxTZWxlY3Rpb25Nb2RlXT1cImdyaWQuY2VsbFNlbGVjdGlvblwiIFtkaXNwbGF5UGlubmVkQ2hpcF09XCJzaG91bGREaXNwbGF5UGlubmVkQ2hpcChjb2wudmlzaWJsZUluZGV4KVwiXG4gICAgICAgIChwb2ludGVyZG93bik9XCJncmlkLm5hdmlnYXRpb24uZm9jdXNPdXRSb3dIZWFkZXIoJGV2ZW50KVwiPlxuICAgIDwvaWd4LWdyaWQtY2VsbD5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjcm93U2VsZWN0b3JCYXNlVGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19jYngtcGFkZGluZ1wiPlxuICAgICAgICA8aWd4LWNoZWNrYm94IFt0YWJpbmRleF09XCItMVwiIFtyZWFkb25seV09XCJ0cnVlXCIgW2NoZWNrZWRdPVwic2VsZWN0ZWRcIiBbZGlzYWJsZVJpcHBsZV09XCJ0cnVlXCIgW2Rpc2FibGVkXT1cImRlbGV0ZWRcIlxuICAgICAgICAgICAgW2Rpc2FibGVUcmFuc2l0aW9uc109XCJncmlkLmRpc2FibGVUcmFuc2l0aW9uc1wiIFthcmlhLWxhYmVsXT1cInJvd0NoZWNrYm94QXJpYUxhYmVsXCI+XG4gICAgICAgIDwvaWd4LWNoZWNrYm94PlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuIl19