import { ChangeDetectionStrategy, Component, Inject, ViewChild, ViewChildren } from '@angular/core';
import { IgxChipComponent } from '../../chips/chip.component';
import { IgxChipsAreaComponent } from '../../chips/chips-area.component';
import { SortingDirection } from '../../data-operations/sorting-strategy';
import { IgxGridForOfDirective } from '../../directives/for-of/for_of.directive';
import { IgxDropDownComponent } from '../../drop-down/drop-down.component';
import { AbsoluteScrollStrategy, AutoPositionStrategy, VerticalAlignment } from '../../services/public_api';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxGridHeaderGroupComponent } from '../headers/grid-header-group.component';
import { IgxGridHeaderRowComponent } from '../headers/grid-header-row.component';
import { DropPosition } from '../moving/moving.service';
import { PivotUtil } from './pivot-util';
import { IgxGridTopLevelColumns } from '../common/pipes';
import { IgxHeaderGroupWidthPipe, IgxHeaderGroupStylePipe } from '../headers/pipes';
import { IgxExcelStyleSearchComponent } from '../filtering/excel-style/excel-style-search.component';
import { IgxGridExcelStyleFilteringComponent, IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleFilterOperationsTemplateDirective } from '../filtering/excel-style/excel-style-filtering.component';
import { IgxDropDownItemComponent } from '../../drop-down/drop-down-item.component';
import { IgxDropDownItemNavigationDirective } from '../../drop-down/drop-down-navigation.directive';
import { IgxSuffixDirective } from '../../directives/suffix/suffix.directive';
import { IgxBadgeComponent } from '../../badge/badge.component';
import { IgxPrefixDirective } from '../../directives/prefix/prefix.directive';
import { IgxIconComponent } from '../../icon/icon.component';
import { IgxDropDirective } from '../../directives/drag-drop/drag-drop.directive';
import { NgIf, NgFor, NgTemplateOutlet, NgClass, NgStyle } from '@angular/common';
import * as i0 from "@angular/core";
/**
 *
 * For all intents & purposes treat this component as what a <thead> usually is in the default <table> element.
 *
 * This container holds the pivot grid header elements and their behavior/interactions.
 *
 * @hidden @internal
 */
export class IgxPivotHeaderRowComponent extends IgxGridHeaderRowComponent {
    get headerForOf() {
        return this.headerContainers.last;
    }
    constructor(grid, ref, cdr, renderer) {
        super(ref, cdr);
        this.grid = grid;
        this.renderer = renderer;
        this.aggregateList = [];
        this.filterDropdownDimensions = new Set();
        this.filterAreaDimensions = new Set();
        this._dropPos = DropPosition.AfterDropTarget;
        this._subMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Bottom,
            closeAnimation: undefined
        };
        this._subMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        /**
        * @hidden
        * @internal
        * Default is a single empty level since default depth is 1
        */
        this.columnDimensionsByLevel = [[]];
    }
    /**
    * @hidden @internal
    */
    get isFiltersButton() {
        let chipsWidth = 0;
        this.filterDropdownDimensions.clear();
        this.filterAreaDimensions.clear();
        if (this.filterArea?.chipsList && this.filterArea.chipsList.length !== 0) {
            const styles = getComputedStyle(this.pivotFilterContainer.nativeElement);
            const containerPaddings = parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
            chipsWidth += containerPaddings + (this.filtersButton && this.filterArea?.chipsList.length > 1 ? this.filtersButton.el.nativeElement.getBoundingClientRect().width : 0);
            this.filterArea.chipsList.forEach(chip => {
                const dim = this.grid.filterDimensions.find(x => x.memberName === chip.id);
                if (dim) {
                    // 8 px margin between chips
                    const currentChipWidth = chip.nativeElement.getBoundingClientRect().width + 8;
                    if (chipsWidth + currentChipWidth < this.grid.pivotRowWidths) {
                        this.filterAreaDimensions.add(dim);
                    }
                    else {
                        this.filterDropdownDimensions.add(dim);
                    }
                    chipsWidth += currentChipWidth;
                }
            });
            return this.filterDropdownDimensions.size > 0;
        }
        return false;
    }
    /**
    * @hidden
    * @internal
    */
    get totalDepth() {
        const columnDimensions = this.grid.columnDimensions;
        if (columnDimensions.length === 0) {
            return 1;
        }
        let totalDepth = columnDimensions.map(x => PivotUtil.getDimensionDepth(x) + 1).reduce((acc, val) => acc + val);
        if (this.grid.hasMultipleValues) {
            totalDepth += 1;
        }
        return totalDepth;
    }
    /**
    * @hidden
    * @internal
    */
    get maxContainerHeight() {
        return this.totalDepth * this.grid.renderedRowHeight;
    }
    /**
    * @hidden
    * @internal
    */
    calcHeight(col, index) {
        return !col.columnGroup && col.level < this.totalDepth && col.level === index ? (this.totalDepth - col.level) * this.grid.rowHeight : this.grid.rowHeight;
    }
    /**
    * @hidden
    * @internal
    */
    isDuplicateOfExistingParent(col, lvl) {
        const parentCollection = lvl > 0 ? this.columnDimensionsByLevel[lvl - 1] : [];
        const duplicate = parentCollection.indexOf(col) !== -1;
        return duplicate;
    }
    /**
    * @hidden
    * @internal
    */
    isMultiRow(col, lvl) {
        const isLeaf = !col.columnGroup;
        return isLeaf && lvl !== this.totalDepth - 1;
    }
    /**
    * @hidden
    * @internal
    */
    populateColumnDimensionsByLevel() {
        const res = [];
        for (let i = 0; i < this.totalDepth; i++) {
            res[i] = [];
        }
        const cols = this.unpinnedColumnCollection;
        // populate column dimension matrix recursively
        this.populateDimensionRecursively(cols.filter(x => x.level === 0), 0, res);
        this.columnDimensionsByLevel = res;
    }
    populateDimensionRecursively(currentLevelColumns, level = 0, res) {
        currentLevelColumns.forEach(col => {
            if (res[level]) {
                res[level].push(col);
                if (col.columnGroup && col.children.length > 0) {
                    const visibleColumns = col.children.toArray().filter(x => !x.hidden);
                    this.populateDimensionRecursively(visibleColumns, level + 1, res);
                }
                else if (level < this.totalDepth - 1) {
                    for (let i = level + 1; i <= this.totalDepth - 1; i++) {
                        res[i].push(col);
                    }
                }
            }
        });
    }
    /**
    * @hidden
    * @internal
    */
    ngOnChanges(changes) {
        if (changes.unpinnedColumnCollection) {
            this.populateColumnDimensionsByLevel();
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragStart(event, area) {
        this.cdr.detectChanges();
        for (const chip of this.notificationChips) {
            const parent = chip.nativeElement.parentElement;
            if (area.chipsList.toArray().indexOf(chip) === -1 &&
                parent.children.length > 0 &&
                parent.children.item(0).id !== 'empty') {
                chip.nativeElement.hidden = false;
                parent.parentElement.scrollTo({ left: chip.nativeElement.offsetLeft });
            }
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragEnd() {
        for (const chip of this.notificationChips) {
            chip.nativeElement.hidden = true;
        }
    }
    /**
    * @hidden
    * @internal
    */
    getAreaHeight(area) {
        const chips = area.chipsList;
        return chips && chips.length > 0 ? chips.first.nativeElement.offsetHeight : 0;
    }
    /**
    * @hidden
    * @internal
    */
    rowRemoved(event) {
        const row = this.grid.pivotConfiguration.rows.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(row);
    }
    /**
    * @hidden
    * @internal
    */
    columnRemoved(event) {
        const col = this.grid.pivotConfiguration.columns.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(col);
    }
    /**
    * @hidden
    * @internal
    */
    valueRemoved(event) {
        const value = this.grid.pivotConfiguration.values.find(x => x.member === event.owner.id || x.displayName === event.owner.id);
        this.grid.toggleValue(value);
    }
    /**
    * @hidden
    * @internal
    */
    filterRemoved(event) {
        const filter = this.grid.pivotConfiguration.filters.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(filter);
        if (this.filterDropdownDimensions.size > 0) {
            this.onFiltersAreaDropdownClick({ target: this.filtersButton.el.nativeElement }, undefined, false);
        }
        else {
            this.grid.filteringService.hideESF();
        }
    }
    onFiltersSelectionChanged(event) {
        this.dropdownChips.chipsList.forEach(chip => {
            if (chip.id !== event.owner.id) {
                chip.selected = false;
            }
        });
        this.onFiltersAreaDropdownClick({ target: this.filtersButton.el.nativeElement }, this.grid.filterDimensions.find(dim => dim.memberName === event.owner.id), false);
    }
    /**
    * @hidden
    * @internal
    */
    onFilteringIconPointerDown(event) {
        event.stopPropagation();
        event.preventDefault();
    }
    /**
    * @hidden
    * @internal
    */
    onFilteringIconClick(event, dimension) {
        event.stopPropagation();
        event.preventDefault();
        const dim = dimension;
        const col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName || x.field === dim.member);
        this.grid.filteringService.toggleFilterDropdown(event.target, col);
    }
    /**
    * @hidden
    * @internal
    */
    onSummaryClick(eventArgs, value, dropdown, chip) {
        this._subMenuOverlaySettings.target = eventArgs.currentTarget;
        this.updateDropDown(value, dropdown, chip);
    }
    /**
     * @hidden @internal
     */
    onFiltersAreaDropdownClick(event, dimension, shouldReattach = true) {
        const dim = dimension || this.filterDropdownDimensions.values().next().value;
        const col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName || x.field === dim.member);
        if (shouldReattach) {
            this.dropdownChips.chipsList.forEach(chip => {
                chip.selected = false;
            });
            this.dropdownChips.chipsList.first.selected = true;
        }
        this.grid.filteringService.toggleFiltersESF(this.esf, event.target, col, shouldReattach);
    }
    /**
    * @hidden
    * @internal
    */
    onAggregationChange(event) {
        if (!this.isSelected(event.newSelection.value)) {
            this.value.aggregate = event.newSelection.value;
            this.grid.pipeTrigger++;
        }
    }
    /**
    * @hidden
    * @internal
    */
    isSelected(val) {
        return this.value.aggregate.key === val.key;
    }
    /**
    * @hidden
    * @internal
    */
    onChipSort(_event, dimension) {
        const startDirection = dimension.sortDirection || SortingDirection.None;
        const direction = startDirection + 1 > SortingDirection.Desc ?
            SortingDirection.None : startDirection + 1;
        this.grid.sortDimension(dimension, direction);
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragOver(event, dimension) {
        if (!event.dragChip || !event.dragChip.data?.pivotArea)
            return;
        const typeMismatch = dimension !== undefined ? this.grid.pivotConfiguration.values.find(x => x.member === event.dragChip.id
            || x.displayName === event.dragChip.id) :
            !this.grid.pivotConfiguration.values.find(x => x.member === event.dragChip.id || x.displayName === event.dragChip.id);
        if (typeMismatch) {
            // cannot drag between dimensions and value
            return;
        }
        // if we are in the left half of the chip, drop on the left
        // else drop on the right of the chip
        const clientRect = event.owner.nativeElement.getBoundingClientRect();
        const pos = clientRect.width / 2;
        this._dropPos = event.originalEvent.offsetX > pos ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
        if (this._dropPos === DropPosition.AfterDropTarget) {
            event.owner.nativeElement.previousElementSibling.style.visibility = 'hidden';
            event.owner.nativeElement.nextElementSibling.style.visibility = '';
        }
        else {
            event.owner.nativeElement.nextElementSibling.style.visibility = 'hidden';
            event.owner.nativeElement.previousElementSibling.style.visibility = '';
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragLeave(event) {
        event.owner.nativeElement.previousElementSibling.style.visibility = 'hidden';
        event.owner.nativeElement.nextElementSibling.style.visibility = 'hidden';
        this._dropPos = DropPosition.AfterDropTarget;
    }
    /**
    * @hidden
    * @internal
    */
    onAreaDragLeave(event, area) {
        const dataChips = area.chipsList.toArray().filter(x => this.notificationChips.toArray().indexOf(x) === -1);
        dataChips.forEach(element => {
            if (element.nativeElement.previousElementSibling) {
                element.nativeElement.previousElementSibling.style.visibility = 'hidden';
            }
            if (element.nativeElement.nextElementSibling) {
                element.nativeElement.nextElementSibling.style.visibility = 'hidden';
            }
        });
    }
    /**
    * @hidden
    * @internal
    */
    onValueDrop(event, area) {
        if (!(event.dragChip && event.dragChip.data?.pivotArea) && !(event.dragData?.chip && !!event.dragData.chip.data.pivotArea))
            return;
        //values can only be reordered
        const values = this.grid.pivotConfiguration.values;
        const dragId = event.dragChip?.id || event.dragData?.chip.id;
        const chipsArray = area.chipsList.toArray();
        let chipIndex = chipsArray.indexOf(event.owner) !== -1 ? chipsArray.indexOf(event.owner) : chipsArray.length;
        chipIndex = this._dropPos === DropPosition.AfterDropTarget ? chipIndex + 1 : chipIndex;
        const value = values.find(x => x.member === dragId || x.displayName === dragId);
        if (value) {
            const dragChipIndex = chipsArray.indexOf(event.dragChip || event.dragData.chip);
            this.grid.moveValue(value, dragChipIndex >= chipIndex ? chipIndex : chipIndex - 1);
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDrop(event, area, dimensionType) {
        if (!(event.dragChip && event.dragChip.data?.pivotArea) && !(event.dragData?.chip && !!event.dragData.chip.data.pivotArea))
            return;
        const dragId = event.dragChip?.id || event.dragData?.chip.id;
        const currentDim = this.grid.getDimensionsByType(dimensionType);
        const chipsArray = area.chipsList.toArray();
        const chip = chipsArray.find(x => x.id === dragId);
        const isNewChip = chip === undefined;
        const isReorder = event.owner.id !== undefined;
        //const chipIndex = chipsArray.indexOf(event.owner) !== -1 ? chipsArray.indexOf(event.owner) : chipsArray.length;
        const chipIndex = currentDim.findIndex(x => x.memberName === event.owner.id) !== -1 ?
            currentDim.findIndex(x => x.memberName === event.owner.id) : currentDim.length;
        const targetIndex = this._dropPos === DropPosition.AfterDropTarget ? chipIndex + 1 : chipIndex;
        if (isNewChip) {
            // chip moved from an external collection
            const dim = this.grid.allDimensions.find(x => x && x.memberName === dragId);
            if (!dim) {
                // you have dragged something that is not a dimension
                return;
            }
            this.grid.moveDimension(dim, dimensionType, targetIndex);
        }
        else if (isReorder) {
            // chip from same collection, reordered.
            const newDim = currentDim.find(x => x.memberName === dragId);
            const dragChipIndex = currentDim.findIndex(x => x.memberName === dragId);
            this.grid.moveDimension(newDim, dimensionType, dragChipIndex > chipIndex ? targetIndex : targetIndex - 1);
        }
        this.grid.pipeTrigger++;
        this.grid.dimensionsChange.emit({ dimensions: currentDim, dimensionCollectionType: dimensionType });
        // clean states
        this.onDimDragEnd();
        this.onAreaDragLeave(event, area);
    }
    updateDropDown(value, dropdown, chip) {
        this.value = value;
        dropdown.width = chip.nativeElement.clientWidth + 'px';
        this.aggregateList = PivotUtil.getAggregateList(value, this.grid);
        this.cdr.detectChanges();
        dropdown.open(this._subMenuOverlaySettings);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotHeaderRowComponent, deps: [{ token: IGX_GRID_BASE }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: IgxPivotHeaderRowComponent, isStandalone: true, selector: "igx-pivot-header-row", viewQueries: [{ propertyName: "esf", first: true, predicate: ["esf"], descendants: true }, { propertyName: "filterArea", first: true, predicate: ["filterAreaHidden"], descendants: true }, { propertyName: "filtersButton", first: true, predicate: ["filterIcon"], descendants: true }, { propertyName: "dropdownChips", first: true, predicate: ["dropdownChips"], descendants: true }, { propertyName: "pivotFilterContainer", first: true, predicate: ["pivotFilterContainer"], descendants: true }, { propertyName: "notificationChips", predicate: ["notifyChip"], descendants: true }, { propertyName: "headerContainers", predicate: ["headerVirtualContainer"], descendants: true, read: IgxGridForOfDirective }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div>\n    <div class=\"igx-grid-thead__wrapper igx-grid-thead__wrapper--pivot\" role=\"row\" [style.width.px]=\"width\">\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div class='igx-grid__tr-pivot--filter-container'>\n                <div #pivotFilterContainer *ngIf=\"grid.showPivotConfigurationUI\"\n                     class=\"igx-grid__tr-pivot igx-grid__tr-pivot--filter\" [style.min-width.px]=\"grid.pivotRowWidths - 1\"\n                     [style.max-width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, filterArea)\"\n                     igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\" (pointerdown)=\"$event.preventDefault()\">\n                    <!-- Filter area -->\n                    <igx-chips-area #filterArea droppable='true'>\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\"\n                          *ngIf=\"grid.filterDimensions.length === 0\"\n                          class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_filter_drop_area}}</span>\n                        <ng-container *ngFor=\"let filter of this.filterAreaDimensions; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(filterArea)'></span>\n                            <igx-chip [id]=\"filter.memberName\" [draggable]=\"true\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'filter' }\"\n                                      [removable]=\"true\" (remove)=\"filterRemoved($event)\" (dragOver)=\"onDimDragOver($event, 2)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, filterArea, 2)\"\n                                      (moveStart)='onDimDragStart($event, filterArea)' (moveEnd)='onDimDragEnd()'>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, filter)'>filter_list</igx-icon>\n                                {{filter.displayName || filter.memberName}}\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(filterArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, filterArea, 2)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_filter_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                    <div class=\"igx-grid__pivot-filter-toggle\" *ngIf=\"isFiltersButton && grid.filterDimensions.length !== 0\">\n                        <igx-icon #filterIcon (pointerdown)='onFilteringIconPointerDown($event)' (click)='onFiltersAreaDropdownClick($event)'>filter_list</igx-icon>\n                        <igx-badge value=\"{{this.filterDropdownDimensions.size}}\"></igx-badge>\n                    </div>\n                </div>\n                <div class='igx-grid__tr-pivot--drop-row-area' (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                     (dropped)=\"onDimDrop($event, rowArea, 0)\">\n                </div>\n            </div>\n\n            <div class=\"igx-grid__tr-pivot-group\">\n                <div #pivotColumnContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop (igxDragLeave)=\"onAreaDragLeave($event, colArea)\">\n                    <!-- Columns area -->\n                    <igx-chips-area #colArea droppable='true'>\n                    <span id='empty' (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop\n                        *ngIf=\"grid.columnDimensions.length === 0\" class='igx-grid__pivot-empty-chip-area'>\n                        {{grid.resourceStrings.igx_grid_pivot_empty_column_drop_area}}</span>\n                        <ng-container *ngFor=\"let col of grid.columnDimensions; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(colArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"col.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'column' }\"\n                                      [removable]=\"true\" (remove)=\"columnRemoved($event)\" (dragOver)=\"onDimDragOver($event, 1)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, colArea, 1)\"\n                                      (moveStart)='onDimDragStart($event, colArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, col)\">\n                                <igx-icon igxPrefix>view_column</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, col)'>filter_list</igx-icon>\n                                {{col.displayName || col.memberName}}\n                                <igx-icon *ngIf=\"col.sortDirection\" igxSuffix> {{ col.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(colArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, colArea, 1)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_column_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n\n                <div #pivotValueContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (pointerdown)=\"$event.preventDefault()\" (dropped)=\"onValueDrop($event, valueArea)\" igxDrop\n                     (igxDragLeave)=\"onAreaDragLeave($event, valueArea)\">\n                    <!-- Value area -->\n                    <igx-chips-area #valueArea droppable='true'>\n                    <span id='empty' (dropped)=\"onValueDrop($event, valueArea)\" igxDrop *ngIf=\"grid.values.length === 0\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_value_drop_area}}</span>\n                    <ng-container *ngFor=\"let value of grid.values; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(valueArea)'></span>\n                            <igx-chip #currChip [draggable]=\"true\" [id]=\"value.displayName || value.member\" [data]=\"{ pivotArea: 'value' }\"\n                                      [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"valueRemoved($event)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragOver)=\"onDimDragOver($event)\"\n                                      (dragDrop)=\"onValueDrop($event, valueArea)\">\n                                <div class=\"igx-grid__tr-pivot-toggle-icons\" igxPrefix\n                                     (click)='onSummaryClick($event, value, dropdown, currChip)'\n                                     (pointerdown)='$event.stopPropagation()' [igxDropDownItemNavigation]=\"dropdown\">\n                                    <igx-icon>functions</igx-icon>\n                                    <igx-icon>arrow_drop_down</igx-icon>\n                                </div>\n                                <ng-container *ngTemplateOutlet=\"grid.valueChipTemplate ? grid.valueChipTemplate : valueChipDefaultTemplate; context: { $implicit: value }\"></ng-container>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(valueArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onValueDrop($event, valueArea)\" #notifyValueChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_value_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n         [attr.aria-activedescendant]=\"activeDescendant\" [class.igx-grid__tr--mrl]=\"hasMRL\">\n\n        <!-- Column headers area -->\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div #pivotContainer class=\"igx-grid__tr-pivot igx-grid__tr-pivot--row-area\"\n                 [style.width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                 (dropped)=\"onDimDrop($event, rowArea, 0)\" (pointerdown)=\"$event.preventDefault()\">\n                <!-- Row area -->\n                <igx-chips-area #rowArea droppable='true'>\n                    <ng-container *ngIf=\"grid.showPivotConfigurationUI\">\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, rowArea, 0)\"\n                        *ngIf=\"grid.rowDimensions.length === 0 && grid.showPivotConfigurationUI\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_row_drop_area}}</span>\n                    <ng-container *ngFor=\"let row of grid.rowDimensions; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(rowArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"row.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'row' }\"\n                                      [removable]=\"true\" (remove)=\"rowRemoved($event)\" (dragLeave)=\"onDimDragLeave($event)\"\n                                      (dragDrop)=\"onDimDrop($event, rowArea, 0)\" (dragOver)=\"onDimDragOver($event, 0)\"\n                                      (moveStart)='onDimDragStart($event, rowArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, row)\">\n                                <igx-icon igxPrefix>table_rows</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, row)'>filter_list</igx-icon>\n                                {{ row.displayName || row.memberName}}\n                                <igx-icon *ngIf=\"row.sortDirection\" igxSuffix> {{ row.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(rowArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, rowArea, 0)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_row_drop_chip}}\n                        </igx-chip>\n                    </ng-container>\n                </igx-chips-area>\n            </div>\n\n            <!-- Pinned columns collection from the start -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles | igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n            <div class=\"igx-grid-thead--virtualizationWrapper\" [style.max-height.px]='maxContainerHeight'>\n                <div class=\"igx-grid-thead__group igx-grid-thead--virtualizationContainer\" [style.height.px]='totalDepth > 1 ? grid.rowHeight : undefined' *ngFor='let dimLevelColumns of columnDimensionsByLevel; let i = index' [style.width.px]='grid.unpinnedWidth'>\n                    <ng-template igxGridFor #headerVirtualContainer let-column\n                                 [igxGridForOf]=\"dimLevelColumns\" [igxGridForOfUniqueSizeCache] = 'true' [igxForScrollContainer]=\"grid.parentVirtDir\"\n                                 [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\"\n                                 [igxForSizePropName]=\"'calcPixelWidth'\" [igxForScrollOrientation]=\"'horizontal'\">\n                        <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                               [style.height.px]='totalDepth > 1 ? calcHeight(column, i) : undefined'\n                                               [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                               [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [class.igx-grid__tr-pivot--columnDimensionLeaf] = 'isDuplicateOfExistingParent(column, i)'\n                                               [class.igx-grid__tr-pivot--columnMultiRowSpan] = 'isMultiRow(column, i)'\n                        >\n                        </igx-grid-header-group>\n                    </ng-template>\n                </div>\n            </div>\n\n            <!-- Pinned columns collection at the end -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && !grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.left]=\"column.rightPinnedOffset\" (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n        </div>\n    </div>\n</div>\n<!-- Header thumb area -->\n<div class=\"igx-grid-thead__thumb\" [hidden]=\"!grid.hasVerticalScroll()\" [style.width.px]=\"grid.scrollSize\">\n</div>\n\n<igx-drop-down #dropdown (selectionChanging)='onAggregationChange($event)'>\n    <igx-drop-down-item *ngFor=\"let item of aggregateList\" [selected]='isSelected(item)' [value]='item'>\n        {{ item.label }}\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<div [hidden]='true'>\n    <igx-grid-excel-style-filtering [maxHeight]='grid.excelStyleFilterMaxHeight' [minHeight]='grid.excelStyleFilterMinHeight' #esf>\n        <div igxExcelStyleColumnOperations>\n            <igx-chips-area #dropdownChips>\n                <igx-chip *ngFor=\"let filter of this.filterDropdownDimensions\" [id]=\"filter.memberName\"\n                [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\"\n                (chipClick)='onFiltersSelectionChanged($event)' [selectable]='true' [selected]='filter === this.filterDropdownDimensions.values().next().value'>\n                {{filter.displayName || filter.memberName}}\n            </igx-chip>\n        </igx-chips-area>\n        </div>\n        <igx-excel-style-filter-operations>\n            <igx-excel-style-search></igx-excel-style-search>\n        </igx-excel-style-filter-operations>\n    </igx-grid-excel-style-filtering>\n</div>\n\n<div style=\"visibility: hidden; position: absolute; top: -10000px\">\n    <igx-chips-area #filterAreaHidden droppable='true'>\n        <igx-chip *ngFor=\"let filter of grid.filterDimensions\" [id]=\"filter.memberName\" [draggable]=\"true\"\n            [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\">\n            <igx-icon igxPrefix>filter_list</igx-icon>\n            {{filter.displayName || filter.memberName}}\n        </igx-chip>\n    </igx-chips-area>\n</div>\n\n<ng-template #valueChipDefaultTemplate let-value>\n    {{value.aggregate.key}}({{value.displayName || value.member}})\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: IgxDropDirective, selector: "[igxDrop]", inputs: ["igxDrop", "dropChannel", "dropStrategy"], outputs: ["enter", "over", "leave", "dropped"], exportAs: ["drop"] }, { kind: "component", type: IgxChipsAreaComponent, selector: "igx-chips-area", inputs: ["width", "height"], outputs: ["reorder", "selectionChange", "moveStart", "moveEnd"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: IgxChipComponent, selector: "igx-chip", inputs: ["variant", "id", "tabIndex", "data", "draggable", "animateOnRelease", "hideBaseOnDrag", "removable", "removeIcon", "selectable", "selectIcon", "class", "disabled", "selected", "color", "resourceStrings"], outputs: ["selectedChange", "moveStart", "moveEnd", "remove", "chipClick", "selectedChanging", "selectedChanged", "keyDown", "dragEnter", "dragLeave", "dragOver", "dragDrop"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: IgxPrefixDirective, selector: "igx-prefix,[igxPrefix],[igxStart]" }, { kind: "component", type: IgxBadgeComponent, selector: "igx-badge", inputs: ["id", "type", "value", "icon", "iconSet", "shape"] }, { kind: "directive", type: IgxSuffixDirective, selector: "igx-suffix,[igxSuffix],[igxEnd]" }, { kind: "directive", type: IgxDropDownItemNavigationDirective, selector: "[igxDropDownItemNavigation]", inputs: ["igxDropDownItemNavigation"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IgxGridHeaderGroupComponent, selector: "igx-grid-header-group", inputs: ["column"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { kind: "component", type: IgxDropDownComponent, selector: "igx-drop-down", inputs: ["allowItemsFocus", "labelledBy"], outputs: ["opening", "opened", "closing", "closed"] }, { kind: "component", type: IgxDropDownItemComponent, selector: "igx-drop-down-item" }, { kind: "component", type: IgxGridExcelStyleFilteringComponent, selector: "igx-grid-excel-style-filtering", inputs: ["column", "minHeight", "maxHeight"], outputs: ["loadingStart", "loadingEnd", "initialized", "sortingChanged", "columnChange", "listDataLoaded"] }, { kind: "directive", type: IgxExcelStyleColumnOperationsTemplateDirective, selector: "igx-excel-style-column-operations,[igxExcelStyleColumnOperations]" }, { kind: "directive", type: IgxExcelStyleFilterOperationsTemplateDirective, selector: "igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]" }, { kind: "component", type: IgxExcelStyleSearchComponent, selector: "igx-excel-style-search", inputs: ["id"] }, { kind: "pipe", type: IgxHeaderGroupWidthPipe, name: "igxHeaderGroupWidth" }, { kind: "pipe", type: IgxHeaderGroupStylePipe, name: "igxHeaderGroupStyle" }, { kind: "pipe", type: IgxGridTopLevelColumns, name: "igxTopLevel" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotHeaderRowComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-pivot-header-row', standalone: true, imports: [NgIf, IgxDropDirective, IgxChipsAreaComponent, NgFor, IgxChipComponent, IgxIconComponent, IgxPrefixDirective, IgxBadgeComponent, IgxSuffixDirective, IgxDropDownItemNavigationDirective, NgTemplateOutlet, IgxGridHeaderGroupComponent, NgClass, NgStyle, IgxGridForOfDirective, IgxDropDownComponent, IgxDropDownItemComponent, IgxGridExcelStyleFilteringComponent, IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleFilterOperationsTemplateDirective, IgxExcelStyleSearchComponent, IgxHeaderGroupWidthPipe, IgxHeaderGroupStylePipe, IgxGridTopLevelColumns], template: "<div>\n    <div class=\"igx-grid-thead__wrapper igx-grid-thead__wrapper--pivot\" role=\"row\" [style.width.px]=\"width\">\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div class='igx-grid__tr-pivot--filter-container'>\n                <div #pivotFilterContainer *ngIf=\"grid.showPivotConfigurationUI\"\n                     class=\"igx-grid__tr-pivot igx-grid__tr-pivot--filter\" [style.min-width.px]=\"grid.pivotRowWidths - 1\"\n                     [style.max-width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, filterArea)\"\n                     igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\" (pointerdown)=\"$event.preventDefault()\">\n                    <!-- Filter area -->\n                    <igx-chips-area #filterArea droppable='true'>\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\"\n                          *ngIf=\"grid.filterDimensions.length === 0\"\n                          class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_filter_drop_area}}</span>\n                        <ng-container *ngFor=\"let filter of this.filterAreaDimensions; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(filterArea)'></span>\n                            <igx-chip [id]=\"filter.memberName\" [draggable]=\"true\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'filter' }\"\n                                      [removable]=\"true\" (remove)=\"filterRemoved($event)\" (dragOver)=\"onDimDragOver($event, 2)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, filterArea, 2)\"\n                                      (moveStart)='onDimDragStart($event, filterArea)' (moveEnd)='onDimDragEnd()'>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, filter)'>filter_list</igx-icon>\n                                {{filter.displayName || filter.memberName}}\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(filterArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, filterArea, 2)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_filter_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                    <div class=\"igx-grid__pivot-filter-toggle\" *ngIf=\"isFiltersButton && grid.filterDimensions.length !== 0\">\n                        <igx-icon #filterIcon (pointerdown)='onFilteringIconPointerDown($event)' (click)='onFiltersAreaDropdownClick($event)'>filter_list</igx-icon>\n                        <igx-badge value=\"{{this.filterDropdownDimensions.size}}\"></igx-badge>\n                    </div>\n                </div>\n                <div class='igx-grid__tr-pivot--drop-row-area' (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                     (dropped)=\"onDimDrop($event, rowArea, 0)\">\n                </div>\n            </div>\n\n            <div class=\"igx-grid__tr-pivot-group\">\n                <div #pivotColumnContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop (igxDragLeave)=\"onAreaDragLeave($event, colArea)\">\n                    <!-- Columns area -->\n                    <igx-chips-area #colArea droppable='true'>\n                    <span id='empty' (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop\n                        *ngIf=\"grid.columnDimensions.length === 0\" class='igx-grid__pivot-empty-chip-area'>\n                        {{grid.resourceStrings.igx_grid_pivot_empty_column_drop_area}}</span>\n                        <ng-container *ngFor=\"let col of grid.columnDimensions; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(colArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"col.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'column' }\"\n                                      [removable]=\"true\" (remove)=\"columnRemoved($event)\" (dragOver)=\"onDimDragOver($event, 1)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, colArea, 1)\"\n                                      (moveStart)='onDimDragStart($event, colArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, col)\">\n                                <igx-icon igxPrefix>view_column</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, col)'>filter_list</igx-icon>\n                                {{col.displayName || col.memberName}}\n                                <igx-icon *ngIf=\"col.sortDirection\" igxSuffix> {{ col.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(colArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, colArea, 1)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_column_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n\n                <div #pivotValueContainer *ngIf=\"grid.showPivotConfigurationUI\" class=\"igx-grid__tr-pivot\"\n                     (pointerdown)=\"$event.preventDefault()\" (dropped)=\"onValueDrop($event, valueArea)\" igxDrop\n                     (igxDragLeave)=\"onAreaDragLeave($event, valueArea)\">\n                    <!-- Value area -->\n                    <igx-chips-area #valueArea droppable='true'>\n                    <span id='empty' (dropped)=\"onValueDrop($event, valueArea)\" igxDrop *ngIf=\"grid.values.length === 0\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_value_drop_area}}</span>\n                    <ng-container *ngFor=\"let value of grid.values; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(valueArea)'></span>\n                            <igx-chip #currChip [draggable]=\"true\" [id]=\"value.displayName || value.member\" [data]=\"{ pivotArea: 'value' }\"\n                                      [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"valueRemoved($event)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragOver)=\"onDimDragOver($event)\"\n                                      (dragDrop)=\"onValueDrop($event, valueArea)\">\n                                <div class=\"igx-grid__tr-pivot-toggle-icons\" igxPrefix\n                                     (click)='onSummaryClick($event, value, dropdown, currChip)'\n                                     (pointerdown)='$event.stopPropagation()' [igxDropDownItemNavigation]=\"dropdown\">\n                                    <igx-icon>functions</igx-icon>\n                                    <igx-icon>arrow_drop_down</igx-icon>\n                                </div>\n                                <ng-container *ngTemplateOutlet=\"grid.valueChipTemplate ? grid.valueChipTemplate : valueChipDefaultTemplate; context: { $implicit: value }\"></ng-container>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(valueArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onValueDrop($event, valueArea)\" #notifyValueChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_value_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n         [attr.aria-activedescendant]=\"activeDescendant\" [class.igx-grid__tr--mrl]=\"hasMRL\">\n\n        <!-- Column headers area -->\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div #pivotContainer class=\"igx-grid__tr-pivot igx-grid__tr-pivot--row-area\"\n                 [style.width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                 (dropped)=\"onDimDrop($event, rowArea, 0)\" (pointerdown)=\"$event.preventDefault()\">\n                <!-- Row area -->\n                <igx-chips-area #rowArea droppable='true'>\n                    <ng-container *ngIf=\"grid.showPivotConfigurationUI\">\n                    <span id='empty' igxDrop (dropped)=\"onDimDrop($event, rowArea, 0)\"\n                        *ngIf=\"grid.rowDimensions.length === 0 && grid.showPivotConfigurationUI\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_row_drop_area}}</span>\n                    <ng-container *ngFor=\"let row of grid.rowDimensions; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(rowArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"row.memberName\" [displayDensity]=\"grid.displayDensity\" [data]=\"{ pivotArea: 'row' }\"\n                                      [removable]=\"true\" (remove)=\"rowRemoved($event)\" (dragLeave)=\"onDimDragLeave($event)\"\n                                      (dragDrop)=\"onDimDrop($event, rowArea, 0)\" (dragOver)=\"onDimDragOver($event, 0)\"\n                                      (moveStart)='onDimDragStart($event, rowArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, row)\">\n                                <igx-icon igxPrefix>table_rows</igx-icon>\n                                <igx-icon igxPrefix (pointerdown)='onFilteringIconPointerDown($event)'\n                                          (click)='onFilteringIconClick($event, row)'>filter_list</igx-icon>\n                                {{ row.displayName || row.memberName}}\n                                <igx-icon *ngIf=\"row.sortDirection\" igxSuffix> {{ row.sortDirection < 2 ? 'arrow_upward'\n                                    : 'arrow_downward' }}</igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(rowArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, rowArea, 0)\" #notifyChip [hidden]='true'\n                                  [displayDensity]=\"grid.displayDensity\">\n                            {{grid.resourceStrings.igx_grid_pivot_row_drop_chip}}\n                        </igx-chip>\n                    </ng-container>\n                </igx-chips-area>\n            </div>\n\n            <!-- Pinned columns collection from the start -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles | igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n            <div class=\"igx-grid-thead--virtualizationWrapper\" [style.max-height.px]='maxContainerHeight'>\n                <div class=\"igx-grid-thead__group igx-grid-thead--virtualizationContainer\" [style.height.px]='totalDepth > 1 ? grid.rowHeight : undefined' *ngFor='let dimLevelColumns of columnDimensionsByLevel; let i = index' [style.width.px]='grid.unpinnedWidth'>\n                    <ng-template igxGridFor #headerVirtualContainer let-column\n                                 [igxGridForOf]=\"dimLevelColumns\" [igxGridForOfUniqueSizeCache] = 'true' [igxForScrollContainer]=\"grid.parentVirtDir\"\n                                 [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\"\n                                 [igxForSizePropName]=\"'calcPixelWidth'\" [igxForScrollOrientation]=\"'horizontal'\">\n                        <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                               [style.height.px]='totalDepth > 1 ? calcHeight(column, i) : undefined'\n                                               [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                               [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [class.igx-grid__tr-pivot--columnDimensionLeaf] = 'isDuplicateOfExistingParent(column, i)'\n                                               [class.igx-grid__tr-pivot--columnMultiRowSpan] = 'isMultiRow(column, i)'\n                        >\n                        </igx-grid-header-group>\n                    </ng-template>\n                </div>\n            </div>\n\n            <!-- Pinned columns collection at the end -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && !grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.left]=\"column.rightPinnedOffset\" (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n        </div>\n    </div>\n</div>\n<!-- Header thumb area -->\n<div class=\"igx-grid-thead__thumb\" [hidden]=\"!grid.hasVerticalScroll()\" [style.width.px]=\"grid.scrollSize\">\n</div>\n\n<igx-drop-down #dropdown (selectionChanging)='onAggregationChange($event)'>\n    <igx-drop-down-item *ngFor=\"let item of aggregateList\" [selected]='isSelected(item)' [value]='item'>\n        {{ item.label }}\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<div [hidden]='true'>\n    <igx-grid-excel-style-filtering [maxHeight]='grid.excelStyleFilterMaxHeight' [minHeight]='grid.excelStyleFilterMinHeight' #esf>\n        <div igxExcelStyleColumnOperations>\n            <igx-chips-area #dropdownChips>\n                <igx-chip *ngFor=\"let filter of this.filterDropdownDimensions\" [id]=\"filter.memberName\"\n                [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\"\n                (chipClick)='onFiltersSelectionChanged($event)' [selectable]='true' [selected]='filter === this.filterDropdownDimensions.values().next().value'>\n                {{filter.displayName || filter.memberName}}\n            </igx-chip>\n        </igx-chips-area>\n        </div>\n        <igx-excel-style-filter-operations>\n            <igx-excel-style-search></igx-excel-style-search>\n        </igx-excel-style-filter-operations>\n    </igx-grid-excel-style-filtering>\n</div>\n\n<div style=\"visibility: hidden; position: absolute; top: -10000px\">\n    <igx-chips-area #filterAreaHidden droppable='true'>\n        <igx-chip *ngFor=\"let filter of grid.filterDimensions\" [id]=\"filter.memberName\" [draggable]=\"true\"\n            [displayDensity]=\"grid.displayDensity\" [removable]=\"true\" (remove)=\"filterRemoved($event)\">\n            <igx-icon igxPrefix>filter_list</igx-icon>\n            {{filter.displayName || filter.memberName}}\n        </igx-chip>\n    </igx-chips-area>\n</div>\n\n<ng-template #valueChipDefaultTemplate let-value>\n    {{value.aggregate.key}}({{value.displayName || value.member}})\n</ng-template>\n" }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }], propDecorators: { esf: [{
                type: ViewChild,
                args: ['esf']
            }], filterArea: [{
                type: ViewChild,
                args: ['filterAreaHidden', { static: false }]
            }], filtersButton: [{
                type: ViewChild,
                args: ['filterIcon']
            }], dropdownChips: [{
                type: ViewChild,
                args: ['dropdownChips']
            }], pivotFilterContainer: [{
                type: ViewChild,
                args: ['pivotFilterContainer']
            }], notificationChips: [{
                type: ViewChildren,
                args: ['notifyChip']
            }], headerContainers: [{
                type: ViewChildren,
                args: ['headerVirtualContainer', { read: IgxGridForOfDirective }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3QtaGVhZGVyLXJvdy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvcGl2b3QtZ3JpZC9waXZvdC1oZWFkZXItcm93LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LWhlYWRlci1yb3cuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBRVQsTUFBTSxFQUlOLFNBQVMsRUFFVCxZQUFZLEVBQ2YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFzQixnQkFBZ0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ2xGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBRWpGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzNFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxvQkFBb0IsRUFBcUMsaUJBQWlCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMvSSxPQUFPLEVBQWMsYUFBYSxFQUFpQixNQUFNLDBCQUEwQixDQUFDO0FBQ3BGLE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQ3JGLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ2pGLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUV4RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxD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cG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgSW5qZWN0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBRdWVyeUxpc3QsXG4gICAgUmVuZGVyZXIyLFxuICAgIFZpZXdDaGlsZCxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFZpZXdDaGlsZHJlblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElCYXNlQ2hpcEV2ZW50QXJncywgSWd4Q2hpcENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXAuY29tcG9uZW50JztcbmltcG9ydCB7IElneENoaXBzQXJlYUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXBzLWFyZWEuY29tcG9uZW50JztcbmltcG9ydCB7IFNvcnRpbmdEaXJlY3Rpb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2Zvci1vZi9mb3Jfb2YuZGlyZWN0aXZlJztcbmltcG9ydCB7IElTZWxlY3Rpb25FdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9kcm9wLWRvd24vZHJvcC1kb3duLmNvbW1vbic7XG5pbXBvcnQgeyBJZ3hEcm9wRG93bkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2Ryb3AtZG93bi9kcm9wLWRvd24uY29tcG9uZW50JztcbmltcG9ydCB7IEFic29sdXRlU2Nyb2xsU3RyYXRlZ3ksIEF1dG9Qb3NpdGlvblN0cmF0ZWd5LCBPdmVybGF5U2V0dGluZ3MsIFBvc2l0aW9uU2V0dGluZ3MsIFZlcnRpY2FsQWxpZ25tZW50IH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcHVibGljX2FwaSc7XG5pbXBvcnQgeyBDb2x1bW5UeXBlLCBJR1hfR1JJRF9CQVNFLCBQaXZvdEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudCB9IGZyb20gJy4uL2hlYWRlcnMvZ3JpZC1oZWFkZXItZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJSb3dDb21wb25lbnQgfSBmcm9tICcuLi9oZWFkZXJzL2dyaWQtaGVhZGVyLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgRHJvcFBvc2l0aW9uIH0gZnJvbSAnLi4vbW92aW5nL21vdmluZy5zZXJ2aWNlJztcbmltcG9ydCB7IElQaXZvdEFnZ3JlZ2F0b3IsIElQaXZvdERpbWVuc2lvbiwgSVBpdm90VmFsdWUsIFBpdm90RGltZW5zaW9uVHlwZSB9IGZyb20gJy4vcGl2b3QtZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUGl2b3RVdGlsIH0gZnJvbSAnLi9waXZvdC11dGlsJztcbmltcG9ydCB7IElneEdyaWRUb3BMZXZlbENvbHVtbnMgfSBmcm9tICcuLi9jb21tb24vcGlwZXMnO1xuaW1wb3J0IHsgSWd4SGVhZGVyR3JvdXBXaWR0aFBpcGUsIElneEhlYWRlckdyb3VwU3R5bGVQaXBlIH0gZnJvbSAnLi4vaGVhZGVycy9waXBlcyc7XG5pbXBvcnQgeyBJZ3hFeGNlbFN0eWxlU2VhcmNoQ29tcG9uZW50IH0gZnJvbSAnLi4vZmlsdGVyaW5nL2V4Y2VsLXN0eWxlL2V4Y2VsLXN0eWxlLXNlYXJjaC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZEV4Y2VsU3R5bGVGaWx0ZXJpbmdDb21wb25lbnQsIElneEV4Y2VsU3R5bGVDb2x1bW5PcGVyYXRpb25zVGVtcGxhdGVEaXJlY3RpdmUsIElneEV4Y2VsU3R5bGVGaWx0ZXJPcGVyYXRpb25zVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuLi9maWx0ZXJpbmcvZXhjZWwtc3R5bGUvZXhjZWwtc3R5bGUtZmlsdGVyaW5nLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hEcm9wRG93bkl0ZW1Db21wb25lbnQgfSBmcm9tICcuLi8uLi9kcm9wLWRvd24vZHJvcC1kb3duLWl0ZW0uY29tcG9uZW50JztcbmltcG9ydCB7IElneERyb3BEb3duSXRlbU5hdmlnYXRpb25EaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kcm9wLWRvd24vZHJvcC1kb3duLW5hdmlnYXRpb24uZGlyZWN0aXZlJztcbmltcG9ydCB7IElneFN1ZmZpeERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvc3VmZml4L3N1ZmZpeC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4QmFkZ2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi9iYWRnZS9iYWRnZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4UHJlZml4RGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9wcmVmaXgvcHJlZml4LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hJY29uQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hEcm9wRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9kcmFnLWRyb3AvZHJhZy1kcm9wLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOZ0lmLCBOZ0ZvciwgTmdUZW1wbGF0ZU91dGxldCwgTmdDbGFzcywgTmdTdHlsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbi8qKlxuICpcbiAqIEZvciBhbGwgaW50ZW50cyAmIHB1cnBvc2VzIHRyZWF0IHRoaXMgY29tcG9uZW50IGFzIHdoYXQgYSA8dGhlYWQ+IHVzdWFsbHkgaXMgaW4gdGhlIGRlZmF1bHQgPHRhYmxlPiBlbGVtZW50LlxuICpcbiAqIFRoaXMgY29udGFpbmVyIGhvbGRzIHRoZSBwaXZvdCBncmlkIGhlYWRlciBlbGVtZW50cyBhbmQgdGhlaXIgYmVoYXZpb3IvaW50ZXJhY3Rpb25zLlxuICpcbiAqIEBoaWRkZW4gQGludGVybmFsXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHNlbGVjdG9yOiAnaWd4LXBpdm90LWhlYWRlci1yb3cnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9waXZvdC1oZWFkZXItcm93LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtOZ0lmLCBJZ3hEcm9wRGlyZWN0aXZlLCBJZ3hDaGlwc0FyZWFDb21wb25lbnQsIE5nRm9yLCBJZ3hDaGlwQ29tcG9uZW50LCBJZ3hJY29uQ29tcG9uZW50LCBJZ3hQcmVmaXhEaXJlY3RpdmUsIElneEJhZGdlQ29tcG9uZW50LCBJZ3hTdWZmaXhEaXJlY3RpdmUsIElneERyb3BEb3duSXRlbU5hdmlnYXRpb25EaXJlY3RpdmUsIE5nVGVtcGxhdGVPdXRsZXQsIElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudCwgTmdDbGFzcywgTmdTdHlsZSwgSWd4R3JpZEZvck9mRGlyZWN0aXZlLCBJZ3hEcm9wRG93bkNvbXBvbmVudCwgSWd4RHJvcERvd25JdGVtQ29tcG9uZW50LCBJZ3hHcmlkRXhjZWxTdHlsZUZpbHRlcmluZ0NvbXBvbmVudCwgSWd4RXhjZWxTdHlsZUNvbHVtbk9wZXJhdGlvbnNUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4RXhjZWxTdHlsZUZpbHRlck9wZXJhdGlvbnNUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4RXhjZWxTdHlsZVNlYXJjaENvbXBvbmVudCwgSWd4SGVhZGVyR3JvdXBXaWR0aFBpcGUsIElneEhlYWRlckdyb3VwU3R5bGVQaXBlLCBJZ3hHcmlkVG9wTGV2ZWxDb2x1bW5zXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdEhlYWRlclJvd0NvbXBvbmVudCBleHRlbmRzIElneEdyaWRIZWFkZXJSb3dDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICAgIHB1YmxpYyBhZ2dyZWdhdGVMaXN0OiBJUGl2b3RBZ2dyZWdhdG9yW10gPSBbXTtcblxuICAgIHB1YmxpYyB2YWx1ZTogSVBpdm90VmFsdWU7XG4gICAgcHVibGljIGZpbHRlckRyb3Bkb3duRGltZW5zaW9uczogU2V0PGFueT4gPSBuZXcgU2V0PGFueT4oKTtcbiAgICBwdWJsaWMgZmlsdGVyQXJlYURpbWVuc2lvbnM6IFNldDxhbnk+ID0gbmV3IFNldDxhbnk+KCk7XG4gICAgcHJpdmF0ZSBfZHJvcFBvcyA9IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQ7XG4gICAgcHJpdmF0ZSB2YWx1ZURhdGE6IE1hcDxzdHJpbmcsIElQaXZvdEFnZ3JlZ2F0b3JbXT47XG4gICAgcHJpdmF0ZSBfc3ViTWVudVBvc2l0aW9uU2V0dGluZ3M6IFBvc2l0aW9uU2V0dGluZ3MgPSB7XG4gICAgICAgIHZlcnRpY2FsU3RhcnRQb2ludDogVmVydGljYWxBbGlnbm1lbnQuQm90dG9tLFxuICAgICAgICBjbG9zZUFuaW1hdGlvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBwcml2YXRlIF9zdWJNZW51T3ZlcmxheVNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3MgPSB7XG4gICAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgICAgIG1vZGFsOiBmYWxzZSxcbiAgICAgICAgcG9zaXRpb25TdHJhdGVneTogbmV3IEF1dG9Qb3NpdGlvblN0cmF0ZWd5KHRoaXMuX3N1Yk1lbnVQb3NpdGlvblNldHRpbmdzKSxcbiAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IG5ldyBBYnNvbHV0ZVNjcm9sbFN0cmF0ZWd5KClcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdlc2YnKSBwdWJsaWMgZXNmOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2ZpbHRlckFyZWFIaWRkZW4nLCB7IHN0YXRpYzogZmFsc2UgfSkgcHVibGljIGZpbHRlckFyZWE7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2ZpbHRlckljb24nKSBwdWJsaWMgZmlsdGVyc0J1dHRvbjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZHJvcGRvd25DaGlwcycpIHB1YmxpYyBkcm9wZG93bkNoaXBzO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdwaXZvdEZpbHRlckNvbnRhaW5lcicpIHB1YmxpYyBwaXZvdEZpbHRlckNvbnRhaW5lcjtcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKCdub3RpZnlDaGlwJylcbiAgICBwdWJsaWMgbm90aWZpY2F0aW9uQ2hpcHM6IFF1ZXJ5TGlzdDxJZ3hDaGlwQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKiBUaGUgdmlydHVhbGl6ZWQgcGFydCBvZiB0aGUgaGVhZGVyIHJvdyBjb250YWluaW5nIHRoZSB1bnBpbm5lZCBoZWFkZXIgZ3JvdXBzLlxuICAgICovXG4gICAgQFZpZXdDaGlsZHJlbignaGVhZGVyVmlydHVhbENvbnRhaW5lcicsIHsgcmVhZDogSWd4R3JpZEZvck9mRGlyZWN0aXZlIH0pXG4gICAgcHVibGljIGhlYWRlckNvbnRhaW5lcnM6IFF1ZXJ5TGlzdDxJZ3hHcmlkRm9yT2ZEaXJlY3RpdmU8Q29sdW1uVHlwZSwgQ29sdW1uVHlwZVtdPj47XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IGhlYWRlckZvck9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJDb250YWluZXJzLmxhc3Q7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoSUdYX0dSSURfQkFTRSkgcHVibGljIG92ZXJyaWRlIGdyaWQ6IFBpdm90R3JpZFR5cGUsXG4gICAgICAgIHJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICkge1xuICAgICAgICBzdXBlcihyZWYsIGNkcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqIERlZmF1bHQgaXMgYSBzaW5nbGUgZW1wdHkgbGV2ZWwgc2luY2UgZGVmYXVsdCBkZXB0aCBpcyAxXG4gICAgKi9cbiAgICBwdWJsaWMgY29sdW1uRGltZW5zaW9uc0J5TGV2ZWw6IGFueVtdID0gW1tdXTtcblxuICAgIC8qKlxuICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgaXNGaWx0ZXJzQnV0dG9uKCk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgY2hpcHNXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuZmlsdGVyRHJvcGRvd25EaW1lbnNpb25zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVyQXJlYURpbWVuc2lvbnMuY2xlYXIoKTtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyQXJlYT8uY2hpcHNMaXN0ICYmIHRoaXMuZmlsdGVyQXJlYS5jaGlwc0xpc3QubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMucGl2b3RGaWx0ZXJDb250YWluZXIubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJQYWRkaW5ncyA9IHBhcnNlRmxvYXQoc3R5bGVzLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoc3R5bGVzLnBhZGRpbmdSaWdodCk7XG4gICAgICAgICAgICBjaGlwc1dpZHRoICs9IGNvbnRhaW5lclBhZGRpbmdzICsgKHRoaXMuZmlsdGVyc0J1dHRvbiAmJiB0aGlzLmZpbHRlckFyZWE/LmNoaXBzTGlzdC5sZW5ndGggPiAxID8gdGhpcy5maWx0ZXJzQnV0dG9uLmVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggOiAwKTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyQXJlYS5jaGlwc0xpc3QuZm9yRWFjaChjaGlwID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaW0gPSB0aGlzLmdyaWQuZmlsdGVyRGltZW5zaW9ucy5maW5kKHggPT4geC5tZW1iZXJOYW1lID09PSBjaGlwLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZGltKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDggcHggbWFyZ2luIGJldHdlZW4gY2hpcHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENoaXBXaWR0aCA9IGNoaXAubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIDg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlwc1dpZHRoICsgY3VycmVudENoaXBXaWR0aCA8IHRoaXMuZ3JpZC5waXZvdFJvd1dpZHRocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJBcmVhRGltZW5zaW9ucy5hZGQoZGltKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyRHJvcGRvd25EaW1lbnNpb25zLmFkZChkaW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaXBzV2lkdGggKz0gY3VycmVudENoaXBXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckRyb3Bkb3duRGltZW5zaW9ucy5zaXplID4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgdG90YWxEZXB0aCgpIHtcbiAgICAgICAgY29uc3QgY29sdW1uRGltZW5zaW9ucyA9IHRoaXMuZ3JpZC5jb2x1bW5EaW1lbnNpb25zO1xuICAgICAgICBpZiAoY29sdW1uRGltZW5zaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbERlcHRoID0gY29sdW1uRGltZW5zaW9ucy5tYXAoeCA9PiBQaXZvdFV0aWwuZ2V0RGltZW5zaW9uRGVwdGgoeCkgKyAxKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpO1xuICAgICAgICBpZiAodGhpcy5ncmlkLmhhc011bHRpcGxlVmFsdWVzKSB7XG4gICAgICAgICAgICB0b3RhbERlcHRoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsRGVwdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWF4Q29udGFpbmVySGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbERlcHRoICogdGhpcy5ncmlkLnJlbmRlcmVkUm93SGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgY2FsY0hlaWdodChjb2w6IENvbHVtblR5cGUsIGluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuICFjb2wuY29sdW1uR3JvdXAgJiYgY29sLmxldmVsIDwgdGhpcy50b3RhbERlcHRoICYmIGNvbC5sZXZlbCA9PT0gaW5kZXggPyAodGhpcy50b3RhbERlcHRoIC0gY29sLmxldmVsKSAqIHRoaXMuZ3JpZC5yb3dIZWlnaHQgOiB0aGlzLmdyaWQucm93SGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgaXNEdXBsaWNhdGVPZkV4aXN0aW5nUGFyZW50KGNvbDogQ29sdW1uVHlwZSwgbHZsOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Q29sbGVjdGlvbiA9IGx2bCA+IDAgPyB0aGlzLmNvbHVtbkRpbWVuc2lvbnNCeUxldmVsW2x2bCAtIDFdIDogW107XG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IHBhcmVudENvbGxlY3Rpb24uaW5kZXhPZihjb2wpICE9PSAtMTtcblxuICAgICAgICByZXR1cm4gZHVwbGljYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgaXNNdWx0aVJvdyhjb2w6IENvbHVtblR5cGUsIGx2bDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGlzTGVhZiA9ICFjb2wuY29sdW1uR3JvdXA7XG4gICAgICAgIHJldHVybiBpc0xlYWYgJiYgbHZsICE9PSB0aGlzLnRvdGFsRGVwdGggLSAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgcG9wdWxhdGVDb2x1bW5EaW1lbnNpb25zQnlMZXZlbCgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50b3RhbERlcHRoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLnVucGlubmVkQ29sdW1uQ29sbGVjdGlvbjtcbiAgICAgICAgLy8gcG9wdWxhdGUgY29sdW1uIGRpbWVuc2lvbiBtYXRyaXggcmVjdXJzaXZlbHlcbiAgICAgICAgdGhpcy5wb3B1bGF0ZURpbWVuc2lvblJlY3Vyc2l2ZWx5KGNvbHMuZmlsdGVyKHggPT4geC5sZXZlbCA9PT0gMCksIDAsIHJlcyk7XG4gICAgICAgIHRoaXMuY29sdW1uRGltZW5zaW9uc0J5TGV2ZWwgPSByZXM7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBvcHVsYXRlRGltZW5zaW9uUmVjdXJzaXZlbHkoY3VycmVudExldmVsQ29sdW1uczogQ29sdW1uVHlwZVtdLCBsZXZlbCA9IDAsIHJlczogYW55W10pIHtcbiAgICAgICAgY3VycmVudExldmVsQ29sdW1ucy5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICAgICAgICBpZiAocmVzW2xldmVsXSkge1xuICAgICAgICAgICAgICAgIHJlc1tsZXZlbF0ucHVzaChjb2wpO1xuICAgICAgICAgICAgICAgIGlmIChjb2wuY29sdW1uR3JvdXAgJiYgY29sLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlzaWJsZUNvbHVtbnMgPSBjb2wuY2hpbGRyZW4udG9BcnJheSgpLmZpbHRlcih4ID0+ICF4LmhpZGRlbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdWxhdGVEaW1lbnNpb25SZWN1cnNpdmVseSh2aXNpYmxlQ29sdW1ucywgbGV2ZWwgKyAxLCByZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGV2ZWwgPCB0aGlzLnRvdGFsRGVwdGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZXZlbCArIDE7IGkgPD0gdGhpcy50b3RhbERlcHRoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbaV0ucHVzaChjb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMudW5waW5uZWRDb2x1bW5Db2xsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVsYXRlQ29sdW1uRGltZW5zaW9uc0J5TGV2ZWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25EaW1EcmFnU3RhcnQoZXZlbnQsIGFyZWEpIHtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaXAgb2YgdGhpcy5ub3RpZmljYXRpb25DaGlwcykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gY2hpcC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoYXJlYS5jaGlwc0xpc3QudG9BcnJheSgpLmluZGV4T2YoY2hpcCkgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uaXRlbSgwKS5pZCAhPT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgICAgIGNoaXAubmF0aXZlRWxlbWVudC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50RWxlbWVudC5zY3JvbGxUbyh7IGxlZnQ6IGNoaXAubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkRpbURyYWdFbmQoKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpcCBvZiB0aGlzLm5vdGlmaWNhdGlvbkNoaXBzKSB7XG4gICAgICAgICAgICBjaGlwLm5hdGl2ZUVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0QXJlYUhlaWdodChhcmVhOiBJZ3hDaGlwc0FyZWFDb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgY2hpcHMgPSBhcmVhLmNoaXBzTGlzdDtcbiAgICAgICAgcmV0dXJuIGNoaXBzICYmIGNoaXBzLmxlbmd0aCA+IDAgPyBjaGlwcy5maXJzdC5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyByb3dSZW1vdmVkKGV2ZW50OiBJQmFzZUNoaXBFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi5yb3dzLmZpbmQoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKTtcbiAgICAgICAgdGhpcy5ncmlkLnRvZ2dsZURpbWVuc2lvbihyb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgY29sdW1uUmVtb3ZlZChldmVudDogSUJhc2VDaGlwRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ3JpZC5waXZvdENvbmZpZ3VyYXRpb24uY29sdW1ucy5maW5kKHggPT4geC5tZW1iZXJOYW1lID09PSBldmVudC5vd25lci5pZCk7XG4gICAgICAgIHRoaXMuZ3JpZC50b2dnbGVEaW1lbnNpb24oY29sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIHZhbHVlUmVtb3ZlZChldmVudDogSUJhc2VDaGlwRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi52YWx1ZXMuZmluZCh4ID0+IHgubWVtYmVyID09PSBldmVudC5vd25lci5pZCB8fCB4LmRpc3BsYXlOYW1lID09PSBldmVudC5vd25lci5pZCk7XG4gICAgICAgIHRoaXMuZ3JpZC50b2dnbGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBmaWx0ZXJSZW1vdmVkKGV2ZW50OiBJQmFzZUNoaXBFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi5maWx0ZXJzLmZpbmQoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKTtcbiAgICAgICAgdGhpcy5ncmlkLnRvZ2dsZURpbWVuc2lvbihmaWx0ZXIpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMub25GaWx0ZXJzQXJlYURyb3Bkb3duQ2xpY2soeyB0YXJnZXQ6IHRoaXMuZmlsdGVyc0J1dHRvbi5lbC5uYXRpdmVFbGVtZW50IH0sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UuaGlkZUVTRigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG9uRmlsdGVyc1NlbGVjdGlvbkNoYW5nZWQoZXZlbnQ/OiBJQmFzZUNoaXBFdmVudEFyZ3MpIHtcbiAgICAgICAgdGhpcy5kcm9wZG93bkNoaXBzLmNoaXBzTGlzdC5mb3JFYWNoKGNoaXAgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaXAuaWQgIT09IGV2ZW50Lm93bmVyLmlkKSB7XG4gICAgICAgICAgICAgICAgY2hpcC5zZWxlY3RlZCA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uRmlsdGVyc0FyZWFEcm9wZG93bkNsaWNrKHsgdGFyZ2V0OiB0aGlzLmZpbHRlcnNCdXR0b24uZWwubmF0aXZlRWxlbWVudCB9LCB0aGlzLmdyaWQuZmlsdGVyRGltZW5zaW9ucy5maW5kKGRpbSA9PiBkaW0ubWVtYmVyTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkZpbHRlcmluZ0ljb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uRmlsdGVyaW5nSWNvbkNsaWNrKGV2ZW50LCBkaW1lbnNpb24pIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGRpbSA9IGRpbWVuc2lvbjtcbiAgICAgICAgY29uc3QgY29sID0gdGhpcy5ncmlkLmRpbWVuc2lvbkRhdGFDb2x1bW5zLmZpbmQoeCA9PiB4LmZpZWxkID09PSBkaW0ubWVtYmVyTmFtZSB8fCB4LmZpZWxkID09PSBkaW0ubWVtYmVyKTtcbiAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UudG9nZ2xlRmlsdGVyRHJvcGRvd24oZXZlbnQudGFyZ2V0LCBjb2wpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25TdW1tYXJ5Q2xpY2soZXZlbnRBcmdzLCB2YWx1ZTogSVBpdm90VmFsdWUsIGRyb3Bkb3duOiBJZ3hEcm9wRG93bkNvbXBvbmVudCwgY2hpcDogSWd4Q2hpcENvbXBvbmVudCkge1xuICAgICAgICB0aGlzLl9zdWJNZW51T3ZlcmxheVNldHRpbmdzLnRhcmdldCA9IGV2ZW50QXJncy5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLnVwZGF0ZURyb3BEb3duKHZhbHVlLCBkcm9wZG93biwgY2hpcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25GaWx0ZXJzQXJlYURyb3Bkb3duQ2xpY2soZXZlbnQsIGRpbWVuc2lvbj8sIHNob3VsZFJlYXR0YWNoID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBkaW0gPSBkaW1lbnNpb24gfHwgdGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdyaWQuZGltZW5zaW9uRGF0YUNvbHVtbnMuZmluZCh4ID0+IHguZmllbGQgPT09IGRpbS5tZW1iZXJOYW1lIHx8IHguZmllbGQgPT09IGRpbS5tZW1iZXIpO1xuICAgICAgICBpZiAoc2hvdWxkUmVhdHRhY2gpIHtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd25DaGlwcy5jaGlwc0xpc3QuZm9yRWFjaChjaGlwID0+IHtcbiAgICAgICAgICAgICAgICBjaGlwLnNlbGVjdGVkID0gZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bkNoaXBzLmNoaXBzTGlzdC5maXJzdC5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UudG9nZ2xlRmlsdGVyc0VTRih0aGlzLmVzZiwgZXZlbnQudGFyZ2V0LCBjb2wsIHNob3VsZFJlYXR0YWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uQWdncmVnYXRpb25DaGFuZ2UoZXZlbnQ6IElTZWxlY3Rpb25FdmVudEFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQoZXZlbnQubmV3U2VsZWN0aW9uLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5hZ2dyZWdhdGUgPSBldmVudC5uZXdTZWxlY3Rpb24udmFsdWU7XG4gICAgICAgICAgICB0aGlzLmdyaWQucGlwZVRyaWdnZXIrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgaXNTZWxlY3RlZCh2YWw6IElQaXZvdEFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuYWdncmVnYXRlLmtleSA9PT0gdmFsLmtleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uQ2hpcFNvcnQoX2V2ZW50LCBkaW1lbnNpb246IElQaXZvdERpbWVuc2lvbikge1xuICAgICAgICBjb25zdCBzdGFydERpcmVjdGlvbiA9IGRpbWVuc2lvbi5zb3J0RGlyZWN0aW9uIHx8IFNvcnRpbmdEaXJlY3Rpb24uTm9uZTtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gc3RhcnREaXJlY3Rpb24gKyAxID4gU29ydGluZ0RpcmVjdGlvbi5EZXNjID9cbiAgICAgICAgICAgIFNvcnRpbmdEaXJlY3Rpb24uTm9uZSA6IHN0YXJ0RGlyZWN0aW9uICsgMTtcbiAgICAgICAgdGhpcy5ncmlkLnNvcnREaW1lbnNpb24oZGltZW5zaW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25EaW1EcmFnT3ZlcihldmVudCwgZGltZW5zaW9uPzogUGl2b3REaW1lbnNpb25UeXBlKSB7XG4gICAgICAgIGlmICghZXZlbnQuZHJhZ0NoaXAgfHwgIWV2ZW50LmRyYWdDaGlwLmRhdGE/LnBpdm90QXJlYSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB0eXBlTWlzbWF0Y2ggPSBkaW1lbnNpb24gIT09IHVuZGVmaW5lZCA/IHRoaXMuZ3JpZC5waXZvdENvbmZpZ3VyYXRpb24udmFsdWVzLmZpbmQoeCA9PiB4Lm1lbWJlciA9PT0gZXZlbnQuZHJhZ0NoaXAuaWRcbiAgICAgICAgICAgIHx8IHguZGlzcGxheU5hbWUgPT09IGV2ZW50LmRyYWdDaGlwLmlkKSA6XG4gICAgICAgICAgICAhdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi52YWx1ZXMuZmluZCh4ID0+IHgubWVtYmVyID09PSBldmVudC5kcmFnQ2hpcC5pZCB8fCB4LmRpc3BsYXlOYW1lID09PSBldmVudC5kcmFnQ2hpcC5pZCk7XG4gICAgICAgIGlmICh0eXBlTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIGNhbm5vdCBkcmFnIGJldHdlZW4gZGltZW5zaW9ucyBhbmQgdmFsdWVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBhcmUgaW4gdGhlIGxlZnQgaGFsZiBvZiB0aGUgY2hpcCwgZHJvcCBvbiB0aGUgbGVmdFxuICAgICAgICAvLyBlbHNlIGRyb3Agb24gdGhlIHJpZ2h0IG9mIHRoZSBjaGlwXG4gICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBldmVudC5vd25lci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBwb3MgPSBjbGllbnRSZWN0LndpZHRoIC8gMjtcblxuICAgICAgICB0aGlzLl9kcm9wUG9zID0gZXZlbnQub3JpZ2luYWxFdmVudC5vZmZzZXRYID4gcG9zID8gRHJvcFBvc2l0aW9uLkFmdGVyRHJvcFRhcmdldCA6IERyb3BQb3NpdGlvbi5CZWZvcmVEcm9wVGFyZ2V0O1xuICAgICAgICBpZiAodGhpcy5fZHJvcFBvcyA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyRHJvcFRhcmdldCkge1xuICAgICAgICAgICAgZXZlbnQub3duZXIubmF0aXZlRWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uRGltRHJhZ0xlYXZlKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fZHJvcFBvcyA9IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkFyZWFEcmFnTGVhdmUoZXZlbnQsIGFyZWEpIHtcbiAgICAgICAgY29uc3QgZGF0YUNoaXBzID0gYXJlYS5jaGlwc0xpc3QudG9BcnJheSgpLmZpbHRlcih4ID0+IHRoaXMubm90aWZpY2F0aW9uQ2hpcHMudG9BcnJheSgpLmluZGV4T2YoeCkgPT09IC0xKTtcbiAgICAgICAgZGF0YUNoaXBzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5uYXRpdmVFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5uYXRpdmVFbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubmF0aXZlRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uVmFsdWVEcm9wKGV2ZW50LCBhcmVhKSB7XG4gICAgICAgIGlmICghKGV2ZW50LmRyYWdDaGlwICYmIGV2ZW50LmRyYWdDaGlwLmRhdGE/LnBpdm90QXJlYSkgJiYgIShldmVudC5kcmFnRGF0YT8uY2hpcCAmJiAhIWV2ZW50LmRyYWdEYXRhLmNoaXAuZGF0YS5waXZvdEFyZWEpKSByZXR1cm47XG4gICAgICAgIC8vdmFsdWVzIGNhbiBvbmx5IGJlIHJlb3JkZXJlZFxuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmdyaWQucGl2b3RDb25maWd1cmF0aW9uLnZhbHVlcztcbiAgICAgICAgY29uc3QgZHJhZ0lkID0gZXZlbnQuZHJhZ0NoaXA/LmlkIHx8IGV2ZW50LmRyYWdEYXRhPy5jaGlwLmlkO1xuICAgICAgICBjb25zdCBjaGlwc0FycmF5ID0gYXJlYS5jaGlwc0xpc3QudG9BcnJheSgpO1xuICAgICAgICBsZXQgY2hpcEluZGV4ID0gY2hpcHNBcnJheS5pbmRleE9mKGV2ZW50Lm93bmVyKSAhPT0gLTEgPyBjaGlwc0FycmF5LmluZGV4T2YoZXZlbnQub3duZXIpIDogY2hpcHNBcnJheS5sZW5ndGg7XG4gICAgICAgIGNoaXBJbmRleCA9IHRoaXMuX2Ryb3BQb3MgPT09IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQgPyBjaGlwSW5kZXggKyAxIDogY2hpcEluZGV4O1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlcy5maW5kKHggPT4geC5tZW1iZXIgPT09IGRyYWdJZCB8fCB4LmRpc3BsYXlOYW1lID09PSBkcmFnSWQpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdDaGlwSW5kZXggPSBjaGlwc0FycmF5LmluZGV4T2YoZXZlbnQuZHJhZ0NoaXAgfHwgZXZlbnQuZHJhZ0RhdGEuY2hpcCk7XG4gICAgICAgICAgICB0aGlzLmdyaWQubW92ZVZhbHVlKHZhbHVlLCBkcmFnQ2hpcEluZGV4ID49IGNoaXBJbmRleCA/IGNoaXBJbmRleCA6IGNoaXBJbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkRpbURyb3AoZXZlbnQsIGFyZWEsIGRpbWVuc2lvblR5cGU6IFBpdm90RGltZW5zaW9uVHlwZSkge1xuICAgICAgICBpZiAoIShldmVudC5kcmFnQ2hpcCAmJiBldmVudC5kcmFnQ2hpcC5kYXRhPy5waXZvdEFyZWEpICYmICEoZXZlbnQuZHJhZ0RhdGE/LmNoaXAgJiYgISFldmVudC5kcmFnRGF0YS5jaGlwLmRhdGEucGl2b3RBcmVhKSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBkcmFnSWQgPSBldmVudC5kcmFnQ2hpcD8uaWQgfHwgZXZlbnQuZHJhZ0RhdGE/LmNoaXAuaWQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREaW0gPSB0aGlzLmdyaWQuZ2V0RGltZW5zaW9uc0J5VHlwZShkaW1lbnNpb25UeXBlKTtcbiAgICAgICAgY29uc3QgY2hpcHNBcnJheSA9IGFyZWEuY2hpcHNMaXN0LnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgY2hpcCA9IGNoaXBzQXJyYXkuZmluZCh4ID0+IHguaWQgPT09IGRyYWdJZCk7XG4gICAgICAgIGNvbnN0IGlzTmV3Q2hpcCA9IGNoaXAgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaXNSZW9yZGVyID0gZXZlbnQub3duZXIuaWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgLy9jb25zdCBjaGlwSW5kZXggPSBjaGlwc0FycmF5LmluZGV4T2YoZXZlbnQub3duZXIpICE9PSAtMSA/IGNoaXBzQXJyYXkuaW5kZXhPZihldmVudC5vd25lcikgOiBjaGlwc0FycmF5Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgY2hpcEluZGV4ID0gY3VycmVudERpbS5maW5kSW5kZXgoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKSAhPT0gLTEgP1xuICAgICAgICAgICAgY3VycmVudERpbS5maW5kSW5kZXgoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKSA6IGN1cnJlbnREaW0ubGVuZ3RoO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuX2Ryb3BQb3MgPT09IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQgPyBjaGlwSW5kZXggKyAxIDogY2hpcEluZGV4O1xuICAgICAgICBpZiAoaXNOZXdDaGlwKSB7XG4gICAgICAgICAgICAvLyBjaGlwIG1vdmVkIGZyb20gYW4gZXh0ZXJuYWwgY29sbGVjdGlvblxuICAgICAgICAgICAgY29uc3QgZGltID0gdGhpcy5ncmlkLmFsbERpbWVuc2lvbnMuZmluZCh4ID0+IHggJiYgeC5tZW1iZXJOYW1lID09PSBkcmFnSWQpO1xuICAgICAgICAgICAgaWYgKCFkaW0pIHtcbiAgICAgICAgICAgICAgICAvLyB5b3UgaGF2ZSBkcmFnZ2VkIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGRpbWVuc2lvblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5tb3ZlRGltZW5zaW9uKGRpbSwgZGltZW5zaW9uVHlwZSwgdGFyZ2V0SW5kZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVvcmRlcikge1xuICAgICAgICAgICAgLy8gY2hpcCBmcm9tIHNhbWUgY29sbGVjdGlvbiwgcmVvcmRlcmVkLlxuICAgICAgICAgICAgY29uc3QgbmV3RGltID0gY3VycmVudERpbS5maW5kKHggPT4geC5tZW1iZXJOYW1lID09PSBkcmFnSWQpO1xuICAgICAgICAgICAgY29uc3QgZHJhZ0NoaXBJbmRleCA9IGN1cnJlbnREaW0uZmluZEluZGV4KHggPT4geC5tZW1iZXJOYW1lID09PSBkcmFnSWQpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLm1vdmVEaW1lbnNpb24obmV3RGltLCBkaW1lbnNpb25UeXBlLCBkcmFnQ2hpcEluZGV4ID4gY2hpcEluZGV4ID8gdGFyZ2V0SW5kZXggOiB0YXJnZXRJbmRleCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5waXBlVHJpZ2dlcisrO1xuICAgICAgICB0aGlzLmdyaWQuZGltZW5zaW9uc0NoYW5nZS5lbWl0KHsgZGltZW5zaW9uczogY3VycmVudERpbSwgZGltZW5zaW9uQ29sbGVjdGlvblR5cGU6IGRpbWVuc2lvblR5cGUgfSk7XG4gICAgICAgIC8vIGNsZWFuIHN0YXRlc1xuICAgICAgICB0aGlzLm9uRGltRHJhZ0VuZCgpO1xuICAgICAgICB0aGlzLm9uQXJlYURyYWdMZWF2ZShldmVudCwgYXJlYSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHVwZGF0ZURyb3BEb3duKHZhbHVlOiBJUGl2b3RWYWx1ZSwgZHJvcGRvd246IElneERyb3BEb3duQ29tcG9uZW50LCBjaGlwOiBJZ3hDaGlwQ29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZHJvcGRvd24ud2lkdGggPSBjaGlwLm5hdGl2ZUVsZW1lbnQuY2xpZW50V2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZUxpc3QgPSBQaXZvdFV0aWwuZ2V0QWdncmVnYXRlTGlzdCh2YWx1ZSwgdGhpcy5ncmlkKTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICBkcm9wZG93bi5vcGVuKHRoaXMuX3N1Yk1lbnVPdmVybGF5U2V0dGluZ3MpO1xuICAgIH1cbn1cbiIsIjxkaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkLXRoZWFkX193cmFwcGVyIGlneC1ncmlkLXRoZWFkX193cmFwcGVyLS1waXZvdFwiIHJvbGU9XCJyb3dcIiBbc3R5bGUud2lkdGgucHhdPVwid2lkdGhcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190clwiIHJvbGU9XCJyb3dcIiBbc3R5bGUud2lkdGgucHhdPVwid2lkdGhcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J2lneC1ncmlkX190ci1waXZvdC0tZmlsdGVyLWNvbnRhaW5lcic+XG4gICAgICAgICAgICAgICAgPGRpdiAjcGl2b3RGaWx0ZXJDb250YWluZXIgKm5nSWY9XCJncmlkLnNob3dQaXZvdENvbmZpZ3VyYXRpb25VSVwiXG4gICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdCBpZ3gtZ3JpZF9fdHItcGl2b3QtLWZpbHRlclwiIFtzdHlsZS5taW4td2lkdGgucHhdPVwiZ3JpZC5waXZvdFJvd1dpZHRocyAtIDFcIlxuICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1heC13aWR0aC5weF09XCJncmlkLnBpdm90Um93V2lkdGhzIC0gMVwiIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgZmlsdGVyQXJlYSlcIlxuICAgICAgICAgICAgICAgICAgICAgaWd4RHJvcCAoZHJvcHBlZCk9XCJvbkRpbURyb3AoJGV2ZW50LCBmaWx0ZXJBcmVhLCAyKVwiIChwb2ludGVyZG93bik9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuICAgICAgICAgICAgICAgICAgICA8IS0tIEZpbHRlciBhcmVhIC0tPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXBzLWFyZWEgI2ZpbHRlckFyZWEgZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9J2VtcHR5JyBpZ3hEcm9wIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIGZpbHRlckFyZWEsIDIpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJncmlkLmZpbHRlckRpbWVuc2lvbnMubGVuZ3RoID09PSAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9J2lneC1ncmlkX19waXZvdC1lbXB0eS1jaGlwLWFyZWEnPnt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3RfZW1wdHlfZmlsdGVyX2Ryb3BfYXJlYX19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgZmlsdGVyIG9mIHRoaXMuZmlsdGVyQXJlYURpbWVuc2lvbnM7IGxldCBsYXN0ID0gbGFzdDtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KGZpbHRlckFyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIFtpZF09XCJmaWx0ZXIubWVtYmVyTmFtZVwiIFtkcmFnZ2FibGVdPVwidHJ1ZVwiIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCIgW2RhdGFdPVwieyBwaXZvdEFyZWE6ICdmaWx0ZXInIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVtb3ZhYmxlXT1cInRydWVcIiAocmVtb3ZlKT1cImZpbHRlclJlbW92ZWQoJGV2ZW50KVwiIChkcmFnT3Zlcik9XCJvbkRpbURyYWdPdmVyKCRldmVudCwgMilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHJhZ0xlYXZlKT1cIm9uRGltRHJhZ0xlYXZlKCRldmVudClcIiAoZHJhZ0Ryb3ApPVwib25EaW1Ecm9wKCRldmVudCwgZmlsdGVyQXJlYSwgMilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobW92ZVN0YXJ0KT0nb25EaW1EcmFnU3RhcnQoJGV2ZW50LCBmaWx0ZXJBcmVhKScgKG1vdmVFbmQpPSdvbkRpbURyYWdFbmQoKSc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXggKHBvaW50ZXJkb3duKT0nb25GaWx0ZXJpbmdJY29uUG9pbnRlckRvd24oJGV2ZW50KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9J29uRmlsdGVyaW5nSWNvbkNsaWNrKCRldmVudCwgZmlsdGVyKSc+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2ZpbHRlci5kaXNwbGF5TmFtZSB8fCBmaWx0ZXIubWVtYmVyTmFtZX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPSdsYXN0Jz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQoZmlsdGVyQXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIGlneERyb3AgKGRyYWdEcm9wKT1cIm9uRGltRHJvcCgkZXZlbnQsIGZpbHRlckFyZWEsIDIpXCIgI25vdGlmeUNoaXAgW2hpZGRlbl09J3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc3BsYXlEZW5zaXR5XT1cImdyaWQuZGlzcGxheURlbnNpdHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2dyaWQucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Bpdm90X2ZpbHRlcl9kcm9wX2NoaXB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcHMtYXJlYT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19waXZvdC1maWx0ZXItdG9nZ2xlXCIgKm5nSWY9XCJpc0ZpbHRlcnNCdXR0b24gJiYgZ3JpZC5maWx0ZXJEaW1lbnNpb25zLmxlbmd0aCAhPT0gMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uICNmaWx0ZXJJY29uIChwb2ludGVyZG93bik9J29uRmlsdGVyaW5nSWNvblBvaW50ZXJEb3duKCRldmVudCknIChjbGljayk9J29uRmlsdGVyc0FyZWFEcm9wZG93bkNsaWNrKCRldmVudCknPmZpbHRlcl9saXN0PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtYmFkZ2UgdmFsdWU9XCJ7e3RoaXMuZmlsdGVyRHJvcGRvd25EaW1lbnNpb25zLnNpemV9fVwiPjwvaWd4LWJhZGdlPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdpZ3gtZ3JpZF9fdHItcGl2b3QtLWRyb3Atcm93LWFyZWEnIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgcm93QXJlYSlcIiBpZ3hEcm9wXG4gICAgICAgICAgICAgICAgICAgICAoZHJvcHBlZCk9XCJvbkRpbURyb3AoJGV2ZW50LCByb3dBcmVhLCAwKVwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICA8ZGl2ICNwaXZvdENvbHVtbkNvbnRhaW5lciAqbmdJZj1cImdyaWQuc2hvd1Bpdm90Q29uZmlndXJhdGlvblVJXCIgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3RcIlxuICAgICAgICAgICAgICAgICAgICAgKGRyb3BwZWQpPVwib25EaW1Ecm9wKCRldmVudCwgY29sQXJlYSwgMSlcIiBpZ3hEcm9wIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgY29sQXJlYSlcIj5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSBDb2x1bW5zIGFyZWEgLS0+XG4gICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcHMtYXJlYSAjY29sQXJlYSBkcm9wcGFibGU9J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0nZW1wdHknIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIGNvbEFyZWEsIDEpXCIgaWd4RHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJncmlkLmNvbHVtbkRpbWVuc2lvbnMubGVuZ3RoID09PSAwXCIgY2xhc3M9J2lneC1ncmlkX19waXZvdC1lbXB0eS1jaGlwLWFyZWEnPlxuICAgICAgICAgICAgICAgICAgICAgICAge3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9lbXB0eV9jb2x1bW5fZHJvcF9hcmVhfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBjb2wgb2YgZ3JpZC5jb2x1bW5EaW1lbnNpb25zOyBsZXQgbGFzdCA9IGxhc3Q7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodChjb2xBcmVhKSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBbZHJhZ2dhYmxlXT1cInRydWVcIiBbaWRdPVwiY29sLm1lbWJlck5hbWVcIiBbZGlzcGxheURlbnNpdHldPVwiZ3JpZC5kaXNwbGF5RGVuc2l0eVwiIFtkYXRhXT1cInsgcGl2b3RBcmVhOiAnY29sdW1uJyB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3JlbW92YWJsZV09XCJ0cnVlXCIgKHJlbW92ZSk9XCJjb2x1bW5SZW1vdmVkKCRldmVudClcIiAoZHJhZ092ZXIpPVwib25EaW1EcmFnT3ZlcigkZXZlbnQsIDEpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRyYWdMZWF2ZSk9XCJvbkRpbURyYWdMZWF2ZSgkZXZlbnQpXCIgKGRyYWdEcm9wKT1cIm9uRGltRHJvcCgkZXZlbnQsIGNvbEFyZWEsIDEpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1vdmVTdGFydCk9J29uRGltRHJhZ1N0YXJ0KCRldmVudCwgY29sQXJlYSknIChtb3ZlRW5kKT0nb25EaW1EcmFnRW5kKCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJvbkNoaXBTb3J0KCRldmVudCwgY29sKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb24gaWd4UHJlZml4PnZpZXdfY29sdW1uPC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uIGlneFByZWZpeCAocG9pbnRlcmRvd24pPSdvbkZpbHRlcmluZ0ljb25Qb2ludGVyRG93bigkZXZlbnQpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT0nb25GaWx0ZXJpbmdJY29uQ2xpY2soJGV2ZW50LCBjb2wpJz5maWx0ZXJfbGlzdDwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7Y29sLmRpc3BsYXlOYW1lIHx8IGNvbC5tZW1iZXJOYW1lfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uICpuZ0lmPVwiY29sLnNvcnREaXJlY3Rpb25cIiBpZ3hTdWZmaXg+IHt7IGNvbC5zb3J0RGlyZWN0aW9uIDwgMiA/ICdhcnJvd191cHdhcmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdhcnJvd19kb3dud2FyZCcgfX08L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj0nbGFzdCc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KGNvbEFyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBpZ3hEcm9wIChkcmFnRHJvcCk9XCJvbkRpbURyb3AoJGV2ZW50LCBjb2xBcmVhLCAxKVwiICNub3RpZnlDaGlwIFtoaWRkZW5dPSd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9jb2x1bW5fZHJvcF9jaGlwfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXBzLWFyZWE+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2ICNwaXZvdFZhbHVlQ29udGFpbmVyICpuZ0lmPVwiZ3JpZC5zaG93UGl2b3RDb25maWd1cmF0aW9uVUlcIiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdFwiXG4gICAgICAgICAgICAgICAgICAgICAocG9pbnRlcmRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIiAoZHJvcHBlZCk9XCJvblZhbHVlRHJvcCgkZXZlbnQsIHZhbHVlQXJlYSlcIiBpZ3hEcm9wXG4gICAgICAgICAgICAgICAgICAgICAoaWd4RHJhZ0xlYXZlKT1cIm9uQXJlYURyYWdMZWF2ZSgkZXZlbnQsIHZhbHVlQXJlYSlcIj5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSBWYWx1ZSBhcmVhIC0tPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXBzLWFyZWEgI3ZhbHVlQXJlYSBkcm9wcGFibGU9J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0nZW1wdHknIChkcm9wcGVkKT1cIm9uVmFsdWVEcm9wKCRldmVudCwgdmFsdWVBcmVhKVwiIGlneERyb3AgKm5nSWY9XCJncmlkLnZhbHVlcy5sZW5ndGggPT09IDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9J2lneC1ncmlkX19waXZvdC1lbXB0eS1jaGlwLWFyZWEnPnt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3RfZW1wdHlfdmFsdWVfZHJvcF9hcmVhfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHZhbHVlIG9mIGdyaWQudmFsdWVzOyBsZXQgbGFzdCA9IGxhc3Q7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodCh2YWx1ZUFyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwICNjdXJyQ2hpcCBbZHJhZ2dhYmxlXT1cInRydWVcIiBbaWRdPVwidmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubWVtYmVyXCIgW2RhdGFdPVwieyBwaXZvdEFyZWE6ICd2YWx1ZScgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCIgW3JlbW92YWJsZV09XCJ0cnVlXCIgKHJlbW92ZSk9XCJ2YWx1ZVJlbW92ZWQoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkcmFnTGVhdmUpPVwib25EaW1EcmFnTGVhdmUoJGV2ZW50KVwiIChkcmFnT3Zlcik9XCJvbkRpbURyYWdPdmVyKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHJhZ0Ryb3ApPVwib25WYWx1ZURyb3AoJGV2ZW50LCB2YWx1ZUFyZWEpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtdG9nZ2xlLWljb25zXCIgaWd4UHJlZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT0nb25TdW1tYXJ5Q2xpY2soJGV2ZW50LCB2YWx1ZSwgZHJvcGRvd24sIGN1cnJDaGlwKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocG9pbnRlcmRvd24pPSckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCknIFtpZ3hEcm9wRG93bkl0ZW1OYXZpZ2F0aW9uXT1cImRyb3Bkb3duXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb24+ZnVuY3Rpb25zPC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbj5hcnJvd19kcm9wX2Rvd248L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImdyaWQudmFsdWVDaGlwVGVtcGxhdGUgPyBncmlkLnZhbHVlQ2hpcFRlbXBsYXRlIDogdmFsdWVDaGlwRGVmYXVsdFRlbXBsYXRlOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogdmFsdWUgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj0nbGFzdCc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KHZhbHVlQXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIGlneERyb3AgKGRyYWdEcm9wKT1cIm9uVmFsdWVEcm9wKCRldmVudCwgdmFsdWVBcmVhKVwiICNub3RpZnlWYWx1ZUNoaXAgW2hpZGRlbl09J3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc3BsYXlEZW5zaXR5XT1cImdyaWQuZGlzcGxheURlbnNpdHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2dyaWQucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Bpdm90X3ZhbHVlX2Ryb3BfY2hpcH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwcy1hcmVhPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgcm9sZT1cInJvd2dyb3VwXCIgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZF9fd3JhcHBlclwiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiXG4gICAgICAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiYWN0aXZlRGVzY2VuZGFudFwiIFtjbGFzcy5pZ3gtZ3JpZF9fdHItLW1ybF09XCJoYXNNUkxcIj5cblxuICAgICAgICA8IS0tIENvbHVtbiBoZWFkZXJzIGFyZWEgLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHJcIiByb2xlPVwicm93XCIgW3N0eWxlLndpZHRoLnB4XT1cIndpZHRoXCI+XG4gICAgICAgICAgICA8ZGl2ICNwaXZvdENvbnRhaW5lciBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdCBpZ3gtZ3JpZF9fdHItcGl2b3QtLXJvdy1hcmVhXCJcbiAgICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoLnB4XT1cImdyaWQucGl2b3RSb3dXaWR0aHMgLSAxXCIgKGlneERyYWdMZWF2ZSk9XCJvbkFyZWFEcmFnTGVhdmUoJGV2ZW50LCByb3dBcmVhKVwiIGlneERyb3BcbiAgICAgICAgICAgICAgICAgKGRyb3BwZWQpPVwib25EaW1Ecm9wKCRldmVudCwgcm93QXJlYSwgMClcIiAocG9pbnRlcmRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIj5cbiAgICAgICAgICAgICAgICA8IS0tIFJvdyBhcmVhIC0tPlxuICAgICAgICAgICAgICAgIDxpZ3gtY2hpcHMtYXJlYSAjcm93QXJlYSBkcm9wcGFibGU9J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiZ3JpZC5zaG93UGl2b3RDb25maWd1cmF0aW9uVUlcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9J2VtcHR5JyBpZ3hEcm9wIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIHJvd0FyZWEsIDApXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZ3JpZC5yb3dEaW1lbnNpb25zLmxlbmd0aCA9PT0gMCAmJiBncmlkLnNob3dQaXZvdENvbmZpZ3VyYXRpb25VSVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz0naWd4LWdyaWRfX3Bpdm90LWVtcHR5LWNoaXAtYXJlYSc+e3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9lbXB0eV9yb3dfZHJvcF9hcmVhfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHJvdyBvZiBncmlkLnJvd0RpbWVuc2lvbnM7IGxldCBsYXN0ID0gbGFzdDtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdnZXRBcmVhSGVpZ2h0KHJvd0FyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIFtkcmFnZ2FibGVdPVwidHJ1ZVwiIFtpZF09XCJyb3cubWVtYmVyTmFtZVwiIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCIgW2RhdGFdPVwieyBwaXZvdEFyZWE6ICdyb3cnIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVtb3ZhYmxlXT1cInRydWVcIiAocmVtb3ZlKT1cInJvd1JlbW92ZWQoJGV2ZW50KVwiIChkcmFnTGVhdmUpPVwib25EaW1EcmFnTGVhdmUoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkcmFnRHJvcCk9XCJvbkRpbURyb3AoJGV2ZW50LCByb3dBcmVhLCAwKVwiIChkcmFnT3Zlcik9XCJvbkRpbURyYWdPdmVyKCRldmVudCwgMClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobW92ZVN0YXJ0KT0nb25EaW1EcmFnU3RhcnQoJGV2ZW50LCByb3dBcmVhKScgKG1vdmVFbmQpPSdvbkRpbURyYWdFbmQoKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uQ2hpcFNvcnQoJGV2ZW50LCByb3cpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXg+dGFibGVfcm93czwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXggKHBvaW50ZXJkb3duKT0nb25GaWx0ZXJpbmdJY29uUG9pbnRlckRvd24oJGV2ZW50KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9J29uRmlsdGVyaW5nSWNvbkNsaWNrKCRldmVudCwgcm93KSc+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyByb3cuZGlzcGxheU5hbWUgfHwgcm93Lm1lbWJlck5hbWV9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb24gKm5nSWY9XCJyb3cuc29ydERpcmVjdGlvblwiIGlneFN1ZmZpeD4ge3sgcm93LnNvcnREaXJlY3Rpb24gPCAyID8gJ2Fycm93X3Vwd2FyZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2Fycm93X2Rvd253YXJkJyB9fTwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPSdsYXN0Jz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQocm93QXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIGlneERyb3AgKGRyYWdEcm9wKT1cIm9uRGltRHJvcCgkZXZlbnQsIHJvd0FyZWEsIDApXCIgI25vdGlmeUNoaXAgW2hpZGRlbl09J3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc3BsYXlEZW5zaXR5XT1cImdyaWQuZGlzcGxheURlbnNpdHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2dyaWQucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Bpdm90X3Jvd19kcm9wX2NoaXB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC9pZ3gtY2hpcHMtYXJlYT5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8IS0tIFBpbm5lZCBjb2x1bW5zIGNvbGxlY3Rpb24gZnJvbSB0aGUgc3RhcnQgLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwicGlubmVkQ29sdW1uQ29sbGVjdGlvbi5sZW5ndGggJiYgZ3JpZC5pc1Bpbm5pbmdUb1N0YXJ0XCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIHBpbm5lZENvbHVtbkNvbGxlY3Rpb24gfCBpZ3hUb3BMZXZlbFwiPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWdyaWQtaGVhZGVyLWdyb3VwIFtuZ0NsYXNzXT1cImNvbHVtbi5oZWFkZXJHcm91cENsYXNzZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNvbHVtbi5oZWFkZXJHcm91cFN0eWxlcyB8IGlneEhlYWRlckdyb3VwU3R5bGU6Y29sdW1uOmdyaWQucGlwZVRyaWdnZXJcIiBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1pbi13aWR0aF09XCJjb2x1bW4ucmVzb2x2ZWRXaWR0aCB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5mbGV4LWJhc2lzXT1cImNvbHVtbi5yZXNvbHZlZFdpZHRoIHwgaWd4SGVhZGVyR3JvdXBXaWR0aDpncmlkLmRlZmF1bHRIZWFkZXJHcm91cE1pbldpZHRoOmhhc01STFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvaW50ZXJkb3duKT1cImdyaWQubmF2aWdhdGlvbi5mb2N1c091dFJvd0hlYWRlcigkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICAgIDwvaWd4LWdyaWQtaGVhZGVyLWdyb3VwPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWQtdGhlYWQtLXZpcnR1YWxpemF0aW9uV3JhcHBlclwiIFtzdHlsZS5tYXgtaGVpZ2h0LnB4XT0nbWF4Q29udGFpbmVySGVpZ2h0Jz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWQtdGhlYWRfX2dyb3VwIGlneC1ncmlkLXRoZWFkLS12aXJ0dWFsaXphdGlvbkNvbnRhaW5lclwiIFtzdHlsZS5oZWlnaHQucHhdPSd0b3RhbERlcHRoID4gMSA/IGdyaWQucm93SGVpZ2h0IDogdW5kZWZpbmVkJyAqbmdGb3I9J2xldCBkaW1MZXZlbENvbHVtbnMgb2YgY29sdW1uRGltZW5zaW9uc0J5TGV2ZWw7IGxldCBpID0gaW5kZXgnIFtzdHlsZS53aWR0aC5weF09J2dyaWQudW5waW5uZWRXaWR0aCc+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yICNoZWFkZXJWaXJ0dWFsQ29udGFpbmVyIGxldC1jb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpZ3hHcmlkRm9yT2ZdPVwiZGltTGV2ZWxDb2x1bW5zXCIgW2lneEdyaWRGb3JPZlVuaXF1ZVNpemVDYWNoZV0gPSAndHJ1ZScgW2lneEZvclNjcm9sbENvbnRhaW5lcl09XCJncmlkLnBhcmVudFZpcnREaXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2lneEZvckNvbnRhaW5lclNpemVdPVwiZ3JpZC51bnBpbm5lZFdpZHRoXCIgW2lneEZvclRyYWNrQnldPVwiZ3JpZC50cmFja0NvbHVtbkNoYW5nZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2lneEZvclNpemVQcm9wTmFtZV09XCInY2FsY1BpeGVsV2lkdGgnXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1ncmlkLWhlYWRlci1ncm91cCBbbmdDbGFzc109XCJjb2x1bW4uaGVhZGVyR3JvdXBDbGFzc2VzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J3RvdGFsRGVwdGggPiAxID8gY2FsY0hlaWdodChjb2x1bW4sIGkpIDogdW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJjb2x1bW4uaGVhZGVyR3JvdXBTdHlsZXMgfGlneEhlYWRlckdyb3VwU3R5bGU6Y29sdW1uOmdyaWQucGlwZVRyaWdnZXJcIiBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5taW4td2lkdGhdPVwiY29sdW1uLnJlc29sdmVkV2lkdGggfCBpZ3hIZWFkZXJHcm91cFdpZHRoOmdyaWQuZGVmYXVsdEhlYWRlckdyb3VwTWluV2lkdGg6aGFzTVJMXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmZsZXgtYmFzaXNdPVwiY29sdW1uLnJlc29sdmVkV2lkdGggfCBpZ3hIZWFkZXJHcm91cFdpZHRoOmdyaWQuZGVmYXVsdEhlYWRlckdyb3VwTWluV2lkdGg6aGFzTVJMXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmlneC1ncmlkX190ci1waXZvdC0tY29sdW1uRGltZW5zaW9uTGVhZl0gPSAnaXNEdXBsaWNhdGVPZkV4aXN0aW5nUGFyZW50KGNvbHVtbiwgaSknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy5pZ3gtZ3JpZF9fdHItcGl2b3QtLWNvbHVtbk11bHRpUm93U3Bhbl0gPSAnaXNNdWx0aVJvdyhjb2x1bW4sIGkpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtZ3JpZC1oZWFkZXItZ3JvdXA+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPCEtLSBQaW5uZWQgY29sdW1ucyBjb2xsZWN0aW9uIGF0IHRoZSBlbmQgLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwicGlubmVkQ29sdW1uQ29sbGVjdGlvbi5sZW5ndGggJiYgIWdyaWQuaXNQaW5uaW5nVG9TdGFydFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBwaW5uZWRDb2x1bW5Db2xsZWN0aW9uIHwgaWd4VG9wTGV2ZWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1ncmlkLWhlYWRlci1ncm91cCBbbmdDbGFzc109XCJjb2x1bW4uaGVhZGVyR3JvdXBDbGFzc2VzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJjb2x1bW4uaGVhZGVyR3JvdXBTdHlsZXMgfGlneEhlYWRlckdyb3VwU3R5bGU6Y29sdW1uOmdyaWQucGlwZVRyaWdnZXJcIiBbY29sdW1uXT1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1pbi13aWR0aF09XCJjb2x1bW4ucmVzb2x2ZWRXaWR0aCB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5mbGV4LWJhc2lzXT1cImNvbHVtbi5yZXNvbHZlZFdpZHRoIHwgaWd4SGVhZGVyR3JvdXBXaWR0aDpncmlkLmRlZmF1bHRIZWFkZXJHcm91cE1pbldpZHRoOmhhc01STFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmxlZnRdPVwiY29sdW1uLnJpZ2h0UGlubmVkT2Zmc2V0XCIgKHBvaW50ZXJkb3duKT1cImdyaWQubmF2aWdhdGlvbi5mb2N1c091dFJvd0hlYWRlcigkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICAgIDwvaWd4LWdyaWQtaGVhZGVyLWdyb3VwPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG48IS0tIEhlYWRlciB0aHVtYiBhcmVhIC0tPlxuPGRpdiBjbGFzcz1cImlneC1ncmlkLXRoZWFkX190aHVtYlwiIFtoaWRkZW5dPVwiIWdyaWQuaGFzVmVydGljYWxTY3JvbGwoKVwiIFtzdHlsZS53aWR0aC5weF09XCJncmlkLnNjcm9sbFNpemVcIj5cbjwvZGl2PlxuXG48aWd4LWRyb3AtZG93biAjZHJvcGRvd24gKHNlbGVjdGlvbkNoYW5naW5nKT0nb25BZ2dyZWdhdGlvbkNoYW5nZSgkZXZlbnQpJz5cbiAgICA8aWd4LWRyb3AtZG93bi1pdGVtICpuZ0Zvcj1cImxldCBpdGVtIG9mIGFnZ3JlZ2F0ZUxpc3RcIiBbc2VsZWN0ZWRdPSdpc1NlbGVjdGVkKGl0ZW0pJyBbdmFsdWVdPSdpdGVtJz5cbiAgICAgICAge3sgaXRlbS5sYWJlbCB9fVxuICAgIDwvaWd4LWRyb3AtZG93bi1pdGVtPlxuPC9pZ3gtZHJvcC1kb3duPlxuXG48ZGl2IFtoaWRkZW5dPSd0cnVlJz5cbiAgICA8aWd4LWdyaWQtZXhjZWwtc3R5bGUtZmlsdGVyaW5nIFttYXhIZWlnaHRdPSdncmlkLmV4Y2VsU3R5bGVGaWx0ZXJNYXhIZWlnaHQnIFttaW5IZWlnaHRdPSdncmlkLmV4Y2VsU3R5bGVGaWx0ZXJNaW5IZWlnaHQnICNlc2Y+XG4gICAgICAgIDxkaXYgaWd4RXhjZWxTdHlsZUNvbHVtbk9wZXJhdGlvbnM+XG4gICAgICAgICAgICA8aWd4LWNoaXBzLWFyZWEgI2Ryb3Bkb3duQ2hpcHM+XG4gICAgICAgICAgICAgICAgPGlneC1jaGlwICpuZ0Zvcj1cImxldCBmaWx0ZXIgb2YgdGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnNcIiBbaWRdPVwiZmlsdGVyLm1lbWJlck5hbWVcIlxuICAgICAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCIgW3JlbW92YWJsZV09XCJ0cnVlXCIgKHJlbW92ZSk9XCJmaWx0ZXJSZW1vdmVkKCRldmVudClcIlxuICAgICAgICAgICAgICAgIChjaGlwQ2xpY2spPSdvbkZpbHRlcnNTZWxlY3Rpb25DaGFuZ2VkKCRldmVudCknIFtzZWxlY3RhYmxlXT0ndHJ1ZScgW3NlbGVjdGVkXT0nZmlsdGVyID09PSB0aGlzLmZpbHRlckRyb3Bkb3duRGltZW5zaW9ucy52YWx1ZXMoKS5uZXh0KCkudmFsdWUnPlxuICAgICAgICAgICAgICAgIHt7ZmlsdGVyLmRpc3BsYXlOYW1lIHx8IGZpbHRlci5tZW1iZXJOYW1lfX1cbiAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgIDwvaWd4LWNoaXBzLWFyZWE+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aWd4LWV4Y2VsLXN0eWxlLWZpbHRlci1vcGVyYXRpb25zPlxuICAgICAgICAgICAgPGlneC1leGNlbC1zdHlsZS1zZWFyY2g+PC9pZ3gtZXhjZWwtc3R5bGUtc2VhcmNoPlxuICAgICAgICA8L2lneC1leGNlbC1zdHlsZS1maWx0ZXItb3BlcmF0aW9ucz5cbiAgICA8L2lneC1ncmlkLWV4Y2VsLXN0eWxlLWZpbHRlcmluZz5cbjwvZGl2PlxuXG48ZGl2IHN0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMDAwcHhcIj5cbiAgICA8aWd4LWNoaXBzLWFyZWEgI2ZpbHRlckFyZWFIaWRkZW4gZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgPGlneC1jaGlwICpuZ0Zvcj1cImxldCBmaWx0ZXIgb2YgZ3JpZC5maWx0ZXJEaW1lbnNpb25zXCIgW2lkXT1cImZpbHRlci5tZW1iZXJOYW1lXCIgW2RyYWdnYWJsZV09XCJ0cnVlXCJcbiAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJncmlkLmRpc3BsYXlEZW5zaXR5XCIgW3JlbW92YWJsZV09XCJ0cnVlXCIgKHJlbW92ZSk9XCJmaWx0ZXJSZW1vdmVkKCRldmVudClcIj5cbiAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXg+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICAgICAge3tmaWx0ZXIuZGlzcGxheU5hbWUgfHwgZmlsdGVyLm1lbWJlck5hbWV9fVxuICAgICAgICA8L2lneC1jaGlwPlxuICAgIDwvaWd4LWNoaXBzLWFyZWE+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICN2YWx1ZUNoaXBEZWZhdWx0VGVtcGxhdGUgbGV0LXZhbHVlPlxuICAgIHt7dmFsdWUuYWdncmVnYXRlLmtleX19KHt7dmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubWVtYmVyfX0pXG48L25nLXRlbXBsYXRlPlxuIl19