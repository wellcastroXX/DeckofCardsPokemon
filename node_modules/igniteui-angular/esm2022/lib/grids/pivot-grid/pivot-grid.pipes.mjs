import { Inject, Pipe } from '@angular/core';
import { cloneArray, resolveNestedPath } from '../../core/utils';
import { DataUtil } from '../../data-operations/data-util';
import { FilteringExpressionsTree } from '../../data-operations/filtering-expressions-tree';
import { DefaultPivotGridRecordSortingStrategy } from '../../data-operations/pivot-sort-strategy';
import { FilterUtil } from '../../data-operations/filtering-strategy';
import { DimensionValuesFilteringStrategy, PivotColumnDimensionsStrategy, PivotRowDimensionsStrategy } from '../../data-operations/pivot-strategy';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { DEFAULT_PIVOT_KEYS } from './pivot-grid.interface';
import { PivotSortUtil } from './pivot-sort-util';
import { PivotUtil } from './pivot-util';
import * as i0 from "@angular/core";
import * as i1 from "../api.service";
/**
 * @hidden
 */
export class IgxPivotRowPipe {
    constructor() { }
    transform(collection, config, cloneStrategy, _, _pipeTrigger, __) {
        const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;
        const enabledRows = config.rows?.filter(x => x.enabled) || [];
        const enabledColumns = config.columns?.filter(x => x.enabled) || [];
        const enabledValues = config.values?.filter(x => x.enabled) || [];
        if (enabledRows.length === 0 && enabledColumns.length === 0 && enabledValues.length === 0) {
            // nothing to group and aggregate by ...
            return [];
        }
        const rowStrategy = config.rowStrategy || PivotRowDimensionsStrategy.instance();
        const data = cloneArray(collection, true);
        return rowStrategy.process(data, enabledRows, config.values, cloneStrategy, pivotKeys);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotRowPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotRowPipe, isStandalone: true, name: "pivotGridRow" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotRowPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridRow',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [] });
/**
 * @hidden
 * Transforms generic array data into IPivotGridRecord[]
 */
export class IgxPivotAutoTransform {
    transform(collection, config, _pipeTrigger, __) {
        let needsTransformation = false;
        if (collection.length > 0) {
            needsTransformation = !this.isPivotRecord(collection[0]);
        }
        if (!needsTransformation)
            return collection;
        const res = this.processCollectionToPivotRecord(config, collection);
        return res;
    }
    isPivotRecord(arg) {
        return !!arg.aggregationValues;
    }
    processCollectionToPivotRecord(config, collection) {
        const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;
        const enabledRows = config.rows.filter(x => x.enabled);
        const allFlat = PivotUtil.flatten(enabledRows);
        const result = [];
        for (const rec of collection) {
            const pivotRec = {
                dimensionValues: new Map(),
                aggregationValues: new Map(),
                children: new Map(),
                dimensions: []
            };
            const keys = Object.keys(rec);
            for (const key of keys) {
                const dim = allFlat.find(x => x.memberName === key);
                if (dim) {
                    //field has matching dimension
                    pivotRec.dimensions.push(dim);
                    pivotRec.dimensionValues.set(key, rec[key]);
                }
                else if (key.indexOf(pivotKeys.rowDimensionSeparator + pivotKeys.records) !== -1) {
                    // field that contains child collection
                    const dimKey = key.slice(0, key.indexOf(pivotKeys.rowDimensionSeparator + pivotKeys.records));
                    const childData = rec[key];
                    const childPivotData = this.processCollectionToPivotRecord(config, childData);
                    pivotRec.children.set(dimKey, childPivotData);
                }
                else {
                    // an aggregation
                    pivotRec.aggregationValues.set(key, rec[key]);
                }
            }
            const flattened = PivotUtil.flatten(config.rows);
            pivotRec.dimensions.sort((x, y) => flattened.indexOf(x) - flattened.indexOf(y));
            result.push(pivotRec);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotAutoTransform, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotAutoTransform, isStandalone: true, name: "pivotGridAutoTransform" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotAutoTransform, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridAutoTransform',
                    pure: true,
                    standalone: true
                }]
        }] });
/**
 * @hidden
 */
export class IgxPivotRowExpansionPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, config, expansionStates, defaultExpand, _pipeTrigger, __) {
        const enabledRows = config.rows?.filter(x => x.enabled) || [];
        const data = collection ? cloneArray(collection, true) : [];
        for (const row of enabledRows) {
            PivotUtil.flattenGroups(data, row, expansionStates, defaultExpand);
        }
        const finalData = enabledRows.length > 0 ?
            data.filter(x => x.dimensions.length === enabledRows.length) : data;
        if (this.grid) {
            this.grid.setFilteredSortedData(finalData, false);
        }
        return finalData;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotRowExpansionPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotRowExpansionPipe, isStandalone: true, name: "pivotGridRowExpansion" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotRowExpansionPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridRowExpansion',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 */
export class IgxPivotCellMergingPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, config, dim, _pipeTrigger) {
        if (collection.length === 0 || config.rows.length === 0)
            return collection;
        const data = collection ? cloneArray(collection, true) : [];
        const res = [];
        const enabledRows = config.rows?.filter(x => x.enabled);
        let groupData = [];
        let prevId;
        const index = enabledRows.indexOf(dim);
        for (const rec of data) {
            const currentDim = rec.dimensions[index];
            const id = PivotUtil.getRecordKey(rec, currentDim);
            if (groupData.length > 0 && prevId !== id) {
                const h = groupData.length > 1 ? groupData.length * this.grid.renderedRowHeight : undefined;
                groupData[0].height = h;
                groupData[0].rowSpan = groupData.length;
                res.push(groupData[0]);
                groupData = [];
            }
            groupData.push(rec);
            prevId = id;
        }
        if (groupData.length > 0) {
            const h = groupData.length > 1 ? groupData.length * this.grid.rowHeight + (groupData.length - 1) + 1 : undefined;
            groupData[0].height = h;
            groupData[0].rowSpan = groupData.length;
            res.push(groupData[0]);
        }
        return res;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotCellMergingPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotCellMergingPipe, isStandalone: true, name: "pivotGridCellMerging" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotCellMergingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridCellMerging',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 */
export class IgxPivotColumnPipe {
    transform(collection, config, cloneStrategy, _, _pipeTrigger, __) {
        const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;
        const enabledColumns = config.columns?.filter(x => x.enabled) || [];
        const enabledValues = config.values?.filter(x => x.enabled) || [];
        const colStrategy = config.columnStrategy || PivotColumnDimensionsStrategy.instance();
        const data = cloneArray(collection, true);
        return colStrategy.process(data, enabledColumns, enabledValues, cloneStrategy, pivotKeys);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotColumnPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotColumnPipe, isStandalone: true, name: "pivotGridColumn" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotColumnPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridColumn',
                    pure: true,
                    standalone: true
                }]
        }] });
/**
 * @hidden
 */
export class IgxPivotGridFilterPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, config, filterStrategy, advancedExpressionsTree, _filterPipeTrigger, _pipeTrigger) {
        const expressionsTree = PivotUtil.buildExpressionTree(config);
        const state = {
            expressionsTree,
            strategy: filterStrategy || new DimensionValuesFilteringStrategy(),
            advancedExpressionsTree
        };
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            return collection;
        }
        const result = FilterUtil.filter(cloneArray(collection, true), state, this.gridAPI.grid);
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridFilterPipe, deps: [{ token: i1.GridBaseAPIService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridFilterPipe, isStandalone: true, name: "pivotGridFilter" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridFilterPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridFilter',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.GridBaseAPIService }] });
/**
 * @hidden
 */
export class IgxPivotGridColumnSortingPipe {
    transform(collection, expressions, sorting, _pipeTrigger) {
        let result;
        if (!expressions.length) {
            result = collection;
        }
        else {
            for (const expr of expressions) {
                expr.strategy = DefaultPivotGridRecordSortingStrategy.instance();
            }
            result = PivotUtil.sort(cloneArray(collection, true), expressions, sorting);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridColumnSortingPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridColumnSortingPipe, isStandalone: true, name: "pivotGridColumnSort" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridColumnSortingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridColumnSort',
                    pure: true,
                    standalone: true
                }]
        }] });
/**
 * @hidden
 */
export class IgxPivotGridSortingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, config, sorting, _pipeTrigger) {
        let result;
        const allDimensions = config.rows || [];
        const enabledDimensions = allDimensions.filter(x => x && x.enabled);
        const expressions = PivotSortUtil.generateDimensionSortingExpressions(enabledDimensions);
        if (!expressions.length) {
            result = collection;
        }
        else {
            result = DataUtil.sort(cloneArray(collection, true), expressions, sorting, this.gridAPI.grid);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridSortingPipe, deps: [{ token: i1.GridBaseAPIService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridSortingPipe, isStandalone: true, name: "pivotGridSort" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridSortingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridSort',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.GridBaseAPIService }] });
/**
 * @hidden
 */
export class IgxFilterPivotItemsPipe {
    transform(collection, filterCriteria, _pipeTrigger) {
        if (!collection) {
            return collection;
        }
        let copy = collection.slice(0);
        if (filterCriteria && filterCriteria.length > 0) {
            const filterFunc = (c) => {
                const filterText = c.member || c.memberName;
                if (!filterText) {
                    return false;
                }
                return (filterText
                    .toLocaleLowerCase()
                    .indexOf(filterCriteria.toLocaleLowerCase()) >= 0 ||
                    (c.children?.some(filterFunc) ?? false));
            };
            copy = collection.filter(filterFunc);
        }
        return copy;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxFilterPivotItemsPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxFilterPivotItemsPipe, isStandalone: true, name: "filterPivotItems" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxFilterPivotItemsPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: "filterPivotItems",
                    standalone: true
                }]
        }] });
export class IgxPivotGridCellStyleClassesPipe {
    transform(cssClasses, _, rowData, columnData, index, __) {
        if (!cssClasses) {
            return '';
        }
        const result = [];
        for (const cssClass of Object.keys(cssClasses)) {
            const callbackOrValue = cssClasses[cssClass];
            const apply = typeof callbackOrValue === 'function' ?
                callbackOrValue(rowData, columnData, resolveNestedPath(rowData, columnData.field), index) : callbackOrValue;
            if (apply) {
                result.push(cssClass);
            }
        }
        return result.join(' ');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridCellStyleClassesPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridCellStyleClassesPipe, isStandalone: true, name: "igxPivotCellStyleClasses" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxPivotGridCellStyleClassesPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'igxPivotCellStyleClasses',
                    standalone: true
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3QtZ3JpZC5waXBlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LWdyaWQucGlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBQzVELE9BQU8sRUFBRSxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDM0QsT0FBTyxFQUFFLHdCQUF3QixFQUE2QixNQUFNLGtEQUFrRCxDQUFDO0FBQ3ZILE9BQU8sRUFBRSxxQ0FBcUMsRUFBRSxNQUFNLDJDQUEyQyxDQUFDO0FBQ2xHLE9BQU8sRUFBRSxVQUFVLEVBQXNCLE1BQU0sMENBQTBDLENBQUM7QUFDMUYsT0FBTyxFQUNILGdDQUFnQyxFQUFFLDZCQUE2QixFQUMvRCwwQkFBMEIsRUFDN0IsTUFBTSxzQ0FBc0MsQ0FBQztBQUc5QyxPQUFPLEVBQVksYUFBYSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFHbkUsT0FBTyxFQUFFLGtCQUFrQixFQUE0SCxNQUFNLHdCQUF3QixDQUFDO0FBQ3RMLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNsRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7QUFHekM7O0dBRUc7QUFNSCxNQUFNLE9BQU8sZUFBZTtJQUV4QixnQkFBZ0IsQ0FBQztJQUVWLFNBQVMsQ0FDWixVQUFlLEVBQ2YsTUFBMkIsRUFDM0IsYUFBaUMsRUFDakMsQ0FBb0IsRUFDcEIsWUFBcUIsRUFDckIsRUFBRztRQUVILE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLElBQUksa0JBQWtCLENBQUM7UUFDekQs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SUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzVCLENBQUM7OEdBbkJRLGdDQUFnQzs0R0FBaEMsZ0NBQWdDOzsyRkFBaEMsZ0NBQWdDO2tCQUo1QyxJQUFJO21CQUFDO29CQUNGLElBQUksRUFBRSwwQkFBMEI7b0JBQ2hDLFVBQVUsRUFBRSxJQUFJO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY2xvbmVBcnJheSwgcmVzb2x2ZU5lc3RlZFBhdGggfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IERhdGFVdGlsIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2RhdGEtdXRpbCc7XG5pbXBvcnQgeyBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUsIElGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLWV4cHJlc3Npb25zLXRyZWUnO1xuaW1wb3J0IHsgRGVmYXVsdFBpdm90R3JpZFJlY29yZFNvcnRpbmdTdHJhdGVneSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9waXZvdC1zb3J0LXN0cmF0ZWd5JztcbmltcG9ydCB7IEZpbHRlclV0aWwsIElGaWx0ZXJpbmdTdHJhdGVneSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9maWx0ZXJpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHtcbiAgICBEaW1lbnNpb25WYWx1ZXNGaWx0ZXJpbmdTdHJhdGVneSwgUGl2b3RDb2x1bW5EaW1lbnNpb25zU3RyYXRlZ3ksXG4gICAgUGl2b3RSb3dEaW1lbnNpb25zU3RyYXRlZ3lcbn0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL3Bpdm90LXN0cmF0ZWd5JztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4uL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IEdyaWRUeXBlLCBJR1hfR1JJRF9CQVNFIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElHcmlkU29ydGluZ1N0cmF0ZWd5IH0gZnJvbSAnLi4vY29tbW9uL3N0cmF0ZWd5JztcbmltcG9ydCB7IElneEdyaWRCYXNlRGlyZWN0aXZlIH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBERUZBVUxUX1BJVk9UX0tFWVMsIElQaXZvdENvbmZpZ3VyYXRpb24sIElQaXZvdERpbWVuc2lvbiwgSVBpdm90R3JpZENvbHVtbiwgSVBpdm90R3JpZEdyb3VwUmVjb3JkLCBJUGl2b3RHcmlkUmVjb3JkLCBJUGl2b3RLZXlzLCBJUGl2b3RWYWx1ZSB9IGZyb20gJy4vcGl2b3QtZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUGl2b3RTb3J0VXRpbCB9IGZyb20gJy4vcGl2b3Qtc29ydC11dGlsJztcbmltcG9ydCB7IFBpdm90VXRpbCB9IGZyb20gJy4vcGl2b3QtdXRpbCc7XG5pbXBvcnQgeyBJRGF0YUNsb25lU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZGF0YS1jbG9uZS1zdHJhdGVneSc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ3Bpdm90R3JpZFJvdycsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90Um93UGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IoKSB7IH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGNvbGxlY3Rpb246IGFueSxcbiAgICAgICAgY29uZmlnOiBJUGl2b3RDb25maWd1cmF0aW9uLFxuICAgICAgICBjbG9uZVN0cmF0ZWd5OiBJRGF0YUNsb25lU3RyYXRlZ3ksXG4gICAgICAgIF86IE1hcDxhbnksIGJvb2xlYW4+LFxuICAgICAgICBfcGlwZVRyaWdnZXI/OiBudW1iZXIsXG4gICAgICAgIF9fP1xuICAgICk6IElQaXZvdEdyaWRSZWNvcmRbXSB7XG4gICAgICAgIGNvbnN0IHBpdm90S2V5cyA9IGNvbmZpZy5waXZvdEtleXMgfHwgREVGQVVMVF9QSVZPVF9LRVlTO1xuICAgICAgICBjb25zdCBlbmFibGVkUm93cyA9IGNvbmZpZy5yb3dzPy5maWx0ZXIoeCA9PiB4LmVuYWJsZWQpIHx8IFtdO1xuICAgICAgICBjb25zdCBlbmFibGVkQ29sdW1ucyA9IGNvbmZpZy5jb2x1bW5zPy5maWx0ZXIoeCA9PiB4LmVuYWJsZWQpIHx8IFtdO1xuICAgICAgICBjb25zdCBlbmFibGVkVmFsdWVzID0gY29uZmlnLnZhbHVlcz8uZmlsdGVyKHggPT4geC5lbmFibGVkKSB8fCBbXTtcbiAgICAgICAgaWYgKGVuYWJsZWRSb3dzLmxlbmd0aCA9PT0gMCAmJiBlbmFibGVkQ29sdW1ucy5sZW5ndGggPT09IDAgJiYgZW5hYmxlZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZ3JvdXAgYW5kIGFnZ3JlZ2F0ZSBieSAuLi5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3dTdHJhdGVneSA9IGNvbmZpZy5yb3dTdHJhdGVneSB8fCBQaXZvdFJvd0RpbWVuc2lvbnNTdHJhdGVneS5pbnN0YW5jZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0gY2xvbmVBcnJheShjb2xsZWN0aW9uLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJvd1N0cmF0ZWd5LnByb2Nlc3MoZGF0YSwgZW5hYmxlZFJvd3MsIGNvbmZpZy52YWx1ZXMsIGNsb25lU3RyYXRlZ3ksIHBpdm90S2V5cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIFRyYW5zZm9ybXMgZ2VuZXJpYyBhcnJheSBkYXRhIGludG8gSVBpdm90R3JpZFJlY29yZFtdXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAncGl2b3RHcmlkQXV0b1RyYW5zZm9ybScsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90QXV0b1RyYW5zZm9ybSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGNvbGxlY3Rpb246IGFueVtdLFxuICAgICAgICBjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24sXG4gICAgICAgIF9waXBlVHJpZ2dlcj86IG51bWJlcixcbiAgICAgICAgX18/LFxuICAgICk6IElQaXZvdEdyaWRSZWNvcmRbXSB7XG4gICAgICAgIGxldCBuZWVkc1RyYW5zZm9ybWF0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5lZWRzVHJhbnNmb3JtYXRpb24gPSAhdGhpcy5pc1Bpdm90UmVjb3JkKGNvbGxlY3Rpb25bMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZWVkc1RyYW5zZm9ybWF0aW9uKSByZXR1cm4gY29sbGVjdGlvbjtcblxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnByb2Nlc3NDb2xsZWN0aW9uVG9QaXZvdFJlY29yZChjb25maWcsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBpc1Bpdm90UmVjb3JkKGFyZzogSVBpdm90R3JpZFJlY29yZCk6IGFyZyBpcyBJUGl2b3RHcmlkUmVjb3JkIHtcbiAgICAgICAgcmV0dXJuICEhKGFyZyBhcyBJUGl2b3RHcmlkUmVjb3JkKS5hZ2dyZWdhdGlvblZhbHVlcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcHJvY2Vzc0NvbGxlY3Rpb25Ub1Bpdm90UmVjb3JkKGNvbmZpZzogSVBpdm90Q29uZmlndXJhdGlvbiwgY29sbGVjdGlvbjogYW55W10pOiBJUGl2b3RHcmlkUmVjb3JkW10ge1xuICAgICAgICBjb25zdCBwaXZvdEtleXM6IElQaXZvdEtleXMgPSBjb25maWcucGl2b3RLZXlzIHx8IERFRkFVTFRfUElWT1RfS0VZUztcbiAgICAgICAgY29uc3QgZW5hYmxlZFJvd3MgPSBjb25maWcucm93cy5maWx0ZXIoeCA9PiB4LmVuYWJsZWQpO1xuICAgICAgICBjb25zdCBhbGxGbGF0OiBJUGl2b3REaW1lbnNpb25bXSA9IFBpdm90VXRpbC5mbGF0dGVuKGVuYWJsZWRSb3dzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBJUGl2b3RHcmlkUmVjb3JkW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByZWMgb2YgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcGl2b3RSZWM6IElQaXZvdEdyaWRSZWNvcmQgPSB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uVmFsdWVzOiBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpLFxuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0aW9uVmFsdWVzOiBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBuZXcgTWFwPHN0cmluZywgSVBpdm90R3JpZFJlY29yZFtdPigpLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlYylcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaW0gPSBhbGxGbGF0LmZpbmQoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpbSkge1xuICAgICAgICAgICAgICAgICAgICAvL2ZpZWxkIGhhcyBtYXRjaGluZyBkaW1lbnNpb25cbiAgICAgICAgICAgICAgICAgICAgcGl2b3RSZWMuZGltZW5zaW9ucy5wdXNoKGRpbSk7XG4gICAgICAgICAgICAgICAgICAgIHBpdm90UmVjLmRpbWVuc2lvblZhbHVlcy5zZXQoa2V5LCByZWNba2V5XSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkuaW5kZXhPZihwaXZvdEtleXMucm93RGltZW5zaW9uU2VwYXJhdG9yICsgcGl2b3RLZXlzLnJlY29yZHMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZCB0aGF0IGNvbnRhaW5zIGNoaWxkIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGltS2V5ID0ga2V5LnNsaWNlKDAsIGtleS5pbmRleE9mKHBpdm90S2V5cy5yb3dEaW1lbnNpb25TZXBhcmF0b3IgKyBwaXZvdEtleXMucmVjb3JkcykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZERhdGEgPSByZWNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRQaXZvdERhdGEgPSB0aGlzLnByb2Nlc3NDb2xsZWN0aW9uVG9QaXZvdFJlY29yZChjb25maWcsIGNoaWxkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHBpdm90UmVjLmNoaWxkcmVuLnNldChkaW1LZXksIGNoaWxkUGl2b3REYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhZ2dyZWdhdGlvblxuICAgICAgICAgICAgICAgICAgICBwaXZvdFJlYy5hZ2dyZWdhdGlvblZhbHVlcy5zZXQoa2V5LCByZWNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkID0gUGl2b3RVdGlsLmZsYXR0ZW4oY29uZmlnLnJvd3MpO1xuICAgICAgICAgICAgcGl2b3RSZWMuZGltZW5zaW9ucy5zb3J0KCh4LCB5KSA9PiBmbGF0dGVuZWQuaW5kZXhPZih4KSAtIGZsYXR0ZW5lZC5pbmRleE9mKHkpKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBpdm90UmVjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdwaXZvdEdyaWRSb3dFeHBhbnNpb24nLFxuICAgIHB1cmU6IHRydWUsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdFJvd0V4cGFuc2lvblBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoSUdYX0dSSURfQkFTRSkgcHJpdmF0ZSBncmlkPzogR3JpZFR5cGUpIHsgfVxuXG4gICAgcHVibGljIHRyYW5zZm9ybShcbiAgICAgICAgY29sbGVjdGlvbjogSVBpdm90R3JpZFJlY29yZFtdLFxuICAgICAgICBjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24sXG4gICAgICAgIGV4cGFuc2lvblN0YXRlczogTWFwPGFueSwgYm9vbGVhbj4sXG4gICAgICAgIGRlZmF1bHRFeHBhbmQ6IGJvb2xlYW4sXG4gICAgICAgIF9waXBlVHJpZ2dlcj86IG51bWJlcixcbiAgICAgICAgX18/LFxuICAgICk6IElQaXZvdEdyaWRSZWNvcmRbXSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZWRSb3dzID0gY29uZmlnLnJvd3M/LmZpbHRlcih4ID0+IHguZW5hYmxlZCkgfHwgW107XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjb2xsZWN0aW9uID8gY2xvbmVBcnJheShjb2xsZWN0aW9uLCB0cnVlKSA6IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBlbmFibGVkUm93cykge1xuICAgICAgICAgICAgUGl2b3RVdGlsLmZsYXR0ZW5Hcm91cHMoZGF0YSwgcm93LCBleHBhbnNpb25TdGF0ZXMsIGRlZmF1bHRFeHBhbmQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbmFsRGF0YSA9IGVuYWJsZWRSb3dzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgZGF0YS5maWx0ZXIoeCA9PiB4LmRpbWVuc2lvbnMubGVuZ3RoID09PSBlbmFibGVkUm93cy5sZW5ndGgpIDogZGF0YTtcblxuICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc2V0RmlsdGVyZWRTb3J0ZWREYXRhKGZpbmFsRGF0YSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5hbERhdGE7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdwaXZvdEdyaWRDZWxsTWVyZ2luZycsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90Q2VsbE1lcmdpbmdQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoQEluamVjdChJR1hfR1JJRF9CQVNFKSBwcml2YXRlIGdyaWQ6IEdyaWRUeXBlKSB7IH1cbiAgICBwdWJsaWMgdHJhbnNmb3JtKFxuICAgICAgICBjb2xsZWN0aW9uOiBJUGl2b3RHcmlkUmVjb3JkW10sXG4gICAgICAgIGNvbmZpZzogSVBpdm90Q29uZmlndXJhdGlvbixcbiAgICAgICAgZGltOiBJUGl2b3REaW1lbnNpb24sXG4gICAgICAgIF9waXBlVHJpZ2dlcj86IG51bWJlclxuICAgICk6IElQaXZvdEdyaWRHcm91cFJlY29yZFtdIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoID09PSAwIHx8IGNvbmZpZy5yb3dzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIGNvbnN0IGRhdGE6IElQaXZvdEdyaWRHcm91cFJlY29yZFtdID0gY29sbGVjdGlvbiA/IGNsb25lQXJyYXkoY29sbGVjdGlvbiwgdHJ1ZSkgOiBbXTtcbiAgICAgICAgY29uc3QgcmVzOiBJUGl2b3RHcmlkR3JvdXBSZWNvcmRbXSA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGVuYWJsZWRSb3dzID0gY29uZmlnLnJvd3M/LmZpbHRlcih4ID0+IHguZW5hYmxlZCk7XG4gICAgICAgIGxldCBncm91cERhdGE6IElQaXZvdEdyaWRHcm91cFJlY29yZFtdID0gW107XG4gICAgICAgIGxldCBwcmV2SWQ7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZW5hYmxlZFJvd3MuaW5kZXhPZihkaW0pO1xuICAgICAgICBmb3IgKGNvbnN0IHJlYyBvZiBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RGltID0gcmVjLmRpbWVuc2lvbnNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaWQgPSBQaXZvdFV0aWwuZ2V0UmVjb3JkS2V5KHJlYywgY3VycmVudERpbSk7XG4gICAgICAgICAgICBpZiAoZ3JvdXBEYXRhLmxlbmd0aCA+IDAgJiYgcHJldklkICE9PSBpZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGggPSBncm91cERhdGEubGVuZ3RoID4gMSA/IGdyb3VwRGF0YS5sZW5ndGggKiB0aGlzLmdyaWQucmVuZGVyZWRSb3dIZWlnaHQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZ3JvdXBEYXRhWzBdLmhlaWdodCA9IGg7XG4gICAgICAgICAgICAgICAgZ3JvdXBEYXRhWzBdLnJvd1NwYW4gPSBncm91cERhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGdyb3VwRGF0YVswXSk7XG4gICAgICAgICAgICAgICAgZ3JvdXBEYXRhID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncm91cERhdGEucHVzaChyZWMpO1xuICAgICAgICAgICAgcHJldklkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBoID0gZ3JvdXBEYXRhLmxlbmd0aCA+IDEgPyBncm91cERhdGEubGVuZ3RoICogdGhpcy5ncmlkLnJvd0hlaWdodCArIChncm91cERhdGEubGVuZ3RoIC0gMSkgKyAxIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgZ3JvdXBEYXRhWzBdLmhlaWdodCA9IGg7XG4gICAgICAgICAgICBncm91cERhdGFbMF0ucm93U3BhbiA9IGdyb3VwRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICByZXMucHVzaChncm91cERhdGFbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ3Bpdm90R3JpZENvbHVtbicsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90Q29sdW1uUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgcHVibGljIHRyYW5zZm9ybShcbiAgICAgICAgY29sbGVjdGlvbjogSVBpdm90R3JpZFJlY29yZFtdLFxuICAgICAgICBjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24sXG4gICAgICAgIGNsb25lU3RyYXRlZ3k6IElEYXRhQ2xvbmVTdHJhdGVneSxcbiAgICAgICAgXzogTWFwPGFueSwgYm9vbGVhbj4sXG4gICAgICAgIF9waXBlVHJpZ2dlcj86IG51bWJlcixcbiAgICAgICAgX18/XG4gICAgKTogSVBpdm90R3JpZFJlY29yZFtdIHtcbiAgICAgICAgY29uc3QgcGl2b3RLZXlzID0gY29uZmlnLnBpdm90S2V5cyB8fCBERUZBVUxUX1BJVk9UX0tFWVM7XG4gICAgICAgIGNvbnN0IGVuYWJsZWRDb2x1bW5zID0gY29uZmlnLmNvbHVtbnM/LmZpbHRlcih4ID0+IHguZW5hYmxlZCkgfHwgW107XG4gICAgICAgIGNvbnN0IGVuYWJsZWRWYWx1ZXMgPSBjb25maWcudmFsdWVzPy5maWx0ZXIoeCA9PiB4LmVuYWJsZWQpIHx8IFtdO1xuXG4gICAgICAgIGNvbnN0IGNvbFN0cmF0ZWd5ID0gY29uZmlnLmNvbHVtblN0cmF0ZWd5IHx8IFBpdm90Q29sdW1uRGltZW5zaW9uc1N0cmF0ZWd5Lmluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjbG9uZUFycmF5KGNvbGxlY3Rpb24sIHRydWUpO1xuICAgICAgICByZXR1cm4gY29sU3RyYXRlZ3kucHJvY2VzcyhkYXRhLCBlbmFibGVkQ29sdW1ucywgZW5hYmxlZFZhbHVlcywgY2xvbmVTdHJhdGVneSwgcGl2b3RLZXlzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ3Bpdm90R3JpZEZpbHRlcicsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90R3JpZEZpbHRlclBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPikgeyB9XG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBhbnlbXSxcbiAgICAgICAgY29uZmlnOiBJUGl2b3RDb25maWd1cmF0aW9uLFxuICAgICAgICBmaWx0ZXJTdHJhdGVneTogSUZpbHRlcmluZ1N0cmF0ZWd5LFxuICAgICAgICBhZHZhbmNlZEV4cHJlc3Npb25zVHJlZTogSUZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSxcbiAgICAgICAgX2ZpbHRlclBpcGVUcmlnZ2VyOiBudW1iZXIsXG4gICAgICAgIF9waXBlVHJpZ2dlcjogbnVtYmVyKTogYW55W10ge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uc1RyZWUgPSBQaXZvdFV0aWwuYnVpbGRFeHByZXNzaW9uVHJlZShjb25maWcpO1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnNUcmVlLFxuICAgICAgICAgICAgc3RyYXRlZ3k6IGZpbHRlclN0cmF0ZWd5IHx8IG5ldyBEaW1lbnNpb25WYWx1ZXNGaWx0ZXJpbmdTdHJhdGVneSgpLFxuICAgICAgICAgICAgYWR2YW5jZWRFeHByZXNzaW9uc1RyZWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlLmVtcHR5KHN0YXRlLmV4cHJlc3Npb25zVHJlZSkgJiYgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlLmVtcHR5KHN0YXRlLmFkdmFuY2VkRXhwcmVzc2lvbnNUcmVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBGaWx0ZXJVdGlsLmZpbHRlcihjbG9uZUFycmF5KGNvbGxlY3Rpb24sIHRydWUpLCBzdGF0ZSwgdGhpcy5ncmlkQVBJLmdyaWQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ3Bpdm90R3JpZENvbHVtblNvcnQnLFxuICAgIHB1cmU6IHRydWUsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdEdyaWRDb2x1bW5Tb3J0aW5nUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGNvbGxlY3Rpb246IElQaXZvdEdyaWRSZWNvcmRbXSxcbiAgICAgICAgZXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdLFxuICAgICAgICBzb3J0aW5nOiBJR3JpZFNvcnRpbmdTdHJhdGVneSxcbiAgICAgICAgX3BpcGVUcmlnZ2VyOiBudW1iZXJcbiAgICApOiBJUGl2b3RHcmlkUmVjb3JkW10ge1xuICAgICAgICBsZXQgcmVzdWx0OiBJUGl2b3RHcmlkUmVjb3JkW107XG5cbiAgICAgICAgaWYgKCFleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbGxlY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4cHIgb2YgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBleHByLnN0cmF0ZWd5ID0gRGVmYXVsdFBpdm90R3JpZFJlY29yZFNvcnRpbmdTdHJhdGVneS5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gUGl2b3RVdGlsLnNvcnQoY2xvbmVBcnJheShjb2xsZWN0aW9uLCB0cnVlKSwgZXhwcmVzc2lvbnMsIHNvcnRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdwaXZvdEdyaWRTb3J0JyxcbiAgICBwdXJlOiB0cnVlLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4UGl2b3RHcmlkU29ydGluZ1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPikgeyB9XG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBhbnlbXSwgY29uZmlnOiBJUGl2b3RDb25maWd1cmF0aW9uLCBzb3J0aW5nOiBJR3JpZFNvcnRpbmdTdHJhdGVneSwgX3BpcGVUcmlnZ2VyOiBudW1iZXIpOiBhbnlbXSB7XG4gICAgICAgIGxldCByZXN1bHQ6IGFueVtdO1xuICAgICAgICBjb25zdCBhbGxEaW1lbnNpb25zID0gY29uZmlnLnJvd3MgfHwgW107XG4gICAgICAgIGNvbnN0IGVuYWJsZWREaW1lbnNpb25zID0gYWxsRGltZW5zaW9ucy5maWx0ZXIoeCA9PiB4ICYmIHguZW5hYmxlZCk7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gUGl2b3RTb3J0VXRpbC5nZW5lcmF0ZURpbWVuc2lvblNvcnRpbmdFeHByZXNzaW9ucyhlbmFibGVkRGltZW5zaW9ucyk7XG4gICAgICAgIGlmICghZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb2xsZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gRGF0YVV0aWwuc29ydChjbG9uZUFycmF5KGNvbGxlY3Rpb24sIHRydWUpLCBleHByZXNzaW9ucywgc29ydGluZywgdGhpcy5ncmlkQVBJLmdyaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogXCJmaWx0ZXJQaXZvdEl0ZW1zXCIsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hGaWx0ZXJQaXZvdEl0ZW1zUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGNvbGxlY3Rpb246IChJUGl2b3REaW1lbnNpb24gfCBJUGl2b3RWYWx1ZSlbXSxcbiAgICAgICAgZmlsdGVyQ3JpdGVyaWE6IHN0cmluZyxcbiAgICAgICAgX3BpcGVUcmlnZ2VyOiBudW1iZXJcbiAgICApOiBhbnlbXSB7XG4gICAgICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvcHkgPSBjb2xsZWN0aW9uLnNsaWNlKDApO1xuICAgICAgICBpZiAoZmlsdGVyQ3JpdGVyaWEgJiYgZmlsdGVyQ3JpdGVyaWEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRnVuYyA9IChjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyVGV4dCA9IGMubWVtYmVyIHx8IGMubWVtYmVyTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlclRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAudG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmluZGV4T2YoZmlsdGVyQ3JpdGVyaWEudG9Mb2NhbGVMb3dlckNhc2UoKSkgPj0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAoYy5jaGlsZHJlbj8uc29tZShmaWx0ZXJGdW5jKSA/PyBmYWxzZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvcHkgPSBjb2xsZWN0aW9uLmZpbHRlcihmaWx0ZXJGdW5jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JpZFN0eWxlQ1NTUHJvcGVydHkge1xuICAgIFtwcm9wOiBzdHJpbmddOiBhbnk7XG59XG5cbkBQaXBlKHtcbiAgICBuYW1lOiAnaWd4UGl2b3RDZWxsU3R5bGVDbGFzc2VzJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90R3JpZENlbGxTdHlsZUNsYXNzZXNQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKGNzc0NsYXNzZXM6IEdyaWRTdHlsZUNTU1Byb3BlcnR5LCBfOiBhbnksIHJvd0RhdGE6IElQaXZvdEdyaWRSZWNvcmQsIGNvbHVtbkRhdGE6IElQaXZvdEdyaWRDb2x1bW4sIGluZGV4OiBudW1iZXIsIF9fOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIWNzc0NsYXNzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgY3NzQ2xhc3Mgb2YgT2JqZWN0LmtleXMoY3NzQ2xhc3NlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrT3JWYWx1ZSA9IGNzc0NsYXNzZXNbY3NzQ2xhc3NdO1xuICAgICAgICAgICAgY29uc3QgYXBwbHkgPSB0eXBlb2YgY2FsbGJhY2tPclZhbHVlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICBjYWxsYmFja09yVmFsdWUocm93RGF0YSwgY29sdW1uRGF0YSwgcmVzb2x2ZU5lc3RlZFBhdGgocm93RGF0YSwgY29sdW1uRGF0YS5maWVsZCksIGluZGV4KSA6IGNhbGxiYWNrT3JWYWx1ZTtcbiAgICAgICAgICAgIGlmIChhcHBseSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNzc0NsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignICcpO1xuICAgIH1cbn1cbiJdfQ==