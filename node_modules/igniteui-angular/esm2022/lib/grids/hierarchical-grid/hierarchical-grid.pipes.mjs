import { Inject, Pipe } from '@angular/core';
import { cloneArray, resolveNestedPath } from '../../core/utils';
import { DataUtil } from '../../data-operations/data-util';
import { GridPagingMode } from '../common/enums';
import { IGX_GRID_BASE } from '../common/grid.interface';
import * as i0 from "@angular/core";
/**
 * @hidden
 */
export class IgxGridHierarchicalPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, state = new Map(), id, primaryKey, childKeys, _pipeTrigger) {
        if (childKeys.length === 0) {
            return collection;
        }
        if (this.grid.verticalScrollContainer.isRemote) {
            return collection;
        }
        const result = this.addHierarchy(this.grid, cloneArray(collection), state, primaryKey, childKeys);
        return result;
    }
    addHierarchy(grid, data, state, primaryKey, childKeys) {
        const result = [];
        data.forEach((v) => {
            result.push(v);
            const childGridsData = {};
            childKeys.forEach((childKey) => {
                if (!v[childKey]) {
                    v[childKey] = [];
                }
                const hasNestedPath = childKey?.includes('.');
                const childData = !hasNestedPath ? v[childKey] : resolveNestedPath(v, childKey);
                childGridsData[childKey] = childData;
            });
            if (grid.gridAPI.get_row_expansion_state(v)) {
                result.push({ rowID: primaryKey ? v[primaryKey] : v, childGridsData });
            }
        });
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxGridHierarchicalPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxGridHierarchicalPipe, isStandalone: true, name: "gridHierarchical" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxGridHierarchicalPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'gridHierarchical',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 */
export class IgxGridHierarchicalPagingPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, enabled, page = 0, perPage = 15, _id, _pipeTrigger) {
        if (!enabled || this.grid.pagingMode !== GridPagingMode.Local) {
            return collection;
        }
        const state = {
            index: page,
            recordsPerPage: perPage
        };
        const total = this.grid._totalRecords >= 0 ? this.grid._totalRecords : collection.length;
        const result = DataUtil.page(cloneArray(collection), state, total);
        this.grid.pagingState = state;
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxGridHierarchicalPagingPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxGridHierarchicalPagingPipe, isStandalone: true, name: "gridHierarchicalPaging" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxGridHierarchicalPagingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'gridHierarchicalPaging',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGllcmFyY2hpY2FsLWdyaWQucGlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvaGllcmFyY2hpY2FsLWdyaWQvaGllcmFyY2hpY2FsLWdyaWQucGlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBQzVELE9BQU8sRUFBRSxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDM0QsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2pELE9BQU8sRUFBWSxhQUFhLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7QUFFbkU7O0dBRUc7QUFLSCxNQUFNLE9BQU8sdUJBQXVCO0lBRWhDLFlBQTJDLElBQWM7UUFBZCxTQUFJLEdBQUosSUFBSSxDQUFVO0lBQUksQ0FBQztJQUV2RCxTQUFTLENBQ1osVUFBZSxFQUNmLFFBQVEsSUFBSSxHQUFHLEVBQWdCLEVBQy9CLEVBQVUsRUFDVixVQUFlLEVBQ2YsU0FBbUIsRUFDbkIsWUFBb0I7UUFFcEIsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN4QixPQUFPLFVBQVUsQ0FBQztTQUNyQjtRQUNELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLEVBQUU7WUFDNUMsT0FBTyxVQUFVLENBQUM7U0FDckI7UUFDRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFFbEcsT0FBTyxNQUFN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c0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBjbG9uZUFycmF5LCByZXNvbHZlTmVzdGVkUGF0aCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgRGF0YVV0aWwgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsJztcbmltcG9ydCB7IEdyaWRQYWdpbmdNb2RlIH0gZnJvbSAnLi4vY29tbW9uL2VudW1zJztcbmltcG9ydCB7IEdyaWRUeXBlLCBJR1hfR1JJRF9CQVNFIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnZ3JpZEhpZXJhcmNoaWNhbCcsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkSGllcmFyY2hpY2FsUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChJR1hfR1JJRF9CQVNFKSBwcml2YXRlIGdyaWQ6IEdyaWRUeXBlKSB7IH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGNvbGxlY3Rpb246IGFueSxcbiAgICAgICAgc3RhdGUgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKSxcbiAgICAgICAgaWQ6IHN0cmluZyxcbiAgICAgICAgcHJpbWFyeUtleTogYW55LFxuICAgICAgICBjaGlsZEtleXM6IHN0cmluZ1tdLFxuICAgICAgICBfcGlwZVRyaWdnZXI6IG51bWJlclxuICAgICk6IGFueVtdIHtcbiAgICAgICAgaWYgKGNoaWxkS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWRkSGllcmFyY2h5KHRoaXMuZ3JpZCwgY2xvbmVBcnJheShjb2xsZWN0aW9uKSwgc3RhdGUsIHByaW1hcnlLZXksIGNoaWxkS2V5cyk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkSGllcmFyY2h5PFQ+KGdyaWQsIGRhdGE6IFRbXSwgc3RhdGUsIHByaW1hcnlLZXksIGNoaWxkS2V5czogc3RyaW5nW10pOiBUW10ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgICBkYXRhLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHYpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRHcmlkc0RhdGEgPSB7fTtcbiAgICAgICAgICAgIGNoaWxkS2V5cy5mb3JFYWNoKChjaGlsZEtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdltjaGlsZEtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdltjaGlsZEtleV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTmVzdGVkUGF0aCA9IGNoaWxkS2V5Py5pbmNsdWRlcygnLicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkRGF0YSA9ICFoYXNOZXN0ZWRQYXRoID8gdltjaGlsZEtleV0gOiByZXNvbHZlTmVzdGVkUGF0aCh2LCBjaGlsZEtleSk7XG4gICAgICAgICAgICAgICAgY2hpbGRHcmlkc0RhdGFbY2hpbGRLZXldID0gY2hpbGREYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZ3JpZC5ncmlkQVBJLmdldF9yb3dfZXhwYW5zaW9uX3N0YXRlKHYpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyByb3dJRDogcHJpbWFyeUtleSA/IHZbcHJpbWFyeUtleV0gOiB2LCBjaGlsZEdyaWRzRGF0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdncmlkSGllcmFyY2hpY2FsUGFnaW5nJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRIaWVyYXJjaGljYWxQYWdpbmdQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KElHWF9HUklEX0JBU0UpIHByaXZhdGUgZ3JpZDogR3JpZFR5cGUpIHsgfVxuXG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBhbnlbXSwgZW5hYmxlZDogYm9vbGVhbiwgcGFnZSA9IDAsIHBlclBhZ2UgPSAxNSwgX2lkOiBzdHJpbmcsIF9waXBlVHJpZ2dlcjogbnVtYmVyKTogYW55W10ge1xuICAgICAgICBpZiAoIWVuYWJsZWQgfHwgdGhpcy5ncmlkLnBhZ2luZ01vZGUgIT09IEdyaWRQYWdpbmdNb2RlLkxvY2FsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgaW5kZXg6IHBhZ2UsXG4gICAgICAgICAgICByZWNvcmRzUGVyUGFnZTogcGVyUGFnZVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHRvdGFsID0gdGhpcy5ncmlkLl90b3RhbFJlY29yZHMgPj0gMCA/IHRoaXMuZ3JpZC5fdG90YWxSZWNvcmRzIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogYW55W10gPSBEYXRhVXRpbC5wYWdlKGNsb25lQXJyYXkoY29sbGVjdGlvbiksIHN0YXRlLCB0b3RhbCk7XG4gICAgICAgIHRoaXMuZ3JpZC5wYWdpbmdTdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfVxufVxuIl19