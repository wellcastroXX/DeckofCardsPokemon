import { Injectable } from '@angular/core';
import { first } from 'rxjs/operators';
import { NAVIGATION_KEYS, SUPPORTED_KEYS } from '../../core/utils';
import { IgxGridNavigationService } from '../grid-navigation.service';
import * as i0 from "@angular/core";
export class IgxHierarchicalGridNavigationService extends IgxGridNavigationService {
    constructor() {
        super(...arguments);
        this._pendingNavigation = false;
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
            !this.grid.crudService.rowEditingBlocked && !this.grid.crudService.rowInEditMode) {
            return;
        }
        const targetGrid = this.getClosestElemByTag(event.target, 'igx-hierarchical-grid');
        if (targetGrid !== this.grid.nativeElement) {
            return;
        }
        if (this._pendingNavigation && NAVIGATION_KEYS.has(key)) {
            // In case focus needs to be moved from one grid to another, however there is a pending scroll operation
            // which is an async operation, any additional navigation keys should be ignored
            // untill operation complete.
            event.preventDefault();
            return;
        }
        super.dispatchEvent(event);
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        const rec = this.grid.dataView[rowIndex];
        if (rec && this.grid.isChildGridRecord(rec)) {
            // target is child grid
            const virtState = this.grid.verticalScrollContainer.state;
            const inView = rowIndex >= virtState.startIndex && rowIndex <= virtState.startIndex + virtState.chunkSize;
            const isNext = this.activeNode.row < rowIndex;
            const targetLayoutIndex = isNext ? null : this.grid.childLayoutKeys.length - 1;
            if (inView) {
                this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            }
            else {
                let scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(rowIndex, !isNext);
                scrollAmount += isNext ? 1 : -1;
                this.grid.verticalScrollContainer.getScroll().scrollTop = scrollAmount;
                this._pendingNavigation = true;
                this.grid.verticalScrollContainer.chunkLoad.pipe(first()).subscribe(() => {
                    this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
                    this._pendingNavigation = false;
                });
            }
            return;
        }
        const isLast = rowIndex === this.grid.dataView.length;
        if ((rowIndex === -1 || isLast) &&
            this.grid.parent !== null) {
            // reached end of child grid
            const nextSiblingIndex = this.nextSiblingIndex(isLast);
            if (nextSiblingIndex !== null) {
                this.grid.parent.navigation._moveToChild(this.grid.childRow.index, visibleColIndex, isLast, nextSiblingIndex, cb);
            }
            else {
                this._moveToParent(isLast, visibleColIndex, cb);
            }
            return;
        }
        if (this.grid.parent) {
            const isNext = this.activeNode && typeof this.activeNode.row === 'number' ? rowIndex > this.activeNode.row : false;
            const cbHandler = (args) => {
                this._handleScrollInChild(rowIndex, isNext);
                cb(args);
            };
            if (!this.activeNode) {
                this.activeNode = { row: null, column: null };
            }
            super.navigateInBody(rowIndex, visibleColIndex, cbHandler);
            return;
        }
        if (!this.activeNode) {
            this.activeNode = { row: null, column: null };
        }
        super.navigateInBody(rowIndex, visibleColIndex, cb);
    }
    shouldPerformVerticalScroll(index, visibleColumnIndex = -1, isNext) {
        const targetRec = this.grid.dataView[index];
        if (this.grid.isChildGridRecord(targetRec)) {
            const scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(index, !isNext);
            const currScroll = this.grid.verticalScrollContainer.getScroll().scrollTop;
            const shouldScroll = !isNext ? scrollAmount > currScroll : currScroll < scrollAmount;
            return shouldScroll;
        }
        else {
            return super.shouldPerformVerticalScroll(index, visibleColumnIndex);
        }
    }
    focusTbody(event) {
        if (!this.activeNode || this.activeNode.row === null) {
            this.activeNode = {
                row: 0,
                column: 0
            };
            this.grid.navigateTo(0, 0, (obj) => {
                this.grid.clearCellSelection();
                obj.target.activate(event);
            });
        }
        else {
            super.focusTbody(event);
        }
    }
    nextSiblingIndex(isNext) {
        const layoutKey = this.grid.childRow.layout.key;
        const layoutIndex = this.grid.parent.childLayoutKeys.indexOf(layoutKey);
        const nextIndex = isNext ? layoutIndex + 1 : layoutIndex - 1;
        if (nextIndex <= this.grid.parent.childLayoutKeys.length - 1 && nextIndex > -1) {
            return nextIndex;
        }
        else {
            return null;
        }
    }
    /**
     * Handles scrolling in child grid and ensures target child row is in main grid view port.
     *
     * @param rowIndex The row index which should be in view.
     * @param isNext  Optional. Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    _handleScrollInChild(rowIndex, isNext, cb) {
        const shouldScroll = this.shouldPerformVerticalScroll(rowIndex, -1, isNext);
        if (shouldScroll) {
            this.grid.navigation.performVerticalScrollToCell(rowIndex, -1, () => {
                this.positionInParent(rowIndex, isNext, cb);
            });
        }
        else {
            this.positionInParent(rowIndex, isNext, cb);
        }
    }
    /**
     *
     * @param rowIndex Row index that should come in view.
     * @param isNext  Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    positionInParent(rowIndex, isNext, cb) {
        const row = this.grid.gridAPI.get_row_by_index(rowIndex);
        if (!row) {
            if (cb) {
                cb();
            }
            return;
        }
        const positionInfo = this.getPositionInfo(row, isNext);
        if (!positionInfo.inView) {
            // stop event from triggering multiple times before scrolling is complete.
            this._pendingNavigation = true;
            const scrollableGrid = isNext ? this.getNextScrollableDown(this.grid) : this.getNextScrollableUp(this.grid);
            scrollableGrid.grid.verticalScrollContainer.recalcUpdateSizes();
            scrollableGrid.grid.verticalScrollContainer.addScrollTop(positionInfo.offset);
            scrollableGrid.grid.verticalScrollContainer.chunkLoad.pipe(first()).subscribe(() => {
                this._pendingNavigation = false;
                if (cb) {
                    cb();
                }
            });
        }
        else {
            if (cb) {
                cb();
            }
        }
    }
    /**
     * Moves navigation to child grid.
     *
     * @param parentRowIndex The parent row index, at which the child grid is rendered.
     * @param childLayoutIndex Optional. The index of the child row island to which the child grid belongs to. Uses first if not set.
     */
    _moveToChild(parentRowIndex, visibleColIndex, isNext, childLayoutIndex, cb) {
        const ri = typeof childLayoutIndex !== 'number' ?
            this.grid.childLayoutList.first : this.grid.childLayoutList.toArray()[childLayoutIndex];
        const rowId = this.grid.dataView[parentRowIndex].rowID;
        const pathSegment = {
            rowID: rowId,
            rowKey: rowId,
            rowIslandKey: ri.key
        };
        const childGrid = this.grid.gridAPI.getChildGrid([pathSegment]);
        const targetIndex = isNext ? 0 : childGrid.dataView.length - 1;
        const targetRec = childGrid.dataView[targetIndex];
        if (!targetRec) {
            // if no target rec, then move on in next sibling or parent
            childGrid.navigation.navigateInBody(targetIndex, visibleColIndex, cb);
            return;
        }
        if (childGrid.isChildGridRecord(targetRec)) {
            // if target is a child grid record should move into it.
            this.grid.navigation.activeNode.row = null;
            childGrid.navigation.activeNode = { row: targetIndex, column: this.activeNode.column };
            childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
                const targetLayoutIndex = isNext ? 0 : childGrid.childLayoutList.toArray().length - 1;
                childGrid.navigation._moveToChild(targetIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            });
            return;
        }
        const childGridNav = childGrid.navigation;
        this.clearActivation();
        const lastVisibleIndex = childGridNav.lastColumnIndex;
        const columnIndex = visibleColIndex <= lastVisibleIndex ? visibleColIndex : lastVisibleIndex;
        childGridNav.activeNode = { row: targetIndex, column: columnIndex };
        childGrid.tbody.nativeElement.focus({ preventScroll: true });
        this._pendingNavigation = false;
        childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
            childGrid.navigateTo(targetIndex, columnIndex, cb);
        });
    }
    /**
     * Moves navigation back to parent grid.
     *
     * @param rowIndex
     */
    _moveToParent(isNext, columnIndex, cb) {
        const indexInParent = this.grid.childRow.index;
        const hasNextTarget = this.hasNextTarget(this.grid.parent, indexInParent, isNext);
        if (!hasNextTarget) {
            return;
        }
        this.clearActivation();
        const targetRowIndex = isNext ? indexInParent + 1 : indexInParent - 1;
        const lastVisibleIndex = this.grid.parent.navigation.lastColumnIndex;
        const nextColumnIndex = columnIndex <= lastVisibleIndex ? columnIndex : lastVisibleIndex;
        this._pendingNavigation = true;
        const cbFunc = (args) => {
            this._pendingNavigation = false;
            cb(args);
            args.target.grid.tbody.nativeElement.focus();
        };
        this.grid.parent.navigation.navigateInBody(targetRowIndex, nextColumnIndex, cbFunc);
    }
    /**
     * Gets information on the row position relative to the root grid view port.
     * Returns whether the row is in view and its offset.
     *
     * @param rowObj
     * @param isNext
     */
    getPositionInfo(row, isNext) {
        // XXX: Fix type
        let rowElem = row.nativeElement;
        if (row.layout) {
            const childLayoutKeys = this.grid.childLayoutKeys;
            const riKey = isNext ? childLayoutKeys[0] : childLayoutKeys[childLayoutKeys.length - 1];
            const pathSegment = {
                rowID: row.data.rowID, rowKey: row.data.rowID,
                rowIslandKey: riKey
            };
            const childGrid = this.grid.gridAPI.getChildGrid([pathSegment]);
            rowElem = childGrid.tfoot.nativeElement;
        }
        const gridBottom = this._getMinBottom(this.grid);
        const diffBottom = rowElem.getBoundingClientRect().bottom - gridBottom;
        const gridTop = this._getMaxTop(this.grid);
        const diffTop = rowElem.getBoundingClientRect().bottom -
            rowElem.offsetHeight - gridTop;
        // Adding Math.Round because Chrome has some inconsistencies when the page is zoomed
        const isInView = isNext ? Math.round(diffBottom) <= 0 : Math.round(diffTop) >= 0;
        const calcOffset = isNext ? diffBottom : diffTop;
        return { inView: isInView, offset: calcOffset };
    }
    /**
     * Gets closest element by its tag name.
     *
     * @param sourceElem The element from which to start the search.
     * @param targetTag The target element tag name, for which to search.
     */
    getClosestElemByTag(sourceElem, targetTag) {
        let result = sourceElem;
        while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                return result;
            }
            result = result.parentNode;
        }
        return null;
    }
    clearActivation() {
        // clear if previous activation exists.
        if (this.activeNode && Object.keys(this.activeNode).length) {
            this.activeNode = Object.assign({});
        }
    }
    hasNextTarget(grid, index, isNext) {
        const targetRowIndex = isNext ? index + 1 : index - 1;
        const hasTargetRecord = !!grid.dataView[targetRowIndex];
        if (hasTargetRecord) {
            return true;
        }
        else {
            let hasTargetRecordInParent = false;
            if (grid.parent) {
                const indexInParent = grid.childRow.index;
                hasTargetRecordInParent = this.hasNextTarget(grid.parent, indexInParent, isNext);
            }
            return hasTargetRecordInParent;
        }
    }
    /**
     * Gets the max top view in the current grid hierarchy.
     *
     * @param grid
     */
    _getMaxTop(grid) {
        let currGrid = grid;
        let top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top + pinnedRowsHeight);
        }
        return top;
    }
    /**
     * Gets the min bottom view in the current grid hierarchy.
     *
     * @param grid
     */
    _getMinBottom(grid) {
        let currGrid = grid;
        let bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && !currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom - pinnedRowsHeight);
        }
        return bottom;
    }
    /**
     * Finds the next grid that allows scrolling down.
     *
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableDown(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid, prev: null };
        }
        let scrollTop = currGrid.verticalScrollContainer.scrollPosition;
        let scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
        let nonScrollable = scrollHeight === 0 ||
            Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        return { grid: currGrid, prev };
    }
    /**
     * Finds the next grid that allows scrolling up.
     *
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableUp(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid, prev: null };
        }
        let nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        }
        return { grid: currGrid, prev };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxHierarchicalGridNavigationService, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxHierarchicalGridNavigationService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxHierarchicalGridNavigationService, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGllcmFyY2hpY2FsLWdyaWQtbmF2aWdhdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL2hpZXJhcmNoaWNhbC1ncmlkL2hpZXJhcmNoaWNhbC1ncmlkLW5hdmlnYXRpb24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2QyxPQUFPLEVBQUUsZUFBZSxFQUFFLGNBQWMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRW5FLE9BQU8sRUFBZSx3QkFBd0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDOztBQUduRixNQUFNLE9BQU8sb0NBQXFDLFNBQVEsd0JBQXdCO0lBRGxGOztRQUVjLHVCQUFrQixHQUFHLEtBQUssQ0FBQztLQXdZeEM7SUFyWW1CLGFBQWEsQ0FBQyxLQUFvQjtRQUM5QyxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMvRixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFO1lBQ2xGLE9BQU87U0FDVjtRQUVELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLHVCQUF1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LENBQUMsY0FBYyxLQUFLLENBQUMsQ0FBQztTQUN6RTtRQUNELE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDO0lBQ3BDLENBQUM7OEdBeFlRLG9DQUFvQztrSEFBcEMsb0NBQW9DOzsyRkFBcEMsb0NBQW9DO2tCQURoRCxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBOQVZJR0FUSU9OX0tFWVMsIFNVUFBPUlRFRF9LRVlTIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBHcmlkVHlwZSwgSVBhdGhTZWdtZW50LCBSb3dUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElBY3RpdmVOb2RlLCBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi9ncmlkLW5hdmlnYXRpb24uc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBJZ3hIaWVyYXJjaGljYWxHcmlkTmF2aWdhdGlvblNlcnZpY2UgZXh0ZW5kcyBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2Uge1xuICAgIHByb3RlY3RlZCBfcGVuZGluZ05hdmlnYXRpb24gPSBmYWxzZTtcblxuXG4gICAgcHVibGljIG92ZXJyaWRlIGRpc3BhdGNoRXZlbnQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVOb2RlIHx8ICEoU1VQUE9SVEVEX0tFWVMuaGFzKGtleSkgfHwgKGtleSA9PT0gJ3RhYicgJiYgdGhpcy5ncmlkLmNydWRTZXJ2aWNlLmNlbGwpKSAmJlxuICAgICAgICAgICAgIXRoaXMuZ3JpZC5jcnVkU2VydmljZS5yb3dFZGl0aW5nQmxvY2tlZCAmJiAhdGhpcy5ncmlkLmNydWRTZXJ2aWNlLnJvd0luRWRpdE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldEdyaWQgPSB0aGlzLmdldENsb3Nlc3RFbGVtQnlUYWcoZXZlbnQudGFyZ2V0LCAnaWd4LWhpZXJhcmNoaWNhbC1ncmlkJyk7XG4gICAgICAgIGlmICh0YXJnZXRHcmlkICE9PSB0aGlzLmdyaWQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uICYmIE5BVklHQVRJT05fS0VZUy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBmb2N1cyBuZWVkcyB0byBiZSBtb3ZlZCBmcm9tIG9uZSBncmlkIHRvIGFub3RoZXIsIGhvd2V2ZXIgdGhlcmUgaXMgYSBwZW5kaW5nIHNjcm9sbCBvcGVyYXRpb25cbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGFuIGFzeW5jIG9wZXJhdGlvbiwgYW55IGFkZGl0aW9uYWwgbmF2aWdhdGlvbiBrZXlzIHNob3VsZCBiZSBpZ25vcmVkXG4gICAgICAgICAgICAvLyB1bnRpbGwgb3BlcmF0aW9uIGNvbXBsZXRlLlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbmF2aWdhdGVJbkJvZHkocm93SW5kZXgsIHZpc2libGVDb2xJbmRleCwgY2I6IChhcmc6IGFueSkgPT4gdm9pZCA9IG51bGwpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcmVjID0gdGhpcy5ncmlkLmRhdGFWaWV3W3Jvd0luZGV4XTtcbiAgICAgICAgaWYgKHJlYyAmJiB0aGlzLmdyaWQuaXNDaGlsZEdyaWRSZWNvcmQocmVjKSkge1xuICAgICAgICAgICAgIC8vIHRhcmdldCBpcyBjaGlsZCBncmlkXG4gICAgICAgICAgICBjb25zdCB2aXJ0U3RhdGUgPSB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuc3RhdGU7XG4gICAgICAgICAgICAgY29uc3QgaW5WaWV3ID0gcm93SW5kZXggPj0gdmlydFN0YXRlLnN0YXJ0SW5kZXggJiYgcm93SW5kZXggPD0gdmlydFN0YXRlLnN0YXJ0SW5kZXggKyB2aXJ0U3RhdGUuY2h1bmtTaXplO1xuICAgICAgICAgICAgIGNvbnN0IGlzTmV4dCA9ICB0aGlzLmFjdGl2ZU5vZGUucm93IDwgcm93SW5kZXg7XG4gICAgICAgICAgICAgY29uc3QgdGFyZ2V0TGF5b3V0SW5kZXggPSBpc05leHQgPyBudWxsIDogdGhpcy5ncmlkLmNoaWxkTGF5b3V0S2V5cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgIGlmIChpblZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlVG9DaGlsZChyb3dJbmRleCwgdmlzaWJsZUNvbEluZGV4LCBpc05leHQsIHRhcmdldExheW91dEluZGV4LCBjYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzY3JvbGxBbW91bnQgPSB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsRm9ySW5kZXgocm93SW5kZXgsICFpc05leHQpO1xuICAgICAgICAgICAgICAgIHNjcm9sbEFtb3VudCArPSBpc05leHQgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbCgpLnNjcm9sbFRvcCA9IHNjcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmNodW5rTG9hZC5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdmVUb0NoaWxkKHJvd0luZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGlzTmV4dCwgdGFyZ2V0TGF5b3V0SW5kZXgsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzTGFzdCA9IHJvd0luZGV4ID09PSB0aGlzLmdyaWQuZGF0YVZpZXcubGVuZ3RoO1xuICAgICAgICBpZiAoKHJvd0luZGV4ID09PSAtMSB8fCBpc0xhc3QpICYmXG4gICAgICAgICAgICB0aGlzLmdyaWQucGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyByZWFjaGVkIGVuZCBvZiBjaGlsZCBncmlkXG4gICAgICAgICAgICBjb25zdCBuZXh0U2libGluZ0luZGV4ID0gdGhpcy5uZXh0U2libGluZ0luZGV4KGlzTGFzdCk7XG4gICAgICAgICAgICBpZiAobmV4dFNpYmxpbmdJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5wYXJlbnQubmF2aWdhdGlvbi5fbW92ZVRvQ2hpbGQodGhpcy5ncmlkLmNoaWxkUm93LmluZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGlzTGFzdCwgbmV4dFNpYmxpbmdJbmRleCwgY2IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlVG9QYXJlbnQoaXNMYXN0LCB2aXNpYmxlQ29sSW5kZXgsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdyaWQucGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpc05leHQgPSB0aGlzLmFjdGl2ZU5vZGUgJiYgdHlwZW9mIHRoaXMuYWN0aXZlTm9kZS5yb3cgPT09ICdudW1iZXInID8gcm93SW5kZXggPiB0aGlzLmFjdGl2ZU5vZGUucm93IDogZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjYkhhbmRsZXIgPSAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVNjcm9sbEluQ2hpbGQocm93SW5kZXgsIGlzTmV4dCk7XG4gICAgICAgICAgICAgICAgY2IoYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZU5vZGUgPSB7IHJvdzogbnVsbCwgY29sdW1uOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXBlci5uYXZpZ2F0ZUluQm9keShyb3dJbmRleCwgdmlzaWJsZUNvbEluZGV4LCBjYkhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZSA9IHsgcm93OiBudWxsLCBjb2x1bW46IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uYXZpZ2F0ZUluQm9keShyb3dJbmRleCwgdmlzaWJsZUNvbEluZGV4LCBjYik7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHNob3VsZFBlcmZvcm1WZXJ0aWNhbFNjcm9sbChpbmRleCwgdmlzaWJsZUNvbHVtbkluZGV4ID0gLTEsIGlzTmV4dD8pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0UmVjID0gdGhpcy5ncmlkLmRhdGFWaWV3W2luZGV4XTtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc0NoaWxkR3JpZFJlY29yZCh0YXJnZXRSZWMpKSB7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxBbW91bnQgPSB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsRm9ySW5kZXgoaW5kZXgsICFpc05leHQpO1xuICAgICAgICAgICAgY29uc3QgY3VyclNjcm9sbCA9IHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGwoKS5zY3JvbGxUb3A7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSAhaXNOZXh0ID8gc2Nyb2xsQW1vdW50ID4gY3VyclNjcm9sbCA6IGN1cnJTY3JvbGwgPCBzY3JvbGxBbW91bnQ7XG4gICAgICAgICAgICByZXR1cm4gc2hvdWxkU2Nyb2xsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnNob3VsZFBlcmZvcm1WZXJ0aWNhbFNjcm9sbChpbmRleCwgdmlzaWJsZUNvbHVtbkluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBmb2N1c1Rib2R5KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVOb2RlIHx8IHRoaXMuYWN0aXZlTm9kZS5yb3cgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZSA9IHtcbiAgICAgICAgICAgICAgICByb3c6IDAsXG4gICAgICAgICAgICAgICAgY29sdW1uOiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmdyaWQubmF2aWdhdGVUbygwLCAwLCAob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLmNsZWFyQ2VsbFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIG9iai50YXJnZXQuYWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmZvY3VzVGJvZHkoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG5leHRTaWJsaW5nSW5kZXgoaXNOZXh0KSB7XG4gICAgICAgIGNvbnN0IGxheW91dEtleSA9IHRoaXMuZ3JpZC5jaGlsZFJvdy5sYXlvdXQua2V5O1xuICAgICAgICBjb25zdCBsYXlvdXRJbmRleCA9IHRoaXMuZ3JpZC5wYXJlbnQuY2hpbGRMYXlvdXRLZXlzLmluZGV4T2YobGF5b3V0S2V5KTtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gaXNOZXh0ID8gbGF5b3V0SW5kZXggKyAxIDogbGF5b3V0SW5kZXggLSAxO1xuICAgICAgICBpZiAobmV4dEluZGV4IDw9IHRoaXMuZ3JpZC5wYXJlbnQuY2hpbGRMYXlvdXRLZXlzLmxlbmd0aCAtIDEgJiYgbmV4dEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2Nyb2xsaW5nIGluIGNoaWxkIGdyaWQgYW5kIGVuc3VyZXMgdGFyZ2V0IGNoaWxkIHJvdyBpcyBpbiBtYWluIGdyaWQgdmlldyBwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvd0luZGV4IFRoZSByb3cgaW5kZXggd2hpY2ggc2hvdWxkIGJlIGluIHZpZXcuXG4gICAgICogQHBhcmFtIGlzTmV4dCAgT3B0aW9uYWwuIFdoZXRoZXIgd2UgYXJlIG5hdmlnYXRpbmcgdG8gbmV4dC4gVXNlZCB0byBkZXRlcm1pbmUgc2Nyb2xsIGRpcmVjdGlvbi5cbiAgICAgKiBAcGFyYW0gY2IgIE9wdGlvbmFsLkNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2hhbmRsZVNjcm9sbEluQ2hpbGQocm93SW5kZXg6IG51bWJlciwgaXNOZXh0PzogYm9vbGVhbiwgY2I/OiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IHRoaXMuc2hvdWxkUGVyZm9ybVZlcnRpY2FsU2Nyb2xsKHJvd0luZGV4LCAtMSwgaXNOZXh0KTtcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLm5hdmlnYXRpb24ucGVyZm9ybVZlcnRpY2FsU2Nyb2xsVG9DZWxsKHJvd0luZGV4LCAtMSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25JblBhcmVudChyb3dJbmRleCwgaXNOZXh0LCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25JblBhcmVudChyb3dJbmRleCwgaXNOZXh0LCBjYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3dJbmRleCBSb3cgaW5kZXggdGhhdCBzaG91bGQgY29tZSBpbiB2aWV3LlxuICAgICAqIEBwYXJhbSBpc05leHQgIFdoZXRoZXIgd2UgYXJlIG5hdmlnYXRpbmcgdG8gbmV4dC4gVXNlZCB0byBkZXRlcm1pbmUgc2Nyb2xsIGRpcmVjdGlvbi5cbiAgICAgKiBAcGFyYW0gY2IgIE9wdGlvbmFsLkNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcG9zaXRpb25JblBhcmVudChyb3dJbmRleCwgaXNOZXh0LCBjYj86ICgpID0+IHZvaWQpIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5ncmlkLmdyaWRBUEkuZ2V0X3Jvd19ieV9pbmRleChyb3dJbmRleCk7XG4gICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uSW5mbyA9IHRoaXMuZ2V0UG9zaXRpb25JbmZvKHJvdywgaXNOZXh0KTtcbiAgICAgICAgaWYgKCFwb3NpdGlvbkluZm8uaW5WaWV3KSB7XG4gICAgICAgICAgICAvLyBzdG9wIGV2ZW50IGZyb20gdHJpZ2dlcmluZyBtdWx0aXBsZSB0aW1lcyBiZWZvcmUgc2Nyb2xsaW5nIGlzIGNvbXBsZXRlLlxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZUdyaWQgPSBpc05leHQgPyB0aGlzLmdldE5leHRTY3JvbGxhYmxlRG93bih0aGlzLmdyaWQpIDogdGhpcy5nZXROZXh0U2Nyb2xsYWJsZVVwKHRoaXMuZ3JpZCk7XG4gICAgICAgICAgICBzY3JvbGxhYmxlR3JpZC5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnJlY2FsY1VwZGF0ZVNpemVzKCk7XG4gICAgICAgICAgICBzY3JvbGxhYmxlR3JpZC5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmFkZFNjcm9sbFRvcChwb3NpdGlvbkluZm8ub2Zmc2V0KTtcbiAgICAgICAgICAgIHNjcm9sbGFibGVHcmlkLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuY2h1bmtMb2FkLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIG5hdmlnYXRpb24gdG8gY2hpbGQgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJlbnRSb3dJbmRleCBUaGUgcGFyZW50IHJvdyBpbmRleCwgYXQgd2hpY2ggdGhlIGNoaWxkIGdyaWQgaXMgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIGNoaWxkTGF5b3V0SW5kZXggT3B0aW9uYWwuIFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgcm93IGlzbGFuZCB0byB3aGljaCB0aGUgY2hpbGQgZ3JpZCBiZWxvbmdzIHRvLiBVc2VzIGZpcnN0IGlmIG5vdCBzZXQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9tb3ZlVG9DaGlsZChwYXJlbnRSb3dJbmRleDogbnVtYmVyLCB2aXNpYmxlQ29sSW5kZXg6IG51bWJlciwgaXNOZXh0OiBib29sZWFuLCBjaGlsZExheW91dEluZGV4PzogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiPzogKGFyZzogYW55KSA9PiB2b2lkKSB7XG4gICAgICAgIGNvbnN0IHJpID0gdHlwZW9mIGNoaWxkTGF5b3V0SW5kZXggIT09ICdudW1iZXInID9cbiAgICAgICAgIHRoaXMuZ3JpZC5jaGlsZExheW91dExpc3QuZmlyc3QgOiB0aGlzLmdyaWQuY2hpbGRMYXlvdXRMaXN0LnRvQXJyYXkoKVtjaGlsZExheW91dEluZGV4XTtcbiAgICAgICAgY29uc3Qgcm93SWQgPSB0aGlzLmdyaWQuZGF0YVZpZXdbcGFyZW50Um93SW5kZXhdLnJvd0lEO1xuICAgICAgICBjb25zdCBwYXRoU2VnbWVudDogSVBhdGhTZWdtZW50ID0ge1xuICAgICAgICAgICAgcm93SUQ6IHJvd0lkLFxuICAgICAgICAgICAgcm93S2V5OiByb3dJZCxcbiAgICAgICAgICAgIHJvd0lzbGFuZEtleTogcmkua2V5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoaWxkR3JpZCA9ICB0aGlzLmdyaWQuZ3JpZEFQSS5nZXRDaGlsZEdyaWQoW3BhdGhTZWdtZW50XSk7XG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gaXNOZXh0ID8gMCA6IGNoaWxkR3JpZC5kYXRhVmlldy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCB0YXJnZXRSZWMgPSAgY2hpbGRHcmlkLmRhdGFWaWV3W3RhcmdldEluZGV4XTtcbiAgICAgICAgaWYgKCF0YXJnZXRSZWMpIHtcbiAgICAgICAgICAgIC8vIGlmIG5vIHRhcmdldCByZWMsIHRoZW4gbW92ZSBvbiBpbiBuZXh0IHNpYmxpbmcgb3IgcGFyZW50XG4gICAgICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGlvbi5uYXZpZ2F0ZUluQm9keSh0YXJnZXRJbmRleCwgdmlzaWJsZUNvbEluZGV4LCBjYik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkR3JpZC5pc0NoaWxkR3JpZFJlY29yZCh0YXJnZXRSZWMpKSB7XG4gICAgICAgICAgICAvLyBpZiB0YXJnZXQgaXMgYSBjaGlsZCBncmlkIHJlY29yZCBzaG91bGQgbW92ZSBpbnRvIGl0LlxuICAgICAgICAgICAgdGhpcy5ncmlkLm5hdmlnYXRpb24uYWN0aXZlTm9kZS5yb3cgPSBudWxsO1xuICAgICAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRpb24uYWN0aXZlTm9kZSA9IHsgcm93OiB0YXJnZXRJbmRleCwgY29sdW1uOiB0aGlzLmFjdGl2ZU5vZGUuY29sdW1ufTtcbiAgICAgICAgICAgIGNoaWxkR3JpZC5uYXZpZ2F0aW9uLl9oYW5kbGVTY3JvbGxJbkNoaWxkKHRhcmdldEluZGV4LCBpc05leHQsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRMYXlvdXRJbmRleCA9IGlzTmV4dCA/IDAgOiBjaGlsZEdyaWQuY2hpbGRMYXlvdXRMaXN0LnRvQXJyYXkoKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNoaWxkR3JpZC5uYXZpZ2F0aW9uLl9tb3ZlVG9DaGlsZCh0YXJnZXRJbmRleCwgdmlzaWJsZUNvbEluZGV4LCBpc05leHQsIHRhcmdldExheW91dEluZGV4LCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkR3JpZE5hdiA9ICBjaGlsZEdyaWQubmF2aWdhdGlvbjtcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2YXRpb24oKTtcbiAgICAgICAgY29uc3QgbGFzdFZpc2libGVJbmRleCA9IGNoaWxkR3JpZE5hdi5sYXN0Q29sdW1uSW5kZXg7XG4gICAgICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gdmlzaWJsZUNvbEluZGV4IDw9IGxhc3RWaXNpYmxlSW5kZXggPyB2aXNpYmxlQ29sSW5kZXggOiBsYXN0VmlzaWJsZUluZGV4O1xuICAgICAgICBjaGlsZEdyaWROYXYuYWN0aXZlTm9kZSA9IHsgcm93OiB0YXJnZXRJbmRleCwgY29sdW1uOiBjb2x1bW5JbmRleH07XG4gICAgICAgIGNoaWxkR3JpZC50Ym9keS5uYXRpdmVFbGVtZW50LmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIGNoaWxkR3JpZC5uYXZpZ2F0aW9uLl9oYW5kbGVTY3JvbGxJbkNoaWxkKHRhcmdldEluZGV4LCBpc05leHQsICgpID0+IHtcbiAgICAgICAgICAgIGNoaWxkR3JpZC5uYXZpZ2F0ZVRvKHRhcmdldEluZGV4LCBjb2x1bW5JbmRleCwgY2IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBuYXZpZ2F0aW9uIGJhY2sgdG8gcGFyZW50IGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93SW5kZXhcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX21vdmVUb1BhcmVudChpc05leHQ6IGJvb2xlYW4sIGNvbHVtbkluZGV4LCBjYj8pIHtcbiAgICAgICAgY29uc3QgaW5kZXhJblBhcmVudCA9IHRoaXMuZ3JpZC5jaGlsZFJvdy5pbmRleDtcbiAgICAgICAgY29uc3QgaGFzTmV4dFRhcmdldCA9IHRoaXMuaGFzTmV4dFRhcmdldCh0aGlzLmdyaWQucGFyZW50LCBpbmRleEluUGFyZW50LCBpc05leHQpO1xuICAgICAgICBpZiAoIWhhc05leHRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZhdGlvbigpO1xuICAgICAgICBjb25zdCB0YXJnZXRSb3dJbmRleCA9ICBpc05leHQgPyBpbmRleEluUGFyZW50ICsgMSA6IGluZGV4SW5QYXJlbnQgLSAxO1xuICAgICAgICBjb25zdCBsYXN0VmlzaWJsZUluZGV4ID0gdGhpcy5ncmlkLnBhcmVudC5uYXZpZ2F0aW9uLmxhc3RDb2x1bW5JbmRleDtcbiAgICAgICAgY29uc3QgbmV4dENvbHVtbkluZGV4ID0gY29sdW1uSW5kZXggPD0gbGFzdFZpc2libGVJbmRleCA/IGNvbHVtbkluZGV4IDogbGFzdFZpc2libGVJbmRleDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSB0cnVlO1xuICAgICAgICBjb25zdCBjYkZ1bmMgPSAoYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGNiKGFyZ3MpO1xuICAgICAgICAgICAgYXJncy50YXJnZXQuZ3JpZC50Ym9keS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ3JpZC5wYXJlbnQubmF2aWdhdGlvbi5uYXZpZ2F0ZUluQm9keSh0YXJnZXRSb3dJbmRleCwgbmV4dENvbHVtbkluZGV4LCBjYkZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaW5mb3JtYXRpb24gb24gdGhlIHJvdyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcm9vdCBncmlkIHZpZXcgcG9ydC5cbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJvdyBpcyBpbiB2aWV3IGFuZCBpdHMgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvd09ialxuICAgICAqIEBwYXJhbSBpc05leHRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0UG9zaXRpb25JbmZvKHJvdzogUm93VHlwZSwgaXNOZXh0OiBib29sZWFuKSB7XG4gICAgICAgIC8vIFhYWDogRml4IHR5cGVcbiAgICAgICAgbGV0IHJvd0VsZW0gPSByb3cubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKChyb3cgYXMgYW55KS5sYXlvdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTGF5b3V0S2V5cyA9IHRoaXMuZ3JpZC5jaGlsZExheW91dEtleXM7XG4gICAgICAgICAgICBjb25zdCByaUtleSA9IGlzTmV4dCA/IGNoaWxkTGF5b3V0S2V5c1swXSA6IGNoaWxkTGF5b3V0S2V5c1tjaGlsZExheW91dEtleXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBwYXRoU2VnbWVudDogSVBhdGhTZWdtZW50ID0ge1xuICAgICAgICAgICAgICAgIHJvd0lEOiByb3cuZGF0YS5yb3dJRCwgcm93S2V5OiByb3cuZGF0YS5yb3dJRCxcbiAgICAgICAgICAgICAgICByb3dJc2xhbmRLZXk6IHJpS2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2hpbGRHcmlkID0gIHRoaXMuZ3JpZC5ncmlkQVBJLmdldENoaWxkR3JpZChbcGF0aFNlZ21lbnRdKTtcbiAgICAgICAgICAgIHJvd0VsZW0gPSBjaGlsZEdyaWQudGZvb3QubmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncmlkQm90dG9tID0gdGhpcy5fZ2V0TWluQm90dG9tKHRoaXMuZ3JpZCk7XG4gICAgICAgIGNvbnN0IGRpZmZCb3R0b20gPVxuICAgICAgICByb3dFbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIGdyaWRCb3R0b207XG4gICAgICAgIGNvbnN0IGdyaWRUb3AgPSB0aGlzLl9nZXRNYXhUb3AodGhpcy5ncmlkKTtcbiAgICAgICAgY29uc3QgZGlmZlRvcCA9IHJvd0VsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC1cbiAgICAgICAgcm93RWxlbS5vZmZzZXRIZWlnaHQgLSBncmlkVG9wO1xuICAgICAgICAvLyBBZGRpbmcgTWF0aC5Sb3VuZCBiZWNhdXNlIENocm9tZSBoYXMgc29tZSBpbmNvbnNpc3RlbmNpZXMgd2hlbiB0aGUgcGFnZSBpcyB6b29tZWRcbiAgICAgICAgY29uc3QgaXNJblZpZXcgPSBpc05leHQgPyBNYXRoLnJvdW5kKGRpZmZCb3R0b20pIDw9IDAgOiBNYXRoLnJvdW5kKGRpZmZUb3ApID49IDA7XG4gICAgICAgIGNvbnN0IGNhbGNPZmZzZXQgPSAgaXNOZXh0ID8gZGlmZkJvdHRvbSA6IGRpZmZUb3A7XG5cbiAgICAgICAgcmV0dXJuIHsgaW5WaWV3OiBpc0luVmlldywgb2Zmc2V0OiBjYWxjT2Zmc2V0IH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjbG9zZXN0IGVsZW1lbnQgYnkgaXRzIHRhZyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZUVsZW0gVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBzdGFydCB0aGUgc2VhcmNoLlxuICAgICAqIEBwYXJhbSB0YXJnZXRUYWcgVGhlIHRhcmdldCBlbGVtZW50IHRhZyBuYW1lLCBmb3Igd2hpY2ggdG8gc2VhcmNoLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRDbG9zZXN0RWxlbUJ5VGFnKHNvdXJjZUVsZW0sIHRhcmdldFRhZykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc291cmNlRWxlbTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YXJnZXRUYWcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyQWN0aXZhdGlvbigpIHtcbiAgICAgICAgLy8gY2xlYXIgaWYgcHJldmlvdXMgYWN0aXZhdGlvbiBleGlzdHMuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZU5vZGUgJiYgT2JqZWN0LmtleXModGhpcy5hY3RpdmVOb2RlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZSA9IE9iamVjdC5hc3NpZ24oe30gYXMgSUFjdGl2ZU5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYXNOZXh0VGFyZ2V0KGdyaWQ6IEdyaWRUeXBlLCBpbmRleDogbnVtYmVyLCBpc05leHQ6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Um93SW5kZXggPSAgaXNOZXh0ID8gaW5kZXggKyAxIDogaW5kZXggLSAxO1xuICAgICAgICBjb25zdCBoYXNUYXJnZXRSZWNvcmQgPSAhIWdyaWQuZGF0YVZpZXdbdGFyZ2V0Um93SW5kZXhdO1xuICAgICAgICBpZiAoaGFzVGFyZ2V0UmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBoYXNUYXJnZXRSZWNvcmRJblBhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGdyaWQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhJblBhcmVudCA9IGdyaWQuY2hpbGRSb3cuaW5kZXg7XG4gICAgICAgICAgICAgICAgaGFzVGFyZ2V0UmVjb3JkSW5QYXJlbnQgPSB0aGlzLmhhc05leHRUYXJnZXQoZ3JpZC5wYXJlbnQsIGluZGV4SW5QYXJlbnQsIGlzTmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFzVGFyZ2V0UmVjb3JkSW5QYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXggdG9wIHZpZXcgaW4gdGhlIGN1cnJlbnQgZ3JpZCBoaWVyYXJjaHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JpZFxuICAgICAqL1xuICAgIHByaXZhdGUgX2dldE1heFRvcChncmlkKSB7XG4gICAgICAgIGxldCBjdXJyR3JpZCA9IGdyaWQ7XG4gICAgICAgIGxldCB0b3AgPSBjdXJyR3JpZC50Ym9keS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgd2hpbGUgKGN1cnJHcmlkLnBhcmVudCkge1xuICAgICAgICAgICAgY3VyckdyaWQgPSBjdXJyR3JpZC5wYXJlbnQ7XG4gICAgICAgICAgICBjb25zdCBwaW5uZWRSb3dzSGVpZ2h0ID0gY3VyckdyaWQuaGFzUGlubmVkUmVjb3JkcyAmJiBjdXJyR3JpZC5pc1Jvd1Bpbm5pbmdUb1RvcCA/IGN1cnJHcmlkLnBpbm5lZFJvd0hlaWdodCA6IDA7XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIGN1cnJHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgcGlubmVkUm93c0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtaW4gYm90dG9tIHZpZXcgaW4gdGhlIGN1cnJlbnQgZ3JpZCBoaWVyYXJjaHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JpZFxuICAgICAqL1xuICAgIHByaXZhdGUgX2dldE1pbkJvdHRvbShncmlkKSB7XG4gICAgICAgIGxldCBjdXJyR3JpZCA9IGdyaWQ7XG4gICAgICAgIGxldCBib3R0b20gPSBjdXJyR3JpZC50Ym9keS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbTtcbiAgICAgICAgd2hpbGUgKGN1cnJHcmlkLnBhcmVudCkge1xuICAgICAgICAgICAgY3VyckdyaWQgPSBjdXJyR3JpZC5wYXJlbnQ7XG4gICAgICAgICAgICBjb25zdCBwaW5uZWRSb3dzSGVpZ2h0ID0gY3VyckdyaWQuaGFzUGlubmVkUmVjb3JkcyAmJiAhY3VyckdyaWQuaXNSb3dQaW5uaW5nVG9Ub3AgPyBjdXJyR3JpZC5waW5uZWRSb3dIZWlnaHQgOiAwO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCBjdXJyR3JpZC50Ym9keS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIHBpbm5lZFJvd3NIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3R0b207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG5leHQgZ3JpZCB0aGF0IGFsbG93cyBzY3JvbGxpbmcgZG93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkIFRoZSBncmlkIGZyb20gd2hpY2ggdG8gYmVnaW4gdGhlIHNlYXJjaC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldE5leHRTY3JvbGxhYmxlRG93bihncmlkKSB7XG4gICAgICAgIGxldCBjdXJyR3JpZCA9IGdyaWQucGFyZW50O1xuICAgICAgICBpZiAoIWN1cnJHcmlkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBncmlkLCBwcmV2OiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFBvc2l0aW9uO1xuICAgICAgICBsZXQgc2Nyb2xsSGVpZ2h0ID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsKCkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICBsZXQgbm9uU2Nyb2xsYWJsZSA9IHNjcm9sbEhlaWdodCA9PT0gMCB8fFxuICAgICAgICAgICAgTWF0aC5yb3VuZChzY3JvbGxUb3AgKyBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5pZ3hGb3JDb250YWluZXJTaXplKSA9PT0gc2Nyb2xsSGVpZ2h0O1xuICAgICAgICBsZXQgcHJldiA9IGdyaWQ7XG4gICAgICAgIHdoaWxlIChub25TY3JvbGxhYmxlICYmIGN1cnJHcmlkLnBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJldiA9IGN1cnJHcmlkO1xuICAgICAgICAgICAgY3VyckdyaWQgPSBjdXJyR3JpZC5wYXJlbnQ7XG4gICAgICAgICAgICBzY3JvbGxUb3AgPSBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5zY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbCgpLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIG5vblNjcm9sbGFibGUgPSBzY3JvbGxIZWlnaHQgPT09IDAgfHxcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHNjcm9sbFRvcCArIGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmlneEZvckNvbnRhaW5lclNpemUpID09PSBzY3JvbGxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZ3JpZDogY3VyckdyaWQsIHByZXYgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmV4dCBncmlkIHRoYXQgYWxsb3dzIHNjcm9sbGluZyB1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkIFRoZSBncmlkIGZyb20gd2hpY2ggdG8gYmVnaW4gdGhlIHNlYXJjaC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldE5leHRTY3JvbGxhYmxlVXAoZ3JpZCkge1xuICAgICAgICBsZXQgY3VyckdyaWQgPSBncmlkLnBhcmVudDtcbiAgICAgICAgaWYgKCFjdXJyR3JpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZ3JpZCwgcHJldjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBub25TY3JvbGxhYmxlID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuc2Nyb2xsUG9zaXRpb24gPT09IDA7XG4gICAgICAgIGxldCBwcmV2ID0gZ3JpZDtcbiAgICAgICAgd2hpbGUgKG5vblNjcm9sbGFibGUgJiYgY3VyckdyaWQucGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2ID0gY3VyckdyaWQ7XG4gICAgICAgICAgICBjdXJyR3JpZCA9IGN1cnJHcmlkLnBhcmVudDtcbiAgICAgICAgICAgIG5vblNjcm9sbGFibGUgPSBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5zY3JvbGxQb3NpdGlvbiA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBncmlkOiBjdXJyR3JpZCwgcHJldiB9O1xuICAgIH1cbn1cbiJdfQ==