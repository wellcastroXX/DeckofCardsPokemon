import { cloneArray, parseDate, resolveNestedPath } from '../../core/utils';
import { getHierarchy, isHierarchyMatch } from '../../data-operations/operations';
import { DefaultSortingStrategy } from '../../data-operations/sorting-strategy';
const DATE_TYPE = 'date';
const TIME_TYPE = 'time';
const DATE_TIME_TYPE = 'dateTime';
const STRING_TYPE = 'string';
/**
 * Represents a class implementing the IGridSortingStrategy interface.
 * It provides sorting functionality for grid data based on sorting expressions.
 */
export class IgxSorting {
    /**
   * Sorts the provided data based on the given sorting expressions.
   * `data`: The array of data to be sorted.
   * `expressions`: An array of sorting expressions that define the sorting rules. The expression contains information like file name, whether the letter case should be taken into account, etc.
   * `grid`: (Optional) The instance of the grid where the sorting is applied.
   * Returns a new array with the data sorted according to the sorting expressions.
   */
    sort(data, expressions, grid) {
        return this.sortDataRecursive(data, expressions, 0, grid);
    }
    /**
   * Recursively groups the provided data based on the given grouping state and returns the grouped result.
   * Returns an array containing the grouped result.
   * @internal
   */
    groupDataRecursive(data, state, level, parent, metadata, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        const expressions = state.expressions;
        const expansion = state.expansion;
        let i = 0;
        let result = [];
        while (i < data.length) {
            const column = grid ? grid.getColumnByName(expressions[level].fieldName) : null;
            const isDate = column?.dataType === DATE_TYPE || column?.dataType === DATE_TIME_TYPE;
            const isTime = column?.dataType === TIME_TYPE || column?.dataType === DATE_TIME_TYPE;
            const isString = column?.dataType === STRING_TYPE;
            const group = this.groupedRecordsByExpression(data, i, expressions[level], isDate, isTime, isString);
            const groupRow = {
                expression: expressions[level],
                level,
                records: cloneArray(group),
                value: this.getFieldValue(group[0], expressions[level].fieldName, isDate, isTime),
                groupParent: parent,
                groups: [],
                height: grid ? grid.renderedRowHeight : null,
                column
            };
            if (parent) {
                parent.groups.push(groupRow);
            }
            else {
                groupsRecords.push(groupRow);
            }
            const hierarchy = getHierarchy(groupRow);
            const expandState = expansion.find((s) => isHierarchyMatch(s.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy, expressions));
            const expanded = expandState ? expandState.expanded : state.defaultExpanded;
            let recursiveResult;
            result.push(groupRow);
            metadata.push(null);
            fullResult.data.push(groupRow);
            fullResult.metadata.push(null);
            if (level < expressions.length - 1) {
                recursiveResult = this.groupDataRecursive(group, state, level + 1, groupRow, expanded ? metadata : [], grid, groupsRecords, fullResult);
                if (expanded) {
                    result = result.concat(recursiveResult);
                }
            }
            else {
                for (const groupItem of group) {
                    fullResult.metadata.push(groupRow);
                    fullResult.data.push(groupItem);
                }
                if (expanded) {
                    metadata.push(...fullResult.metadata.slice(fullResult.metadata.length - group.length));
                    result.push(...fullResult.data.slice(fullResult.data.length - group.length));
                }
            }
            i += group.length;
        }
        return result;
    }
    /**
   * Retrieves the value of the specified field from the given object, considering date and time data types.
   * `key`: The key of the field to retrieve.
   * `isDate`: (Optional) Indicates if the field is of type Date.
   * `isTime`: (Optional) Indicates if the field is of type Time.
   * Returns the value of the specified field in the data object.
   * @internal
   */
    getFieldValue(obj, key, isDate = false, isTime = false) {
        let resolvedValue = resolveNestedPath(obj, key);
        const date = parseDate(resolvedValue);
        if (date && isDate && isTime) {
            resolvedValue = date;
        }
        else if (date && isDate && !isTime) {
            resolvedValue = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
        }
        else if (date && isTime && !isDate) {
            resolvedValue = new Date(new Date().setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
        }
        return resolvedValue;
    }
    /**
   * Groups the records in the provided data array based on the given grouping expression.
   * `groupingComparer`: (Optional) A custom grouping comparator to determine the members of the group.
   * Returns an array containing the records that belong to the group.
   * @internal
   */
    groupedRecordsByExpression(data, index, expression, isDate = false, isTime = false, isString, groupingComparer) {
        const res = [];
        const key = expression.fieldName;
        const len = data.length;
        const groupRecord = data[index];
        let groupval = this.getFieldValue(groupRecord, key, isDate, isTime);
        res.push(groupRecord);
        index++;
        const comparer = expression.groupingComparer || groupingComparer || DefaultSortingStrategy.instance().compareValues;
        for (let i = index; i < len; i++) {
            const currRec = data[i];
            let fieldValue = this.getFieldValue(currRec, key, isDate, isTime);
            if (expression.ignoreCase && isString) {
                // when column's dataType is string but the value is number
                fieldValue = fieldValue?.toString().toLowerCase();
                groupval = groupval?.toString().toLowerCase();
            }
            if (comparer(fieldValue, groupval, currRec, groupRecord) === 0) {
                res.push(currRec);
            }
            else {
                break;
            }
        }
        return res;
    }
    /**
   * Sorts the provided data array based on the given sorting expressions.
   * The method can be used when multiple sorting is performed, going through each one
   * Returns a new array with the data sorted according to the sorting expressions.
   * @internal
   */
    sortDataRecursive(data, expressions, expressionIndex = 0, grid) {
        let i;
        let j;
        let gbData;
        let gbDataLen;
        const exprsLen = expressions.length;
        const dataLen = data.length;
        expressionIndex = expressionIndex || 0;
        if (expressionIndex >= exprsLen || dataLen <= 1) {
            return data;
        }
        const expr = expressions[expressionIndex];
        if (!expr.strategy) {
            expr.strategy = DefaultSortingStrategy.instance();
        }
        const column = grid?.getColumnByName(expr.fieldName);
        const isDate = column?.dataType === DATE_TYPE || column?.dataType === DATE_TIME_TYPE;
        const isTime = column?.dataType === TIME_TYPE || column?.dataType === DATE_TIME_TYPE;
        const isString = column?.dataType === STRING_TYPE;
        data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue, isDate, isTime, grid);
        if (expressionIndex === exprsLen - 1) {
            return data;
        }
        // in case of multiple sorting
        for (i = 0; i < dataLen; i++) {
            gbData = this.groupedRecordsByExpression(data, i, expr, isDate, isTime, isString, column?.groupingComparer);
            gbDataLen = gbData.length;
            if (gbDataLen > 1) {
                gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1, grid);
            }
            for (j = 0; j < gbDataLen; j++) {
                data[i + j] = gbData[j];
            }
            i += gbDataLen - 1;
        }
        return data;
    }
}
/**
 * Represents a class implementing the IGridGroupingStrategy interface and extending the IgxSorting class.
 * It provides a method to group data based on the given grouping state.
 */
export class IgxGrouping extends IgxSorting {
    /**
     * Groups the provided data based on the given grouping state.
     * Returns an object containing the result of the grouping operation.
     */
    groupBy(data, state, grid, groupsRecords, fullResult = { data: [], metadata: [] }) {
        const metadata = [];
        const grouping = this.groupDataRecursive(data, state, 0, null, metadata, grid, groupsRecords, fullResult);
        grid?.groupingPerformedSubject.next();
        return {
            data: grouping,
            metadata
        };
    }
}
/**
 * Represents a class implementing the IGridSortingStrategy interface with a no-operation sorting strategy.
 * It performs no sorting and returns the data as it is.
 */
export class NoopSortingStrategy {
    static { this._instance = null; }
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new NoopSortingStrategy());
    }
    sort(data) {
        return data;
    }
}
/**
 * Represents a class extending the IgxSorting class
 * Provids custom data record sorting.
 */
export class IgxDataRecordSorting extends IgxSorting {
    /**
    * Overrides the base method to retrieve the field value from the data object instead of the record object.
    * Returns the value of the specified field in the data object.
    */
    getFieldValue(obj, key, isDate = false, isTime = false) {
        return super.getFieldValue(obj.data, key, isDate, isTime);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyYXRlZ3kuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvY29tbW9uL3N0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFNNUUsT0FBTyxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxzQkFBc0IsRUFBc0IsTUFBTSx3Q0FBd0MsQ0FBQztBQUdwRyxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUM7QUFDekIsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDO0FBQ3pCLE1BQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQztBQUNsQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUM7QUFnQzdCOzs7R0FHRztBQUNILE1BQU0sT0FBTyxVQUFVO0lBQ25COzs7Ozs7S0FNQztJQUNNLElBQUksQ0FBQyxJQUFXLEVBQUUsV0FBaUMsRUFBRSxJQUFlO1FBQ3ZFLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRDs7OztLQUlDO0lBQ1Msa0JBQWtCLENBQ3hCLElBQVcsRUFDWCxLQUFxQixFQUNyQixLQUFhLEVBQ2IsTUFBc0IsRUFDdEIsUUFBMEIsRUFDMUIsT0FBaUIsSUFBSSxFQUNyQixnQkFBdUIsRUFBRSxFQUN6QixhQUE2QixFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRTtRQUV2RCxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO1FBQ3RDLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7UUFDbEMsSUFBSSxD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QUVyRCxnQkFBd0IsQ0FBQztJQUVsQixNQUFNLENBQUMsUUFBUTtRQUNsQixPQUFPLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksbUJBQW1CLEVBQUUsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFTSxJQUFJLENBQUMsSUFBVztRQUNuQixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDOztBQUdMOzs7R0FHRztBQUNILE1BQU0sT0FBTyxvQkFBcUIsU0FBUSxVQUFVO0lBQ2pEOzs7TUFHRTtJQUNrQixhQUFhLENBQUMsR0FBUSxFQUFFLEdBQVcsRUFBRSxNQUFNLEdBQUcsS0FBSyxFQUFFLE1BQU0sR0FBRyxLQUFLO1FBQ2xGLE9BQU8sS0FBSyxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDOUQsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2xvbmVBcnJheSwgcGFyc2VEYXRlLCByZXNvbHZlTmVzdGVkUGF0aCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSUdyb3VwQnlFeHBhbmRTdGF0ZSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGJ5LWV4cGFuZC1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZWNvcmQgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBieS1yZWNvcmQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElHcm91cGluZ1N0YXRlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwYnktc3RhdGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IElHcm91cGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZXN1bHQgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBpbmctcmVzdWx0LmludGVyZmFjZSc7XG5pbXBvcnQgeyBnZXRIaWVyYXJjaHksIGlzSGllcmFyY2h5TWF0Y2ggfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBEZWZhdWx0U29ydGluZ1N0cmF0ZWd5LCBJU29ydGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBHcmlkVHlwZSB9IGZyb20gJy4vZ3JpZC5pbnRlcmZhY2UnO1xuXG5jb25zdCBEQVRFX1RZUEUgPSAnZGF0ZSc7XG5jb25zdCBUSU1FX1RZUEUgPSAndGltZSc7XG5jb25zdCBEQVRFX1RJTUVfVFlQRSA9ICdkYXRlVGltZSc7XG5jb25zdCBTVFJJTkdfVFlQRSA9ICdzdHJpbmcnO1xuXG4vKiogXG4gKiBSZXByZXNlbnRzIGEgc29ydGluZyBzdHJhdGVneSBmb3IgdGhlIGdyaWQgZGF0YVxuICogQ29udGFpbnMgYSBzaW5nbGUgbWV0aG9kIHNvcnQgdGhhdCBzb3J0cyB0aGUgcHJvdmlkZWQgZGF0YSBiYXNlZCBvbiB0aGUgZ2l2ZW4gc29ydGluZyBleHByZXNzaW9ucyBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJR3JpZFNvcnRpbmdTdHJhdGVneSB7XG4gICAvKipcbiAgICogYGRhdGFgOiBUaGUgYXJyYXkgb2YgZGF0YSB0byBiZSBzb3J0ZWQuIENvdWxkIGJlIG9mIGFueSB0eXBlLlxuICAgKiBgZXhwcmVzc2lvbnNgOiBBbiBhcnJheSBvZiBzb3J0aW5nIGV4cHJlc3Npb25zIHRoYXQgZGVmaW5lIHRoZSBzb3J0aW5nIHJ1bGVzLiBUaGUgZXhwcmVzc2lvbiBjb250YWlucyBpbmZvcm1hdGlvbiBsaWtlIGZpbGUgbmFtZSwgd2hldGhlciB0aGUgbGV0dGVyIGNhc2Ugc2hvdWxkIGJlIHRha2VuIGludG8gYWNjb3VudCwgZXRjLlxuICAgKiBgZ3JpZGA6IChPcHRpb25hbCkgVGhlIGluc3RhbmNlIG9mIHRoZSBncmlkIHdoZXJlIHRoZSBzb3J0aW5nIGlzIGFwcGxpZWQuXG4gICAqIFJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgZGF0YSBzb3J0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzb3J0aW5nIGV4cHJlc3Npb25zLlxuICAgKi9cbiAgICBzb3J0KGRhdGE6IGFueVtdLCBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sIGdyaWQ/OiBHcmlkVHlwZSk6IGFueVtdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBncm91cGluZyBzdHJhdGVneSBmb3IgdGhlIGdyaWQgZGF0YSwgZXh0ZW5kaW5nIHRoZSBTb3J0aW5nIFN0cmF0ZWd5IGludGVyZmFjZSAoY29udGFpbnMgYSBzb3J0aW5nIG1ldGhvZCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUdyaWRHcm91cGluZ1N0cmF0ZWd5IGV4dGVuZHMgSUdyaWRTb3J0aW5nU3RyYXRlZ3kge1xuICAvKipcbiAgICogVGhlIG1ldGhvZCBncm91cHMgdGhlIHByb3ZpZGVkIGRhdGEgYmFzZWQgb24gdGhlIGdpdmVuIGdyb3VwaW5nIHN0YXRlIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gICAqIGBkYXRhYDogVGhlIGFycmF5IG9mIGRhdGEgdG8gYmUgZ3JvdXBlZC4gQ291bGQgYmUgb2YgYW55IHR5cGUuXG4gICAqIGBzdGF0ZWA6IFRoZSBncm91cGluZyBzdGF0ZSB0aGF0IGRlZmluZXMgdGhlIGdyb3VwaW5nIHNldHRpbmdzIGFuZCBleHByZXNzaW9ucy5cbiAgICogYGdyaWRgOiAoT3B0aW9uYWwpIFRoZSBpbnN0YW5jZSBvZiB0aGUgZ3JpZCB3aGVyZSB0aGUgZ3JvdXBpbmcgaXMgYXBwbGllZC5cbiAgICogYGdyb3Vwc1JlY29yZHNgOiAoT3B0aW9uYWwpIEFuIGFycmF5IHRoYXQgaG9sZHMgdGhlIHJlY29yZHMgZm9yIGVhY2ggZ3JvdXAuXG4gICAqIGBmdWxsUmVzdWx0YDogKE9wdGlvbmFsKSBUaGUgY29tcGxldGUgcmVzdWx0IG9mIGdyb3VwaW5nIGluY2x1ZGluZyBncm91cHMgYW5kIHN1bW1hcnkgZGF0YS5cbiAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIHRoZSBncm91cGluZyBvcGVyYXRpb24uXG4gICAqL1xuICAgIGdyb3VwQnkoZGF0YTogYW55W10sIHN0YXRlOiBJR3JvdXBpbmdTdGF0ZSwgZ3JpZD86IGFueSwgZ3JvdXBzUmVjb3Jkcz86IGFueVtdLCBmdWxsUmVzdWx0PzogSUdyb3VwQnlSZXN1bHQpOiBJR3JvdXBCeVJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2xhc3MgaW1wbGVtZW50aW5nIHRoZSBJR3JpZFNvcnRpbmdTdHJhdGVneSBpbnRlcmZhY2UuXG4gKiBJdCBwcm92aWRlcyBzb3J0aW5nIGZ1bmN0aW9uYWxpdHkgZm9yIGdyaWQgZGF0YSBiYXNlZCBvbiBzb3J0aW5nIGV4cHJlc3Npb25zLlxuICovXG5leHBvcnQgY2xhc3MgSWd4U29ydGluZyBpbXBsZW1lbnRzIElHcmlkU29ydGluZ1N0cmF0ZWd5IHtcbiAgICAvKipcbiAgICogU29ydHMgdGhlIHByb3ZpZGVkIGRhdGEgYmFzZWQgb24gdGhlIGdpdmVuIHNvcnRpbmcgZXhwcmVzc2lvbnMuXG4gICAqIGBkYXRhYDogVGhlIGFycmF5IG9mIGRhdGEgdG8gYmUgc29ydGVkLlxuICAgKiBgZXhwcmVzc2lvbnNgOiBBbiBhcnJheSBvZiBzb3J0aW5nIGV4cHJlc3Npb25zIHRoYXQgZGVmaW5lIHRoZSBzb3J0aW5nIHJ1bGVzLiBUaGUgZXhwcmVzc2lvbiBjb250YWlucyBpbmZvcm1hdGlvbiBsaWtlIGZpbGUgbmFtZSwgd2hldGhlciB0aGUgbGV0dGVyIGNhc2Ugc2hvdWxkIGJlIHRha2VuIGludG8gYWNjb3VudCwgZXRjLlxuICAgKiBgZ3JpZGA6IChPcHRpb25hbCkgVGhlIGluc3RhbmNlIG9mIHRoZSBncmlkIHdoZXJlIHRoZSBzb3J0aW5nIGlzIGFwcGxpZWQuXG4gICAqIFJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgZGF0YSBzb3J0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzb3J0aW5nIGV4cHJlc3Npb25zLlxuICAgKi9cbiAgICBwdWJsaWMgc29ydChkYXRhOiBhbnlbXSwgZXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdLCBncmlkPzogR3JpZFR5cGUpOiBhbnlbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnREYXRhUmVjdXJzaXZlKGRhdGEsIGV4cHJlc3Npb25zLCAwLCBncmlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICogUmVjdXJzaXZlbHkgZ3JvdXBzIHRoZSBwcm92aWRlZCBkYXRhIGJhc2VkIG9uIHRoZSBnaXZlbiBncm91cGluZyBzdGF0ZSBhbmQgcmV0dXJucyB0aGUgZ3JvdXBlZCByZXN1bHQuXG4gICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgZ3JvdXBlZCByZXN1bHQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgICBwcm90ZWN0ZWQgZ3JvdXBEYXRhUmVjdXJzaXZlKFxuICAgICAgICBkYXRhOiBhbnlbXSxcbiAgICAgICAgc3RhdGU6IElHcm91cGluZ1N0YXRlLFxuICAgICAgICBsZXZlbDogbnVtYmVyLFxuICAgICAgICBwYXJlbnQ6IElHcm91cEJ5UmVjb3JkLFxuICAgICAgICBtZXRhZGF0YTogSUdyb3VwQnlSZWNvcmRbXSxcbiAgICAgICAgZ3JpZDogR3JpZFR5cGUgPSBudWxsLFxuICAgICAgICBncm91cHNSZWNvcmRzOiBhbnlbXSA9IFtdLFxuICAgICAgICBmdWxsUmVzdWx0OiBJR3JvdXBCeVJlc3VsdCA9IHsgZGF0YTogW10sIG1ldGFkYXRhOiBbXSB9XG4gICAgKTogYW55W10ge1xuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IHN0YXRlLmV4cHJlc3Npb25zO1xuICAgICAgICBjb25zdCBleHBhbnNpb24gPSBzdGF0ZS5leHBhbnNpb247XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBncmlkID8gZ3JpZC5nZXRDb2x1bW5CeU5hbWUoZXhwcmVzc2lvbnNbbGV2ZWxdLmZpZWxkTmFtZSkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgaXNEYXRlID0gY29sdW1uPy5kYXRhVHlwZSA9PT0gREFURV9UWVBFIHx8IGNvbHVtbj8uZGF0YVR5cGUgPT09IERBVEVfVElNRV9UWVBFO1xuICAgICAgICAgICAgY29uc3QgaXNUaW1lID0gY29sdW1uPy5kYXRhVHlwZSA9PT0gVElNRV9UWVBFIHx8IGNvbHVtbj8uZGF0YVR5cGUgPT09IERBVEVfVElNRV9UWVBFO1xuICAgICAgICAgICAgY29uc3QgaXNTdHJpbmcgPSBjb2x1bW4/LmRhdGFUeXBlID09PSBTVFJJTkdfVFlQRTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5ncm91cGVkUmVjb3Jkc0J5RXhwcmVzc2lvbihkYXRhLCBpLCBleHByZXNzaW9uc1tsZXZlbF0sIGlzRGF0ZSwgaXNUaW1lLCBpc1N0cmluZyk7XG4gICAgICAgICAgICBjb25zdCBncm91cFJvdzogSUdyb3VwQnlSZWNvcmQgPSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbnNbbGV2ZWxdLFxuICAgICAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgICAgIHJlY29yZHM6IGNsb25lQXJyYXkoZ3JvdXApLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldEZpZWxkVmFsdWUoZ3JvdXBbMF0sIGV4cHJlc3Npb25zW2xldmVsXS5maWVsZE5hbWUsIGlzRGF0ZSwgaXNUaW1lKSxcbiAgICAgICAgICAgICAgICBncm91cFBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgICAgIGdyb3VwczogW10sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBncmlkID8gZ3JpZC5yZW5kZXJlZFJvd0hlaWdodCA6IG51bGwsXG4gICAgICAgICAgICAgICAgY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5ncm91cHMucHVzaChncm91cFJvdyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyb3Vwc1JlY29yZHMucHVzaChncm91cFJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoaWVyYXJjaHkgPSBnZXRIaWVyYXJjaHkoZ3JvdXBSb3cpO1xuICAgICAgICAgICAgY29uc3QgZXhwYW5kU3RhdGU6IElHcm91cEJ5RXhwYW5kU3RhdGUgPSBleHBhbnNpb24uZmluZCgocykgPT5cbiAgICAgICAgICAgICAgICBpc0hpZXJhcmNoeU1hdGNoKFxuICAgICAgICAgICAgICAgICAgICBzLmhpZXJhcmNoeSB8fCBbeyBmaWVsZE5hbWU6IGdyb3VwUm93LmV4cHJlc3Npb24uZmllbGROYW1lLCB2YWx1ZTogZ3JvdXBSb3cudmFsdWUgfV0sXG4gICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoeSxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kU3RhdGUgPyBleHBhbmRTdGF0ZS5leHBhbmRlZCA6IHN0YXRlLmRlZmF1bHRFeHBhbmRlZDtcbiAgICAgICAgICAgIGxldCByZWN1cnNpdmVSZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQucHVzaChncm91cFJvdyk7XG4gICAgICAgICAgICBtZXRhZGF0YS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgZnVsbFJlc3VsdC5kYXRhLnB1c2goZ3JvdXBSb3cpO1xuICAgICAgICAgICAgZnVsbFJlc3VsdC5tZXRhZGF0YS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgZXhwcmVzc2lvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZVJlc3VsdCA9IHRoaXMuZ3JvdXBEYXRhUmVjdXJzaXZlKGdyb3VwLCBzdGF0ZSwgbGV2ZWwgKyAxLCBncm91cFJvdyxcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPyBtZXRhZGF0YSA6IFtdLCBncmlkLCBncm91cHNSZWNvcmRzLCBmdWxsUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChyZWN1cnNpdmVSZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBncm91cEl0ZW0gb2YgZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbFJlc3VsdC5tZXRhZGF0YS5wdXNoKGdyb3VwUm93KTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbFJlc3VsdC5kYXRhLnB1c2goZ3JvdXBJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLnB1c2goLi4uZnVsbFJlc3VsdC5tZXRhZGF0YS5zbGljZShmdWxsUmVzdWx0Lm1ldGFkYXRhLmxlbmd0aCAtIGdyb3VwLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi5mdWxsUmVzdWx0LmRhdGEuc2xpY2UoZnVsbFJlc3VsdC5kYXRhLmxlbmd0aCAtIGdyb3VwLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gZ3JvdXAubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBmaWVsZCBmcm9tIHRoZSBnaXZlbiBvYmplY3QsIGNvbnNpZGVyaW5nIGRhdGUgYW5kIHRpbWUgZGF0YSB0eXBlcy5cbiAgICogYGtleWA6IFRoZSBrZXkgb2YgdGhlIGZpZWxkIHRvIHJldHJpZXZlLlxuICAgKiBgaXNEYXRlYDogKE9wdGlvbmFsKSBJbmRpY2F0ZXMgaWYgdGhlIGZpZWxkIGlzIG9mIHR5cGUgRGF0ZS5cbiAgICogYGlzVGltZWA6IChPcHRpb25hbCkgSW5kaWNhdGVzIGlmIHRoZSBmaWVsZCBpcyBvZiB0eXBlIFRpbWUuXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgZmllbGQgaW4gdGhlIGRhdGEgb2JqZWN0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICAgcHJvdGVjdGVkIGdldEZpZWxkVmFsdWU8VD4ob2JqOiBULCBrZXk6IHN0cmluZywgaXNEYXRlID0gZmFsc2UsIGlzVGltZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXNvbHZlZFZhbHVlID0gcmVzb2x2ZU5lc3RlZFBhdGgob2JqLCBrZXkpO1xuICAgICAgICBjb25zdCBkYXRlID0gcGFyc2VEYXRlKHJlc29sdmVkVmFsdWUpO1xuICAgICAgICBpZiAoZGF0ZSAmJiBpc0RhdGUgJiYgaXNUaW1lKSB7XG4gICAgICAgICAgICByZXNvbHZlZFZhbHVlID0gZGF0ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRlICYmIGlzRGF0ZSAmJiAhaXNUaW1lKSB7XG4gICAgICAgICAgICByZXNvbHZlZFZhbHVlID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRlICYmIGlzVGltZSAmJiAhaXNEYXRlKSB7XG4gICAgICAgICAgICByZXNvbHZlZFZhbHVlID0gbmV3IERhdGUobmV3IERhdGUoKS5zZXRIb3VycyhkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpLCBkYXRlLmdldFNlY29uZHMoKSwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgKiBHcm91cHMgdGhlIHJlY29yZHMgaW4gdGhlIHByb3ZpZGVkIGRhdGEgYXJyYXkgYmFzZWQgb24gdGhlIGdpdmVuIGdyb3VwaW5nIGV4cHJlc3Npb24uXG4gICAqIGBncm91cGluZ0NvbXBhcmVyYDogKE9wdGlvbmFsKSBBIGN1c3RvbSBncm91cGluZyBjb21wYXJhdG9yIHRvIGRldGVybWluZSB0aGUgbWVtYmVycyBvZiB0aGUgZ3JvdXAuXG4gICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgcmVjb3JkcyB0aGF0IGJlbG9uZyB0byB0aGUgZ3JvdXAuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgICBwcml2YXRlIGdyb3VwZWRSZWNvcmRzQnlFeHByZXNzaW9uPFQ+KFxuICAgICAgICBkYXRhOiBUW10sXG4gICAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICAgIGV4cHJlc3Npb246IElHcm91cGluZ0V4cHJlc3Npb24sXG4gICAgICAgIGlzRGF0ZSA9IGZhbHNlLFxuICAgICAgICBpc1RpbWUgPSBmYWxzZSxcbiAgICAgICAgaXNTdHJpbmc6IGJvb2xlYW4sXG4gICAgICAgIGdyb3VwaW5nQ29tcGFyZXI/OiAoYTogYW55LCBiOiBhbnksIGN1cnJSZWM6IGFueSwgZ3JvdXBSZWM6IGFueSkgPT4gbnVtYmVyXG4gICAgKTogVFtdIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGNvbnN0IGtleSA9IGV4cHJlc3Npb24uZmllbGROYW1lO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZ3JvdXBSZWNvcmQgPSBkYXRhW2luZGV4XTtcbiAgICAgICAgbGV0IGdyb3VwdmFsID0gdGhpcy5nZXRGaWVsZFZhbHVlKGdyb3VwUmVjb3JkLCBrZXksIGlzRGF0ZSwgaXNUaW1lKTtcbiAgICAgICAgcmVzLnB1c2goZ3JvdXBSZWNvcmQpO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBjb25zdCBjb21wYXJlciA9IGV4cHJlc3Npb24uZ3JvdXBpbmdDb21wYXJlciB8fCBncm91cGluZ0NvbXBhcmVyIHx8IERlZmF1bHRTb3J0aW5nU3RyYXRlZ3kuaW5zdGFuY2UoKS5jb21wYXJlVmFsdWVzO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyclJlYyA9IGRhdGFbaV07XG4gICAgICAgICAgICBsZXQgZmllbGRWYWx1ZSA9IHRoaXMuZ2V0RmllbGRWYWx1ZShjdXJyUmVjLCBrZXksIGlzRGF0ZSwgaXNUaW1lKTtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmlnbm9yZUNhc2UgJiYgaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNvbHVtbidzIGRhdGFUeXBlIGlzIHN0cmluZyBidXQgdGhlIHZhbHVlIGlzIG51bWJlclxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBmaWVsZFZhbHVlPy50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgZ3JvdXB2YWwgPSBncm91cHZhbD8udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBhcmVyKGZpZWxkVmFsdWUsIGdyb3VwdmFsLCBjdXJyUmVjLCBncm91cFJlY29yZCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChjdXJyUmVjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICogU29ydHMgdGhlIHByb3ZpZGVkIGRhdGEgYXJyYXkgYmFzZWQgb24gdGhlIGdpdmVuIHNvcnRpbmcgZXhwcmVzc2lvbnMuXG4gICAqIFRoZSBtZXRob2QgY2FuIGJlIHVzZWQgd2hlbiBtdWx0aXBsZSBzb3J0aW5nIGlzIHBlcmZvcm1lZCwgZ29pbmcgdGhyb3VnaCBlYWNoIG9uZVxuICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggdGhlIGRhdGEgc29ydGVkIGFjY29yZGluZyB0byB0aGUgc29ydGluZyBleHByZXNzaW9ucy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICAgIHByaXZhdGUgc29ydERhdGFSZWN1cnNpdmU8VD4oXG4gICAgICAgIGRhdGE6IFRbXSxcbiAgICAgICAgZXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdLFxuICAgICAgICBleHByZXNzaW9uSW5kZXggPSAwLFxuICAgICAgICBncmlkOiBHcmlkVHlwZVxuICAgICk6IFRbXSB7XG4gICAgICAgIGxldCBpOiBudW1iZXI7XG4gICAgICAgIGxldCBqOiBudW1iZXI7XG4gICAgICAgIGxldCBnYkRhdGE6IFRbXTtcbiAgICAgICAgbGV0IGdiRGF0YUxlbjogbnVtYmVyO1xuICAgICAgICBjb25zdCBleHByc0xlbiA9IGV4cHJlc3Npb25zLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgIGV4cHJlc3Npb25JbmRleCA9IGV4cHJlc3Npb25JbmRleCB8fCAwO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbkluZGV4ID49IGV4cHJzTGVuIHx8IGRhdGFMZW4gPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwciA9IGV4cHJlc3Npb25zW2V4cHJlc3Npb25JbmRleF07XG4gICAgICAgIGlmICghZXhwci5zdHJhdGVneSkge1xuICAgICAgICAgICAgZXhwci5zdHJhdGVneSA9IERlZmF1bHRTb3J0aW5nU3RyYXRlZ3kuaW5zdGFuY2UoKSBhcyBhbnk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sdW1uID0gZ3JpZD8uZ2V0Q29sdW1uQnlOYW1lKGV4cHIuZmllbGROYW1lKTtcbiAgICAgICAgY29uc3QgaXNEYXRlID0gY29sdW1uPy5kYXRhVHlwZSA9PT0gREFURV9UWVBFIHx8IGNvbHVtbj8uZGF0YVR5cGUgPT09IERBVEVfVElNRV9UWVBFO1xuICAgICAgICBjb25zdCBpc1RpbWUgPSBjb2x1bW4/LmRhdGFUeXBlID09PSBUSU1FX1RZUEUgfHwgY29sdW1uPy5kYXRhVHlwZSA9PT0gREFURV9USU1FX1RZUEU7XG4gICAgICAgIGNvbnN0IGlzU3RyaW5nID0gY29sdW1uPy5kYXRhVHlwZSA9PT0gU1RSSU5HX1RZUEU7XG4gICAgICAgIGRhdGEgPSBleHByLnN0cmF0ZWd5LnNvcnQoZGF0YSwgZXhwci5maWVsZE5hbWUsIGV4cHIuZGlyLCBleHByLmlnbm9yZUNhc2UsIHRoaXMuZ2V0RmllbGRWYWx1ZSwgaXNEYXRlLCBpc1RpbWUsIGdyaWQpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbkluZGV4ID09PSBleHByc0xlbiAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgbXVsdGlwbGUgc29ydGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbjsgaSsrKSB7XG4gICAgICAgICAgICBnYkRhdGEgPSB0aGlzLmdyb3VwZWRSZWNvcmRzQnlFeHByZXNzaW9uKGRhdGEsIGksIGV4cHIsIGlzRGF0ZSwgaXNUaW1lLCBpc1N0cmluZywgY29sdW1uPy5ncm91cGluZ0NvbXBhcmVyKTtcbiAgICAgICAgICAgIGdiRGF0YUxlbiA9IGdiRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZ2JEYXRhTGVuID4gMSkge1xuICAgICAgICAgICAgICAgIGdiRGF0YSA9IHRoaXMuc29ydERhdGFSZWN1cnNpdmUoZ2JEYXRhLCBleHByZXNzaW9ucywgZXhwcmVzc2lvbkluZGV4ICsgMSwgZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2JEYXRhTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhW2kgKyBqXSA9IGdiRGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gZ2JEYXRhTGVuIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsYXNzIGltcGxlbWVudGluZyB0aGUgSUdyaWRHcm91cGluZ1N0cmF0ZWd5IGludGVyZmFjZSBhbmQgZXh0ZW5kaW5nIHRoZSBJZ3hTb3J0aW5nIGNsYXNzLlxuICogSXQgcHJvdmlkZXMgYSBtZXRob2QgdG8gZ3JvdXAgZGF0YSBiYXNlZCBvbiB0aGUgZ2l2ZW4gZ3JvdXBpbmcgc3RhdGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBJZ3hHcm91cGluZyBleHRlbmRzIElneFNvcnRpbmcgaW1wbGVtZW50cyBJR3JpZEdyb3VwaW5nU3RyYXRlZ3kge1xuICAvKipcbiAgICogR3JvdXBzIHRoZSBwcm92aWRlZCBkYXRhIGJhc2VkIG9uIHRoZSBnaXZlbiBncm91cGluZyBzdGF0ZS5cbiAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIHRoZSBncm91cGluZyBvcGVyYXRpb24uXG4gICAqL1xuICAgIHB1YmxpYyBncm91cEJ5KGRhdGE6IGFueVtdLCBzdGF0ZTogSUdyb3VwaW5nU3RhdGUsIGdyaWQ/OiBhbnksXG4gICAgICAgIGdyb3Vwc1JlY29yZHM/OiBhbnlbXSwgZnVsbFJlc3VsdDogSUdyb3VwQnlSZXN1bHQgPSB7IGRhdGE6IFtdLCBtZXRhZGF0YTogW10gfSk6IElHcm91cEJ5UmVzdWx0IHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGE6IElHcm91cEJ5UmVjb3JkW10gPSBbXTtcbiAgICAgICAgY29uc3QgZ3JvdXBpbmcgPSB0aGlzLmdyb3VwRGF0YVJlY3Vyc2l2ZShkYXRhLCBzdGF0ZSwgMCwgbnVsbCwgbWV0YWRhdGEsIGdyaWQsIGdyb3Vwc1JlY29yZHMsIGZ1bGxSZXN1bHQpO1xuICAgICAgICBncmlkPy5ncm91cGluZ1BlcmZvcm1lZFN1YmplY3QubmV4dCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZ3JvdXBpbmcsXG4gICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2xhc3MgaW1wbGVtZW50aW5nIHRoZSBJR3JpZFNvcnRpbmdTdHJhdGVneSBpbnRlcmZhY2Ugd2l0aCBhIG5vLW9wZXJhdGlvbiBzb3J0aW5nIHN0cmF0ZWd5LlxuICogSXQgcGVyZm9ybXMgbm8gc29ydGluZyBhbmQgcmV0dXJucyB0aGUgZGF0YSBhcyBpdCBpcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vb3BTb3J0aW5nU3RyYXRlZ3kgaW1wbGVtZW50cyBJR3JpZFNvcnRpbmdTdHJhdGVneSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgX2luc3RhbmNlOiBOb29wU29ydGluZ1N0cmF0ZWd5ID0gbnVsbDtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7IH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZSB8fCAodGhpcy5faW5zdGFuY2UgPSBuZXcgTm9vcFNvcnRpbmdTdHJhdGVneSgpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc29ydChkYXRhOiBhbnlbXSk6IGFueVtdIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGFzcyBleHRlbmRpbmcgdGhlIElneFNvcnRpbmcgY2xhc3NcbiAqIFByb3ZpZHMgY3VzdG9tIGRhdGEgcmVjb3JkIHNvcnRpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBJZ3hEYXRhUmVjb3JkU29ydGluZyBleHRlbmRzIElneFNvcnRpbmcge1xuICAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgYmFzZSBtZXRob2QgdG8gcmV0cmlldmUgdGhlIGZpZWxkIHZhbHVlIGZyb20gdGhlIGRhdGEgb2JqZWN0IGluc3RlYWQgb2YgdGhlIHJlY29yZCBvYmplY3QuXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgZmllbGQgaW4gdGhlIGRhdGEgb2JqZWN0LlxuICAgKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZ2V0RmllbGRWYWx1ZShvYmo6IGFueSwga2V5OiBzdHJpbmcsIGlzRGF0ZSA9IGZhbHNlLCBpc1RpbWUgPSBmYWxzZSk6IGFueSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRGaWVsZFZhbHVlKG9iai5kYXRhLCBrZXksIGlzRGF0ZSwgaXNUaW1lKTtcbiAgICB9XG59XG4iXX0=