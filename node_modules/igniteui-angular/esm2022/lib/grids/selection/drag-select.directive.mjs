import { Directive, Input, Output, EventEmitter, booleanAttribute } from '@angular/core';
import { interval, Subject, animationFrameScheduler } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
var DragScrollDirection;
(function (DragScrollDirection) {
    DragScrollDirection[DragScrollDirection["NONE"] = 0] = "NONE";
    DragScrollDirection[DragScrollDirection["LEFT"] = 1] = "LEFT";
    DragScrollDirection[DragScrollDirection["TOP"] = 2] = "TOP";
    DragScrollDirection[DragScrollDirection["RIGHT"] = 3] = "RIGHT";
    DragScrollDirection[DragScrollDirection["BOTTOM"] = 4] = "BOTTOM";
    DragScrollDirection[DragScrollDirection["TOPLEFT"] = 5] = "TOPLEFT";
    DragScrollDirection[DragScrollDirection["TOPRIGHT"] = 6] = "TOPRIGHT";
    DragScrollDirection[DragScrollDirection["BOTTOMLEFT"] = 7] = "BOTTOMLEFT";
    DragScrollDirection[DragScrollDirection["BOTTOMRIGHT"] = 8] = "BOTTOMRIGHT";
})(DragScrollDirection || (DragScrollDirection = {}));
/**
 * An internal directive encapsulating the drag scroll behavior in the grid.
 *
 * @hidden @internal
 */
export class IgxGridDragSelectDirective {
    get activeDrag() {
        return this._activeDrag;
    }
    set activeDrag(val) {
        if (val !== this._activeDrag) {
            this.unsubscribe();
            this._activeDrag = val;
        }
    }
    get nativeElement() {
        return this.ref.nativeElement;
    }
    constructor(ref, zone) {
        this.ref = ref;
        this.zone = zone;
        this.dragStop = new EventEmitter();
        this.dragScroll = new EventEmitter();
        this.end$ = new Subject();
        this.lastDirection = DragScrollDirection.NONE;
        this.startDragSelection = (ev) => {
            if (!this.activeDrag) {
                return;
            }
            const x = ev.clientX;
            const y = ev.clientY;
            const { direction, delta } = this._measureDimensions(x, y);
            if (direction === this.lastDirection) {
                return;
            }
            this.unsubscribe();
            this._sub = this._interval$.subscribe(() => this.dragScroll.emit(delta));
            this.lastDirection = direction;
        };
        this.stopDragSelection = () => {
            if (!this.activeDrag) {
                return;
            }
            this.dragStop.emit(false);
            this.unsubscribe();
            this.lastDirection = DragScrollDirection.NONE;
        };
        this._interval$ = interval(0, animationFrameScheduler).pipe(takeUntil(this.end$), filter(() => this.activeDrag));
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addEventListener('pointerover', this.startDragSelection);
            this.nativeElement.addEventListener('pointerleave', this.stopDragSelection);
        });
    }
    ngOnDestroy() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.removeEventListener('pointerover', this.startDragSelection);
            this.nativeElement.removeEventListener('pointerleave', this.stopDragSelection);
        });
        this.unsubscribe();
        this.end$.complete();
    }
    _measureDimensions(x, y) {
        let direction;
        let delta = { left: 0, top: 0 };
        const { left, top, width, height } = this.nativeElement.getBoundingClientRect();
        const RATIO = 0.15;
        const offsetX = Math.trunc(x - left);
        const offsetY = Math.trunc(y - top);
        const leftDirection = offsetX <= width * RATIO;
        const rightDirection = offsetX >= width * (1 - RATIO);
        const topDirection = offsetY <= height * RATIO;
        const bottomDirection = offsetY >= height * (1 - RATIO);
        if (topDirection && leftDirection) {
            direction = DragScrollDirection.TOPLEFT;
            delta = { left: -1, top: -1 };
        }
        else if (topDirection && rightDirection) {
            direction = DragScrollDirection.TOPRIGHT;
            delta = { left: 1, top: -1 };
        }
        else if (bottomDirection && leftDirection) {
            direction = DragScrollDirection.BOTTOMLEFT;
            delta = { left: -1, top: 1 };
        }
        else if (bottomDirection && rightDirection) {
            direction = DragScrollDirection.BOTTOMRIGHT;
            delta = { top: 1, left: 1 };
        }
        else if (topDirection) {
            direction = DragScrollDirection.TOP;
            delta.top = -1;
        }
        else if (bottomDirection) {
            direction = DragScrollDirection.BOTTOM;
            delta.top = 1;
        }
        else if (leftDirection) {
            direction = DragScrollDirection.LEFT;
            delta.left = -1;
        }
        else if (rightDirection) {
            direction = DragScrollDirection.RIGHT;
            delta.left = 1;
        }
        else {
            direction = DragScrollDirection.NONE;
        }
        return { direction, delta };
    }
    unsubscribe() {
        if (this._sub) {
            this._sub.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxGridDragSelectDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.2.4", type: IgxGridDragSelectDirective, isStandalone: true, selector: "[igxGridDragSelect]", inputs: { activeDrag: ["igxGridDragSelect", "activeDrag", booleanAttribute] }, outputs: { dragStop: "dragStop", dragScroll: "dragScroll" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxGridDragSelectDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxGridDragSelect]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { dragStop: [{
                type: Output
            }], dragScroll: [{
                type: Output
            }], activeDrag: [{
                type: Input,
                args: [{ alias: 'igxGridDragSelect', transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1zZWxlY3QuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL3NlbGVjdGlvbi9kcmFnLXNlbGVjdC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBeUMsZ0JBQWdCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEksT0FBTyxFQUFFLFFBQVEsRUFBNEIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVGLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7O0FBRW5ELElBQUssbUJBVUo7QUFWRCxXQUFLLG1CQUFtQjtJQUNwQiw2REFBSSxDQUFBO0lBQ0osNkRBQUksQ0FBQTtJQUNKLDJEQUFHLENBQUE7SUFDSCwrREFBSyxDQUFBO0lBQ0wsaUVBQU0sQ0FBQTtJQUNOLG1FQUFPLENBQUE7SUFDUCxxRUFBUSxDQUFBO0lBQ1IseUVBQVUsQ0FBQTtJQUNWLDJFQUFXLENBQUE7QUFDZixDQUFDLEVBVkksbUJBQW1CLEtBQW5CLG1CQUFtQixRQVV2QjtBQUVEOzs7O0dBSUc7QUFLSCxNQUFNLE9BQU8sMEJBQTBCO0lBUW5DLElBQ1csVUFBVTtRQUNqQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDNUIsQ0FBQztJQUVELElBQVcsVUFBVSxDQUFDLEdBQVk7UUFDOUIsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUMxQixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDbkIsSUFBSSxDQUFDLFdBQVcsR0FBRyxHQUFHLENBQUM7U0FDMUI7SUFDTCxDQUFDO0lBRUQsSUFBVyxhQUFhO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FB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QUp0QyxTQUFTO21CQUFDO29CQUNQLFFBQVEsRUFBRSxxQkFBcUI7b0JBQy9CLFVBQVUsRUFBRSxJQUFJO2lCQUNuQjtvR0FJVSxRQUFRO3NCQURkLE1BQU07Z0JBSUEsVUFBVTtzQkFEaEIsTUFBTTtnQkFJSSxVQUFVO3NCQURwQixLQUFLO3VCQUFDLEVBQUUsS0FBSyxFQUFFLG1CQUFtQixFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIE5nWm9uZSwgT25Jbml0LCBib29sZWFuQXR0cmlidXRlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpbnRlcnZhbCwgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uLCBTdWJqZWN0LCBhbmltYXRpb25GcmFtZVNjaGVkdWxlciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmVudW0gRHJhZ1Njcm9sbERpcmVjdGlvbiB7XG4gICAgTk9ORSxcbiAgICBMRUZULFxuICAgIFRPUCxcbiAgICBSSUdIVCxcbiAgICBCT1RUT00sXG4gICAgVE9QTEVGVCxcbiAgICBUT1BSSUdIVCxcbiAgICBCT1RUT01MRUZULFxuICAgIEJPVFRPTVJJR0hUXG59XG5cbi8qKlxuICogQW4gaW50ZXJuYWwgZGlyZWN0aXZlIGVuY2Fwc3VsYXRpbmcgdGhlIGRyYWcgc2Nyb2xsIGJlaGF2aW9yIGluIHRoZSBncmlkLlxuICpcbiAqIEBoaWRkZW4gQGludGVybmFsXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneEdyaWREcmFnU2VsZWN0XScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkRHJhZ1NlbGVjdERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnU3RvcCA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnU2Nyb2xsID0gbmV3IEV2ZW50RW1pdHRlcjx7IGxlZnQ6IG51bWJlcjsgdG9wOiBudW1iZXIgfT4oKTtcblxuICAgIEBJbnB1dCh7IGFsaWFzOiAnaWd4R3JpZERyYWdTZWxlY3QnLCB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgICBwdWJsaWMgZ2V0IGFjdGl2ZURyYWcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVEcmFnO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgYWN0aXZlRHJhZyh2YWw6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbCAhPT0gdGhpcy5fYWN0aXZlRHJhZykge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlRHJhZyA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgbmF0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGVuZCQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gICAgcHJvdGVjdGVkIGxhc3REaXJlY3Rpb24gPSBEcmFnU2Nyb2xsRGlyZWN0aW9uLk5PTkU7XG4gICAgcHJvdGVjdGVkIF9pbnRlcnZhbCQ6IE9ic2VydmFibGU8YW55PjtcbiAgICBwcm90ZWN0ZWQgX3N1YjogU3Vic2NyaXB0aW9uO1xuXG4gICAgcHJpdmF0ZSBfYWN0aXZlRHJhZzogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiwgcHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwkID0gaW50ZXJ2YWwoMCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIpLnBpcGUoXG4gICAgICAgICAgICB0YWtlVW50aWwodGhpcy5lbmQkKSxcbiAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLmFjdGl2ZURyYWcpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJvdmVyJywgdGhpcy5zdGFydERyYWdTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIHRoaXMuc3RvcERyYWdTZWxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm92ZXInLCB0aGlzLnN0YXJ0RHJhZ1NlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgdGhpcy5zdG9wRHJhZ1NlbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZW5kJC5jb21wbGV0ZSgpO1xuICAgIH1cblxuXG4gICAgcHJvdGVjdGVkIHN0YXJ0RHJhZ1NlbGVjdGlvbiA9IChldjogUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVEcmFnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4ID0gZXYuY2xpZW50WDtcbiAgICAgICAgY29uc3QgeSA9IGV2LmNsaWVudFk7XG4gICAgICAgIGNvbnN0IHsgZGlyZWN0aW9uLCBkZWx0YSB9ID0gdGhpcy5fbWVhc3VyZURpbWVuc2lvbnMoeCwgeSk7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gdGhpcy5sYXN0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX3N1YiA9IHRoaXMuX2ludGVydmFsJC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kcmFnU2Nyb2xsLmVtaXQoZGVsdGEpKTtcbiAgICAgICAgdGhpcy5sYXN0RGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgc3RvcERyYWdTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVEcmFnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdTdG9wLmVtaXQoZmFsc2UpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMubGFzdERpcmVjdGlvbiA9IERyYWdTY3JvbGxEaXJlY3Rpb24uTk9ORTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9tZWFzdXJlRGltZW5zaW9ucyh4OiBudW1iZXIsIHk6IG51bWJlcik6IHsgZGlyZWN0aW9uOiBEcmFnU2Nyb2xsRGlyZWN0aW9uOyBkZWx0YTogeyBsZWZ0OiBudW1iZXI7IHRvcDogbnVtYmVyIH0gfSB7XG4gICAgICAgIGxldCBkaXJlY3Rpb246IERyYWdTY3JvbGxEaXJlY3Rpb247XG4gICAgICAgIGxldCBkZWx0YSA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIGNvbnN0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IFJBVElPID0gMC4xNTtcblxuICAgICAgICBjb25zdCBvZmZzZXRYID0gTWF0aC50cnVuYyh4IC0gbGVmdCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLnRydW5jKHkgLSB0b3ApO1xuXG4gICAgICAgIGNvbnN0IGxlZnREaXJlY3Rpb24gPSBvZmZzZXRYIDw9IHdpZHRoICogUkFUSU87XG4gICAgICAgIGNvbnN0IHJpZ2h0RGlyZWN0aW9uID0gb2Zmc2V0WCA+PSB3aWR0aCAqICgxIC0gUkFUSU8pO1xuICAgICAgICBjb25zdCB0b3BEaXJlY3Rpb24gPSBvZmZzZXRZIDw9IGhlaWdodCAqIFJBVElPO1xuICAgICAgICBjb25zdCBib3R0b21EaXJlY3Rpb24gPSBvZmZzZXRZID49IGhlaWdodCAqICgxIC0gUkFUSU8pO1xuXG4gICAgICAgIGlmICh0b3BEaXJlY3Rpb24gJiYgbGVmdERpcmVjdGlvbikge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gRHJhZ1Njcm9sbERpcmVjdGlvbi5UT1BMRUZUO1xuICAgICAgICAgICAgZGVsdGEgPSB7IGxlZnQ6IC0xLCB0b3A6IC0xIH07XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRGlyZWN0aW9uICYmIHJpZ2h0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBEcmFnU2Nyb2xsRGlyZWN0aW9uLlRPUFJJR0hUO1xuICAgICAgICAgICAgZGVsdGEgPSB7IGxlZnQ6IDEsIHRvcDogLTEgfTtcbiAgICAgICAgfSBlbHNlIGlmIChib3R0b21EaXJlY3Rpb24gJiYgbGVmdERpcmVjdGlvbikge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gRHJhZ1Njcm9sbERpcmVjdGlvbi5CT1RUT01MRUZUO1xuICAgICAgICAgICAgZGVsdGEgPSB7IGxlZnQ6IC0xLCB0b3A6IDEgfTtcbiAgICAgICAgfSBlbHNlIGlmIChib3R0b21EaXJlY3Rpb24gJiYgcmlnaHREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IERyYWdTY3JvbGxEaXJlY3Rpb24uQk9UVE9NUklHSFQ7XG4gICAgICAgICAgICBkZWx0YSA9IHsgdG9wOiAxLCBsZWZ0OiAxIH07XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBEcmFnU2Nyb2xsRGlyZWN0aW9uLlRPUDtcbiAgICAgICAgICAgIGRlbHRhLnRvcCA9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGJvdHRvbURpcmVjdGlvbikge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gRHJhZ1Njcm9sbERpcmVjdGlvbi5CT1RUT007XG4gICAgICAgICAgICBkZWx0YS50b3AgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGxlZnREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IERyYWdTY3JvbGxEaXJlY3Rpb24uTEVGVDtcbiAgICAgICAgICAgIGRlbHRhLmxlZnQgPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodERpcmVjdGlvbikge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gRHJhZ1Njcm9sbERpcmVjdGlvbi5SSUdIVDtcbiAgICAgICAgICAgIGRlbHRhLmxlZnQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gRHJhZ1Njcm9sbERpcmVjdGlvbi5OT05FO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZGlyZWN0aW9uLCBkZWx0YSB9O1xuXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAodGhpcy5fc3ViKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==