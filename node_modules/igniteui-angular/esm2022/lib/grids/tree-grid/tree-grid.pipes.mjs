import { Inject, Pipe } from '@angular/core';
import { cloneArray, cloneHierarchicalArray } from '../../core/utils';
import { DataUtil } from '../../data-operations/data-util';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { GridPagingMode } from '../common/enums';
import { TransactionType } from '../../services/public_api';
import { IgxAddRow } from '../common/crud.service';
import * as i0 from "@angular/core";
/**
 * @hidden
 */
export class IgxTreeGridHierarchizingPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, primaryKey, foreignKey, childDataKey, _) {
        let hierarchicalRecords = [];
        const treeGridRecordsMap = new Map();
        const flatData = [];
        if (!collection || !collection.length) {
            this.grid.flatData = collection;
            this.grid.records = treeGridRecordsMap;
            this.grid.rootRecords = collection;
            return collection;
        }
        if (childDataKey) {
            hierarchicalRecords = this.hierarchizeRecursive(collection, primaryKey, childDataKey, undefined, flatData, 0, treeGridRecordsMap);
        }
        else if (primaryKey) {
            hierarchicalRecords = this.hierarchizeFlatData(collection, primaryKey, foreignKey, treeGridRecordsMap, flatData);
        }
        this.grid.flatData = this.grid.transactions.enabled ?
            flatData.filter(rec => {
                const state = this.grid.transactions.getState(this.getRowID(primaryKey, rec));
                return !state || state.type !== TransactionType.ADD;
            }) : flatData;
        this.grid.records = treeGridRecordsMap;
        this.grid.rootRecords = hierarchicalRecords;
        return hierarchicalRecords;
    }
    getRowID(primaryKey, rowData) {
        return primaryKey ? rowData[primaryKey] : rowData;
    }
    hierarchizeFlatData(collection, primaryKey, foreignKey, map, flatData) {
        const result = [];
        const missingParentRecords = [];
        collection.forEach(row => {
            const record = {
                key: this.getRowID(primaryKey, row),
                data: row,
                children: []
            };
            const parent = map.get(row[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                missingParentRecords.push(record);
            }
            map.set(row[primaryKey], record);
        });
        missingParentRecords.forEach(record => {
            const parent = map.get(record.data[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                result.push(record);
            }
        });
        this.setIndentationLevels(result, 0, flatData);
        return result;
    }
    setIndentationLevels(collection, indentationLevel, flatData) {
        for (const record of collection) {
            record.level = indentationLevel;
            record.expanded = this.grid.gridAPI.get_row_expansion_state(record);
            flatData.push(record.data);
            if (record.children && record.children.length > 0) {
                this.setIndentationLevels(record.children, indentationLevel + 1, flatData);
            }
        }
    }
    hierarchizeRecursive(collection, primaryKey, childDataKey, parent, flatData, indentationLevel, map) {
        const result = [];
        for (const item of collection) {
            const record = {
                key: this.getRowID(primaryKey, item),
                data: item,
                parent,
                level: indentationLevel
            };
            record.expanded = this.grid.gridAPI.get_row_expansion_state(record);
            flatData.push(item);
            map.set(record.key, record);
            record.children = item[childDataKey] ?
                this.hierarchizeRecursive(item[childDataKey], primaryKey, childDataKey, record, flatData, indentationLevel + 1, map) :
                undefined;
            result.push(record);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridHierarchizingPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridHierarchizingPipe, isStandalone: true, name: "treeGridHierarchizing" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridHierarchizingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'treeGridHierarchizing',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 */
export class IgxTreeGridFlatteningPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, expandedLevels, expandedStates, _) {
        const data = [];
        this.grid.processedRootRecords = collection;
        this.grid.processedRecords = new Map();
        this.getFlatDataRecursive(collection, data, expandedLevels, expandedStates, true);
        this.grid.processedExpandedFlatData = data.map(r => r.data);
        return data;
    }
    getFlatDataRecursive(collection, data, expandedLevels, expandedStates, parentExpanded) {
        if (!collection || !collection.length) {
            return;
        }
        for (const hierarchicalRecord of collection) {
            if (parentExpanded) {
                data.push(hierarchicalRecord);
            }
            hierarchicalRecord.expanded = this.grid.gridAPI.get_row_expansion_state(hierarchicalRecord);
            this.updateNonProcessedRecordExpansion(this.grid, hierarchicalRecord);
            this.grid.processedRecords.set(hierarchicalRecord.key, hierarchicalRecord);
            this.getFlatDataRecursive(hierarchicalRecord.children, data, expandedLevels, expandedStates, parentExpanded && hierarchicalRecord.expanded);
        }
    }
    updateNonProcessedRecordExpansion(grid, record) {
        const rec = grid.records.get(record.key);
        rec.expanded = record.expanded;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridFlatteningPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridFlatteningPipe, isStandalone: true, name: "treeGridFlattening" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridFlatteningPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'treeGridFlattening',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/** @hidden */
export class IgxTreeGridSortingPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(hierarchicalData, sortExpressions, groupExpressions, sorting, _, pinned) {
        const expressions = groupExpressions ? groupExpressions.concat(sortExpressions) : sortExpressions;
        let result;
        if (!expressions.length) {
            result = hierarchicalData;
        }
        else {
            result = DataUtil.treeGridSort(hierarchicalData, expressions, sorting, null, this.grid);
        }
        const filteredSortedData = [];
        this.flattenTreeGridRecords(result, filteredSortedData);
        this.grid.setFilteredSortedData(filteredSortedData, pinned);
        return result;
    }
    flattenTreeGridRecords(records, flatData) {
        if (records && records.length) {
            for (const record of records) {
                flatData.push(record.data);
                this.flattenTreeGridRecords(record.children, flatData);
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridSortingPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridSortingPipe, isStandalone: true, name: "treeGridSorting" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridSortingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'treeGridSorting',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/** @hidden */
export class IgxTreeGridPagingPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, enabled, page = 0, perPage = 15, _) {
        if (!enabled || this.grid.pagingMode !== GridPagingMode.Local) {
            return collection;
        }
        const len = this.grid._totalRecords >= 0 ? this.grid._totalRecords : collection.length;
        const totalPages = Math.ceil(len / perPage);
        const state = {
            index: (totalPages > 0 && page >= totalPages) ? totalPages - 1 : page,
            recordsPerPage: perPage
        };
        const result = DataUtil.page(cloneArray(collection), state, len);
        this.grid.pagingState = state;
        this.grid.page = state.index;
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridPagingPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridPagingPipe, isStandalone: true, name: "treeGridPaging" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridPagingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'treeGridPaging',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/** @hidden */
export class IgxTreeGridTransactionPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, _) {
        if (this.grid.transactions.enabled) {
            const aggregatedChanges = this.grid.transactions.getAggregatedChanges(true);
            if (aggregatedChanges.length > 0) {
                const primaryKey = this.grid.primaryKey;
                if (!primaryKey) {
                    return collection;
                }
                const childDataKey = this.grid.childDataKey;
                if (childDataKey) {
                    const hierarchicalDataClone = cloneHierarchicalArray(collection, childDataKey);
                    return DataUtil.mergeHierarchicalTransactions(hierarchicalDataClone, aggregatedChanges, childDataKey, this.grid.primaryKey, this.grid.dataCloneStrategy);
                }
                else {
                    const flatDataClone = cloneArray(collection);
                    return DataUtil.mergeTransactions(flatDataClone, aggregatedChanges, this.grid.primaryKey, this.grid.dataCloneStrategy);
                }
            }
        }
        return collection;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridTransactionPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridTransactionPipe, isStandalone: true, name: "treeGridTransaction" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridTransactionPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'treeGridTransaction',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * This pipe maps the original record to ITreeGridRecord format used in TreeGrid.
 */
export class IgxTreeGridNormalizeRecordsPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(_, __) {
        const primaryKey = this.grid.primaryKey;
        // using flattened data because origin data may be hierarchical.
        const flatData = this.grid.flatData;
        const res = flatData ? flatData.map(rec => ({
            rowID: this.grid.primaryKey ? rec[primaryKey] : rec,
            data: rec,
            level: 0,
            children: []
        })) : [];
        return res;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridNormalizeRecordsPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridNormalizeRecordsPipe, isStandalone: true, name: "treeGridNormalizeRecord" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridNormalizeRecordsPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'treeGridNormalizeRecord',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
export class IgxTreeGridAddRowPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, isPinned = false, _pipeTrigger) {
        if (!this.grid.rowEditable || !this.grid.crudService.row || this.grid.crudService.row.getClassName() !== IgxAddRow.name ||
            !this.grid.gridAPI.crudService.addRowParent || isPinned !== this.grid.gridAPI.crudService.addRowParent.isPinned) {
            return collection;
        }
        const copy = collection.slice(0);
        const rec = this.grid.crudService.row.recordRef;
        if (this.grid.crudService.addRowParent.isPinned) {
            const parentRowIndex = copy.findIndex(record => record.rowID === this.grid.crudService.addRowParent.rowID);
            copy.splice(parentRowIndex + 1, 0, rec);
        }
        else {
            copy.splice(this.grid.crudService.row.index, 0, rec);
        }
        this.grid.records.set(rec.key, rec);
        return copy;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridAddRowPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridAddRowPipe, isStandalone: true, name: "treeGridAddRow" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxTreeGridAddRowPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'treeGridAddRow',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLnBpcGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL3RyZWUtZ3JpZC90cmVlLWdyaWQucGlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBQzVELE9BQU8sRUFBRSxVQUFVLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUN0RSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFM0QsT0FBTyxFQUFZLGFBQWEsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ25FLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNqRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHdCQUF3QixDQUFDOztBQUtuRDs7R0FFRztBQUtILE1BQU0sT0FBTyw0QkFBNEI7SUFFckMsWUFBMkMsSUFBYztRQUFkLFNBQUksR0FBSixJQUFJLENBQVU7SUFBSSxDQUFDO0lBRXZELFNBQVMsQ0FBQyxVQUFpQixFQUFFLFVBQWtCLEVBQUUsVUFBa0IsRUFBRSxZQUFvQixFQUFFLENBQVM7UUFDdkcsSUFBSSxtQkFBbUIsR0FBc0IsRUFBRSxDQUFDO1FBQ2hELE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxHQUFHLEVBQXdCLENBQUM7UUFDM0QsTUFBTSxRQUFRLEdBQVUsRUFBRSxDQUFDO1FBRTNCLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFO1lBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQztZQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxrQkFB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QUFDO1NBQ3JCO1FBQ0QsTUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqQyxNQUFNLEdBQUcsR0FBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFpQixDQUFDLFNBQVMsQ0FBQztRQUMvRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUU7WUFDN0MsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzNHLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDM0M7YUFBTTtZQUNILElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDeEQ7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNwQyxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDOzhHQW5CUSxxQkFBcUIsa0JBRVYsYUFBYTs0R0FGeEIscUJBQXFCOzsyRkFBckIscUJBQXFCO2tCQUpqQyxJQUFJO21CQUFDO29CQUNGLElBQUksRUFBRSxnQkFBZ0I7b0JBQ3RCLFVBQVUsRUFBRSxJQUFJO2lCQUNuQjs7MEJBR2dCLE1BQU07MkJBQUMsYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY2xvbmVBcnJheSwgY2xvbmVIaWVyYXJjaGljYWxBcnJheSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgRGF0YVV0aWwgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsJztcbmltcG9ydCB7IElUcmVlR3JpZFJlY29yZCB9IGZyb20gJy4vdHJlZS1ncmlkLmludGVyZmFjZXMnO1xuaW1wb3J0IHsgR3JpZFR5cGUsIElHWF9HUklEX0JBU0UgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgR3JpZFBhZ2luZ01vZGUgfSBmcm9tICcuLi9jb21tb24vZW51bXMnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcHVibGljX2FwaSc7XG5pbXBvcnQgeyBJZ3hBZGRSb3cgfSBmcm9tICcuLi9jb21tb24vY3J1ZC5zZXJ2aWNlJztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IElHcmlkU29ydGluZ1N0cmF0ZWd5IH0gZnJvbSAnLi4vY29tbW9uL3N0cmF0ZWd5JztcbmltcG9ydCB7IElHcm91cGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICd0cmVlR3JpZEhpZXJhcmNoaXppbmcnLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZUdyaWRIaWVyYXJjaGl6aW5nUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChJR1hfR1JJRF9CQVNFKSBwcml2YXRlIGdyaWQ6IEdyaWRUeXBlKSB7IH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oY29sbGVjdGlvbjogYW55W10sIHByaW1hcnlLZXk6IHN0cmluZywgZm9yZWlnbktleTogc3RyaW5nLCBjaGlsZERhdGFLZXk6IHN0cmluZywgXzogbnVtYmVyKTogSVRyZWVHcmlkUmVjb3JkW10ge1xuICAgICAgICBsZXQgaGllcmFyY2hpY2FsUmVjb3JkczogSVRyZWVHcmlkUmVjb3JkW10gPSBbXTtcbiAgICAgICAgY29uc3QgdHJlZUdyaWRSZWNvcmRzTWFwID0gbmV3IE1hcDxhbnksIElUcmVlR3JpZFJlY29yZD4oKTtcbiAgICAgICAgY29uc3QgZmxhdERhdGE6IGFueVtdID0gW107XG5cbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uIHx8ICFjb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmZsYXREYXRhID0gY29sbGVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5yZWNvcmRzID0gdHJlZUdyaWRSZWNvcmRzTWFwO1xuICAgICAgICAgICAgdGhpcy5ncmlkLnJvb3RSZWNvcmRzID0gY29sbGVjdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkRGF0YUtleSkge1xuICAgICAgICAgICAgaGllcmFyY2hpY2FsUmVjb3JkcyA9IHRoaXMuaGllcmFyY2hpemVSZWN1cnNpdmUoY29sbGVjdGlvbiwgcHJpbWFyeUtleSwgY2hpbGREYXRhS2V5LCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZmxhdERhdGEsIDAsIHRyZWVHcmlkUmVjb3Jkc01hcCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWFyeUtleSkge1xuICAgICAgICAgICAgaGllcmFyY2hpY2FsUmVjb3JkcyA9IHRoaXMuaGllcmFyY2hpemVGbGF0RGF0YShjb2xsZWN0aW9uLCBwcmltYXJ5S2V5LCBmb3JlaWduS2V5LCB0cmVlR3JpZFJlY29yZHNNYXAsIGZsYXREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZC5mbGF0RGF0YSA9IHRoaXMuZ3JpZC50cmFuc2FjdGlvbnMuZW5hYmxlZCA/XG4gICAgICAgICAgICBmbGF0RGF0YS5maWx0ZXIocmVjID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ3JpZC50cmFuc2FjdGlvbnMuZ2V0U3RhdGUodGhpcy5nZXRSb3dJRChwcmltYXJ5S2V5LCByZWMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXN0YXRlIHx8IHN0YXRlLnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5BREQ7XG4gICAgICAgICAgICB9KSA6IGZsYXREYXRhO1xuICAgICAgICB0aGlzLmdyaWQucmVjb3JkcyA9IHRyZWVHcmlkUmVjb3Jkc01hcDtcbiAgICAgICAgdGhpcy5ncmlkLnJvb3RSZWNvcmRzID0gaGllcmFyY2hpY2FsUmVjb3JkcztcbiAgICAgICAgcmV0dXJuIGhpZXJhcmNoaWNhbFJlY29yZHM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRSb3dJRChwcmltYXJ5S2V5OiBhbnksIHJvd0RhdGE6IGFueSkge1xuICAgICAgICByZXR1cm4gcHJpbWFyeUtleSA/IHJvd0RhdGFbcHJpbWFyeUtleV0gOiByb3dEYXRhO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGllcmFyY2hpemVGbGF0RGF0YShjb2xsZWN0aW9uOiBhbnlbXSwgcHJpbWFyeUtleTogc3RyaW5nLCBmb3JlaWduS2V5OiBzdHJpbmcsXG4gICAgICAgIG1hcDogTWFwPGFueSwgSVRyZWVHcmlkUmVjb3JkPiwgZmxhdERhdGE6IGFueVtdKTpcbiAgICAgICAgSVRyZWVHcmlkUmVjb3JkW10ge1xuICAgICAgICBjb25zdCByZXN1bHQ6IElUcmVlR3JpZFJlY29yZFtdID0gW107XG4gICAgICAgIGNvbnN0IG1pc3NpbmdQYXJlbnRSZWNvcmRzOiBJVHJlZUdyaWRSZWNvcmRbXSA9IFtdO1xuICAgICAgICBjb2xsZWN0aW9uLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZDogSVRyZWVHcmlkUmVjb3JkID0ge1xuICAgICAgICAgICAgICAgIGtleTogdGhpcy5nZXRSb3dJRChwcmltYXJ5S2V5LCByb3cpLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJvdyxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBtYXAuZ2V0KHJvd1tmb3JlaWduS2V5XSk7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChyZWNvcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nUGFyZW50UmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcC5zZXQocm93W3ByaW1hcnlLZXldLCByZWNvcmQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtaXNzaW5nUGFyZW50UmVjb3Jkcy5mb3JFYWNoKHJlY29yZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBtYXAuZ2V0KHJlY29yZC5kYXRhW2ZvcmVpZ25LZXldKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2V0SW5kZW50YXRpb25MZXZlbHMocmVzdWx0LCAwLCBmbGF0RGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldEluZGVudGF0aW9uTGV2ZWxzKGNvbGxlY3Rpb246IElUcmVlR3JpZFJlY29yZFtdLCBpbmRlbnRhdGlvbkxldmVsOiBudW1iZXIsIGZsYXREYXRhOiBhbnlbXSkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICByZWNvcmQubGV2ZWwgPSBpbmRlbnRhdGlvbkxldmVsO1xuICAgICAgICAgICAgcmVjb3JkLmV4cGFuZGVkID0gdGhpcy5ncmlkLmdyaWRBUEkuZ2V0X3Jvd19leHBhbnNpb25fc3RhdGUocmVjb3JkKTtcbiAgICAgICAgICAgIGZsYXREYXRhLnB1c2gocmVjb3JkLmRhdGEpO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkLmNoaWxkcmVuICYmIHJlY29yZC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbmRlbnRhdGlvbkxldmVscyhyZWNvcmQuY2hpbGRyZW4sIGluZGVudGF0aW9uTGV2ZWwgKyAxLCBmbGF0RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGhpZXJhcmNoaXplUmVjdXJzaXZlKGNvbGxlY3Rpb246IGFueVtdLCBwcmltYXJ5S2V5OiBzdHJpbmcsIGNoaWxkRGF0YUtleTogc3RyaW5nLFxuICAgICAgICBwYXJlbnQ6IElUcmVlR3JpZFJlY29yZCwgZmxhdERhdGE6IGFueVtdLCBpbmRlbnRhdGlvbkxldmVsOiBudW1iZXIsIG1hcDogTWFwPGFueSwgSVRyZWVHcmlkUmVjb3JkPik6IElUcmVlR3JpZFJlY29yZFtdIHtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBJVHJlZUdyaWRSZWNvcmRbXSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmQ6IElUcmVlR3JpZFJlY29yZCA9IHtcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuZ2V0Um93SUQocHJpbWFyeUtleSwgaXRlbSksXG4gICAgICAgICAgICAgICAgZGF0YTogaXRlbSxcbiAgICAgICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGluZGVudGF0aW9uTGV2ZWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWNvcmQuZXhwYW5kZWQgPSB0aGlzLmdyaWQuZ3JpZEFQSS5nZXRfcm93X2V4cGFuc2lvbl9zdGF0ZShyZWNvcmQpO1xuICAgICAgICAgICAgZmxhdERhdGEucHVzaChpdGVtKTtcbiAgICAgICAgICAgIG1hcC5zZXQocmVjb3JkLmtleSwgcmVjb3JkKTtcbiAgICAgICAgICAgIHJlY29yZC5jaGlsZHJlbiA9IGl0ZW1bY2hpbGREYXRhS2V5XSA/XG4gICAgICAgICAgICAgICAgdGhpcy5oaWVyYXJjaGl6ZVJlY3Vyc2l2ZShpdGVtW2NoaWxkRGF0YUtleV0sIHByaW1hcnlLZXksIGNoaWxkRGF0YUtleSwgcmVjb3JkLCBmbGF0RGF0YSwgaW5kZW50YXRpb25MZXZlbCArIDEsIG1hcCkgOlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlY29yZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAndHJlZUdyaWRGbGF0dGVuaW5nJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVHcmlkRmxhdHRlbmluZ1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoSUdYX0dSSURfQkFTRSkgcHJpdmF0ZSBncmlkOiBHcmlkVHlwZSkgeyB9XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKGNvbGxlY3Rpb246IElUcmVlR3JpZFJlY29yZFtdLFxuICAgICAgICBleHBhbmRlZExldmVsczogbnVtYmVyLCBleHBhbmRlZFN0YXRlczogTWFwPGFueSwgYm9vbGVhbj4sIF86IG51bWJlcik6IGFueVtdIHtcblxuICAgICAgICBjb25zdCBkYXRhOiBJVHJlZUdyaWRSZWNvcmRbXSA9IFtdO1xuXG4gICAgICAgIHRoaXMuZ3JpZC5wcm9jZXNzZWRSb290UmVjb3JkcyA9IGNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMuZ3JpZC5wcm9jZXNzZWRSZWNvcmRzID0gbmV3IE1hcDxhbnksIElUcmVlR3JpZFJlY29yZD4oKTtcblxuICAgICAgICB0aGlzLmdldEZsYXREYXRhUmVjdXJzaXZlKGNvbGxlY3Rpb24sIGRhdGEsIGV4cGFuZGVkTGV2ZWxzLCBleHBhbmRlZFN0YXRlcywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5ncmlkLnByb2Nlc3NlZEV4cGFuZGVkRmxhdERhdGEgPSBkYXRhLm1hcChyID0+IHIuZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGbGF0RGF0YVJlY3Vyc2l2ZShjb2xsZWN0aW9uOiBJVHJlZUdyaWRSZWNvcmRbXSwgZGF0YTogSVRyZWVHcmlkUmVjb3JkW10sXG4gICAgICAgIGV4cGFuZGVkTGV2ZWxzOiBudW1iZXIsIGV4cGFuZGVkU3RhdGVzOiBNYXA8YW55LCBib29sZWFuPiwgcGFyZW50RXhwYW5kZWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uIHx8ICFjb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBoaWVyYXJjaGljYWxSZWNvcmQgb2YgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKHBhcmVudEV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGhpZXJhcmNoaWNhbFJlY29yZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhpZXJhcmNoaWNhbFJlY29yZC5leHBhbmRlZCA9IHRoaXMuZ3JpZC5ncmlkQVBJLmdldF9yb3dfZXhwYW5zaW9uX3N0YXRlKGhpZXJhcmNoaWNhbFJlY29yZCk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlTm9uUHJvY2Vzc2VkUmVjb3JkRXhwYW5zaW9uKHRoaXMuZ3JpZCwgaGllcmFyY2hpY2FsUmVjb3JkKTtcblxuICAgICAgICAgICAgdGhpcy5ncmlkLnByb2Nlc3NlZFJlY29yZHMuc2V0KGhpZXJhcmNoaWNhbFJlY29yZC5rZXksIGhpZXJhcmNoaWNhbFJlY29yZCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0RmxhdERhdGFSZWN1cnNpdmUoaGllcmFyY2hpY2FsUmVjb3JkLmNoaWxkcmVuLCBkYXRhLCBleHBhbmRlZExldmVscyxcbiAgICAgICAgICAgICAgICBleHBhbmRlZFN0YXRlcywgcGFyZW50RXhwYW5kZWQgJiYgaGllcmFyY2hpY2FsUmVjb3JkLmV4cGFuZGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlTm9uUHJvY2Vzc2VkUmVjb3JkRXhwYW5zaW9uKGdyaWQ6IEdyaWRUeXBlLCByZWNvcmQ6IElUcmVlR3JpZFJlY29yZCkge1xuICAgICAgICBjb25zdCByZWMgPSBncmlkLnJlY29yZHMuZ2V0KHJlY29yZC5rZXkpO1xuICAgICAgICByZWMuZXhwYW5kZWQgPSByZWNvcmQuZXhwYW5kZWQ7XG4gICAgfVxufVxuXG4vKiogQGhpZGRlbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICd0cmVlR3JpZFNvcnRpbmcnLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZUdyaWRTb3J0aW5nUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChJR1hfR1JJRF9CQVNFKSBwcml2YXRlIGdyaWQ6IEdyaWRUeXBlKSB7IH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGhpZXJhcmNoaWNhbERhdGE6IElUcmVlR3JpZFJlY29yZFtdLFxuICAgICAgICBzb3J0RXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdLFxuICAgICAgICBncm91cEV4cHJlc3Npb25zOiBJR3JvdXBpbmdFeHByZXNzaW9uW10sXG4gICAgICAgIHNvcnRpbmc6IElHcmlkU29ydGluZ1N0cmF0ZWd5LFxuICAgICAgICBfOiBudW1iZXIsXG4gICAgICAgIHBpbm5lZD86IGJvb2xlYW4pOiBJVHJlZUdyaWRSZWNvcmRbXSB7XG5cbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBncm91cEV4cHJlc3Npb25zID8gZ3JvdXBFeHByZXNzaW9ucy5jb25jYXQoc29ydEV4cHJlc3Npb25zKSA6IHNvcnRFeHByZXNzaW9ucztcbiAgICAgICAgbGV0IHJlc3VsdDogSVRyZWVHcmlkUmVjb3JkW107XG4gICAgICAgIGlmICghZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBoaWVyYXJjaGljYWxEYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gRGF0YVV0aWwudHJlZUdyaWRTb3J0KGhpZXJhcmNoaWNhbERhdGEsIGV4cHJlc3Npb25zLCBzb3J0aW5nLCBudWxsLCB0aGlzLmdyaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsdGVyZWRTb3J0ZWREYXRhID0gW107XG4gICAgICAgIHRoaXMuZmxhdHRlblRyZWVHcmlkUmVjb3JkcyhyZXN1bHQsIGZpbHRlcmVkU29ydGVkRGF0YSk7XG4gICAgICAgIHRoaXMuZ3JpZC5zZXRGaWx0ZXJlZFNvcnRlZERhdGEoZmlsdGVyZWRTb3J0ZWREYXRhLCBwaW5uZWQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmbGF0dGVuVHJlZUdyaWRSZWNvcmRzKHJlY29yZHM6IElUcmVlR3JpZFJlY29yZFtdLCBmbGF0RGF0YTogYW55W10pIHtcbiAgICAgICAgaWYgKHJlY29yZHMgJiYgcmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICBmbGF0RGF0YS5wdXNoKHJlY29yZC5kYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsYXR0ZW5UcmVlR3JpZFJlY29yZHMocmVjb3JkLmNoaWxkcmVuLCBmbGF0RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKiBAaGlkZGVuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ3RyZWVHcmlkUGFnaW5nJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVHcmlkUGFnaW5nUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChJR1hfR1JJRF9CQVNFKSBwcml2YXRlIGdyaWQ6IEdyaWRUeXBlKSB7IH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oY29sbGVjdGlvbjogSVRyZWVHcmlkUmVjb3JkW10sIGVuYWJsZWQ6IGJvb2xlYW4sIHBhZ2UgPSAwLCBwZXJQYWdlID0gMTUsIF86IG51bWJlcik6IElUcmVlR3JpZFJlY29yZFtdIHtcbiAgICAgICAgaWYgKCFlbmFibGVkIHx8IHRoaXMuZ3JpZC5wYWdpbmdNb2RlICE9PSBHcmlkUGFnaW5nTW9kZS5Mb2NhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmdyaWQuX3RvdGFsUmVjb3JkcyA+PSAwID8gdGhpcy5ncmlkLl90b3RhbFJlY29yZHMgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdG90YWxQYWdlcyA9IE1hdGguY2VpbChsZW4gLyBwZXJQYWdlKTtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAodG90YWxQYWdlcyA+IDAgJiYgcGFnZSA+PSB0b3RhbFBhZ2VzKSA/IHRvdGFsUGFnZXMgLSAxIDogcGFnZSxcbiAgICAgICAgICAgIHJlY29yZHNQZXJQYWdlOiBwZXJQYWdlXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBJVHJlZUdyaWRSZWNvcmRbXSA9IERhdGFVdGlsLnBhZ2UoY2xvbmVBcnJheShjb2xsZWN0aW9uKSwgc3RhdGUsIGxlbik7XG4gICAgICAgIHRoaXMuZ3JpZC5wYWdpbmdTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmdyaWQucGFnZSA9IHN0YXRlLmluZGV4O1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqIEBoaWRkZW4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAndHJlZUdyaWRUcmFuc2FjdGlvbicsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUcmVlR3JpZFRyYW5zYWN0aW9uUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KElHWF9HUklEX0JBU0UpIHByaXZhdGUgZ3JpZDogR3JpZFR5cGUpIHsgfVxuXG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBhbnlbXSwgXzogbnVtYmVyKTogYW55W10ge1xuXG4gICAgICAgIGlmICh0aGlzLmdyaWQudHJhbnNhY3Rpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFnZ3JlZ2F0ZWRDaGFuZ2VzID0gdGhpcy5ncmlkLnRyYW5zYWN0aW9ucy5nZXRBZ2dyZWdhdGVkQ2hhbmdlcyh0cnVlKTtcbiAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVkQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpbWFyeUtleSA9IHRoaXMuZ3JpZC5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgIGlmICghcHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZERhdGFLZXkgPSB0aGlzLmdyaWQuY2hpbGREYXRhS2V5O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkRGF0YUtleSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoaWVyYXJjaGljYWxEYXRhQ2xvbmUgPSBjbG9uZUhpZXJhcmNoaWNhbEFycmF5KGNvbGxlY3Rpb24sIGNoaWxkRGF0YUtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEYXRhVXRpbC5tZXJnZUhpZXJhcmNoaWNhbFRyYW5zYWN0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoaWNhbERhdGFDbG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWRDaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGREYXRhS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkLnByaW1hcnlLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQuZGF0YUNsb25lU3RyYXRlZ3lcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGF0RGF0YUNsb25lID0gY2xvbmVBcnJheShjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERhdGFVdGlsLm1lcmdlVHJhbnNhY3Rpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdERhdGFDbG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWRDaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkLnByaW1hcnlLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQuZGF0YUNsb25lU3RyYXRlZ3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBwaXBlIG1hcHMgdGhlIG9yaWdpbmFsIHJlY29yZCB0byBJVHJlZUdyaWRSZWNvcmQgZm9ybWF0IHVzZWQgaW4gVHJlZUdyaWQuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAndHJlZUdyaWROb3JtYWxpemVSZWNvcmQnLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZUdyaWROb3JtYWxpemVSZWNvcmRzUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChJR1hfR1JJRF9CQVNFKSBwcml2YXRlIGdyaWQ6IEdyaWRUeXBlKSB7IH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXzogYW55W10sIF9fOiBudW1iZXIpOiBhbnlbXSB7XG4gICAgICAgIGNvbnN0IHByaW1hcnlLZXkgPSB0aGlzLmdyaWQucHJpbWFyeUtleTtcbiAgICAgICAgLy8gdXNpbmcgZmxhdHRlbmVkIGRhdGEgYmVjYXVzZSBvcmlnaW4gZGF0YSBtYXkgYmUgaGllcmFyY2hpY2FsLlxuICAgICAgICBjb25zdCBmbGF0RGF0YSA9IHRoaXMuZ3JpZC5mbGF0RGF0YTtcbiAgICAgICAgY29uc3QgcmVzID0gZmxhdERhdGEgPyBmbGF0RGF0YS5tYXAocmVjID0+XG4gICAgICAgICh7XG4gICAgICAgICAgICByb3dJRDogdGhpcy5ncmlkLnByaW1hcnlLZXkgPyByZWNbcHJpbWFyeUtleV0gOiByZWMsXG4gICAgICAgICAgICBkYXRhOiByZWMsXG4gICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9KSkgOiBbXTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbkBQaXBlKHtcbiAgICBuYW1lOiAndHJlZUdyaWRBZGRSb3cnLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZUdyaWRBZGRSb3dQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KElHWF9HUklEX0JBU0UpIHByaXZhdGUgZ3JpZDogR3JpZFR5cGUpIHsgfVxuXG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBhbnksIGlzUGlubmVkID0gZmFsc2UsIF9waXBlVHJpZ2dlcjogbnVtYmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmlkLnJvd0VkaXRhYmxlIHx8ICF0aGlzLmdyaWQuY3J1ZFNlcnZpY2Uucm93IHx8IHRoaXMuZ3JpZC5jcnVkU2VydmljZS5yb3cuZ2V0Q2xhc3NOYW1lKCkgIT09IElneEFkZFJvdy5uYW1lIHx8XG4gICAgICAgICAgICAhdGhpcy5ncmlkLmdyaWRBUEkuY3J1ZFNlcnZpY2UuYWRkUm93UGFyZW50IHx8IGlzUGlubmVkICE9PSB0aGlzLmdyaWQuZ3JpZEFQSS5jcnVkU2VydmljZS5hZGRSb3dQYXJlbnQuaXNQaW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvcHkgPSBjb2xsZWN0aW9uLnNsaWNlKDApO1xuICAgICAgICBjb25zdCByZWMgPSAodGhpcy5ncmlkLmNydWRTZXJ2aWNlLnJvdyBhcyBJZ3hBZGRSb3cpLnJlY29yZFJlZjtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5jcnVkU2VydmljZS5hZGRSb3dQYXJlbnQuaXNQaW5uZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFJvd0luZGV4ID0gY29weS5maW5kSW5kZXgocmVjb3JkID0+IHJlY29yZC5yb3dJRCA9PT0gdGhpcy5ncmlkLmNydWRTZXJ2aWNlLmFkZFJvd1BhcmVudC5yb3dJRCk7XG4gICAgICAgICAgICBjb3B5LnNwbGljZShwYXJlbnRSb3dJbmRleCArIDEsIDAsIHJlYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3B5LnNwbGljZSh0aGlzLmdyaWQuY3J1ZFNlcnZpY2Uucm93LmluZGV4LCAwLCByZWMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5yZWNvcmRzLnNldChyZWMua2V5LCByZWMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG4iXX0=