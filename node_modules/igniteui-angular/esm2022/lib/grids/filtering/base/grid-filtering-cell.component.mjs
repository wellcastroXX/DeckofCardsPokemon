import { ChangeDetectionStrategy, Component, ElementRef, HostBinding, Input, TemplateRef, ViewChild } from '@angular/core';
import { DisplayDensity } from '../../../core/density';
import { IgxChipsAreaComponent } from '../../../chips/chips-area.component';
import { IgxChipComponent } from '../../../chips/chip.component';
import { IgxBadgeComponent } from '../../../badge/badge.component';
import { NgFor, NgIf, NgClass, NgTemplateOutlet } from '@angular/common';
import { IgxPrefixDirective } from '../../../directives/prefix/prefix.directive';
import { IgxIconComponent } from '../../../icon/icon.component';
import * as i0 from "@angular/core";
import * as i1 from "../grid-filtering.service";
/**
 * @hidden
 */
export class IgxGridFilteringCellComponent {
    get styleClasses() {
        let classes = this.column && this.column.selected ?
            'igx-grid__filtering-cell--selected' :
            'igx-grid__filtering-cell';
        switch (this.column.grid.displayDensity) {
            case DisplayDensity.compact:
                classes = classes + ' igx-grid__filtering-cell--compact';
                break;
            case DisplayDensity.cosy:
                classes = classes + ' igx-grid__filtering-cell--cosy';
                break;
        }
        return classes;
    }
    constructor(cdr, filteringService) {
        this.cdr = cdr;
        this.filteringService = filteringService;
        this.moreFiltersCount = 0;
        this.baseClass = 'igx-grid__filtering-cell-indicator';
        this.filteringService.subscribeToEvents();
    }
    ngOnInit() {
        this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
    }
    ngAfterViewInit() {
        this.updateFilterCellArea();
    }
    ngDoCheck() {
        this.updateFilterCellArea();
    }
    /**
     * Returns whether a chip with a given index is visible or not.
     */
    isChipVisible(index) {
        const expression = this.expressionsList[index];
        return !!(expression && expression.isVisible);
    }
    /**
     * Updates the filtering cell area.
     */
    updateFilterCellArea() {
        this.expressionsList = this.filteringService.getExpressions(this.column.field);
        this.updateVisibleFilters();
    }
    get displayDensity() {
        return this.column.grid.displayDensity === DisplayDensity.comfortable ? DisplayDensity.cosy : this.column.grid.displayDensity;
    }
    get template() {
        if (!this.column.filterable) {
            return null;
        }
        if (this.column.filterCellTemplate) {
            return this.column.filterCellTemplate;
        }
        const expressionTree = this.column.filteringExpressionsTree;
        if (!expressionTree || expressionTree.filteringOperands.length === 0) {
            return this.emptyFilter;
        }
        if (this.filteringService.isFilterComplex(this.column.field)) {
            return this.complexFilter;
        }
        return this.defaultFilter;
    }
    /**
     * Gets the context passed to the filter template.
     *
     * @memberof IgxGridFilteringCellComponent
     */
    get context() {
        return { $implicit: this.column, column: this.column };
    }
    /**
     * Chip clicked event handler.
     */
    onChipClicked(expression) {
        if (expression) {
            this.expressionsList.forEach((item) => {
                item.isSelected = (item.expression === expression);
            });
        }
        else if (this.expressionsList.length > 0) {
            this.expressionsList.forEach((item) => {
                item.isSelected = false;
            });
            this.expressionsList[0].isSelected = true;
        }
        this.filteringService.grid.navigation.performHorizontalScrollToCell(this.column.visibleIndex);
        this.filteringService.filteredColumn = this.column;
        this.filteringService.isFilterRowVisible = true;
        this.filteringService.selectedExpression = expression;
    }
    /**
     * Chip removed event handler.
     */
    onChipRemoved(eventArgs, item) {
        const indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove);
        this.filteringService.grid.theadRow.nativeElement.focus();
    }
    /**
     * Clears the filtering.
     */
    clearFiltering() {
        this.filteringService.clearFilter(this.column.field);
        this.cdr.detectChanges();
    }
    /**
     * Returns the filtering indicator class.
     */
    filteringIndicatorClass() {
        return {
            [this.baseClass]: !this.isMoreIconHidden(),
            [`${this.baseClass}--hidden`]: this.isMoreIconHidden()
        };
    }
    removeExpression(indexToRemove) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.updateVisibleFilters();
        this.filteringService.filterInternal(this.column.field);
    }
    isMoreIconHidden() {
        return this.filteringService.columnToMoreIconHidden.get(this.column.field);
    }
    updateVisibleFilters() {
        this.expressionsList.forEach((ex) => ex.isVisible = true);
        if (this.moreIcon) {
            this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
        }
        this.cdr.detectChanges();
        if (this.chipsArea && this.expressionsList.length > 1) {
            const areaWidth = this.chipsArea.element.nativeElement.offsetWidth;
            let viewWidth = 0;
            const chipsAreaElements = this.chipsArea.element.nativeElement.children;
            let visibleChipsCount = 0;
            const moreIconWidth = this.moreIcon.nativeElement.offsetWidth -
                parseInt(document.defaultView.getComputedStyle(this.moreIcon.nativeElement)['margin-left'], 10);
            for (let index = 0; index < chipsAreaElements.length - 1; index++) {
                if (viewWidth + chipsAreaElements[index].offsetWidth < areaWidth) {
                    viewWidth += chipsAreaElements[index].offsetWidth;
                    if (index % 2 === 0) {
                        visibleChipsCount++;
                    }
                    else {
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-left'], 10);
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-right'], 10);
                    }
                }
                else {
                    if (index % 2 !== 0 && viewWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    else if (visibleChipsCount > 0 && viewWidth - chipsAreaElements[index - 1].offsetWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    this.moreFiltersCount = this.expressionsList.length - visibleChipsCount;
                    this.filteringService.columnToMoreIconHidden.set(this.column.field, false);
                    break;
                }
            }
            for (let i = visibleChipsCount; i < this.expressionsList.length; i++) {
                this.expressionsList[i].isVisible = false;
            }
            this.cdr.detectChanges();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxGridFilteringCellComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.IgxFilteringService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: IgxGridFilteringCellComponent, isStandalone: true, selector: "igx-grid-filtering-cell", inputs: { column: "column" }, host: { properties: { "class": "this.styleClasses" } }, viewQueries: [{ propertyName: "emptyFilter", first: true, predicate: ["emptyFilter"], descendants: true, read: TemplateRef, static: true }, { propertyName: "defaultFilter", first: true, predicate: ["defaultFilter"], descendants: true, read: TemplateRef, static: true }, { propertyName: "complexFilter", first: true, predicate: ["complexFilter"], descendants: true, read: TemplateRef, static: true }, { propertyName: "chipsArea", first: true, predicate: ["chipsArea"], descendants: true, read: IgxChipsAreaComponent }, { propertyName: "moreIcon", first: true, predicate: ["moreIcon"], descendants: true, read: ElementRef }, { propertyName: "ghostChip", first: true, predicate: ["ghostChip"], descendants: true, read: IgxChipComponent }, { propertyName: "complexChip", first: true, predicate: ["complexChip"], descendants: true, read: IgxChipComponent }], ngImport: i0, template: "<ng-template #emptyFilter>\n    <igx-chips-area [attr.draggable]=\"false\" class=\"igx-filtering-chips\">\n        <igx-chip #ghostChip [attr.draggable]=\"false\" (click)=\"onChipClicked()\" [displayDensity]=\"displayDensity\" [tabIndex]=\"-1\">\n            <igx-icon [attr.draggable]=\"false\" igxPrefix>filter_list</igx-icon>\n            <span [attr.draggable]=\"false\">{{filteringService.grid.resourceStrings.igx_grid_filter}}</span>\n        </igx-chip>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #defaultFilter>\n    <igx-chips-area #chipsArea class=\"igx-filtering-chips\">\n        <ng-container *ngFor=\"let item of expressionsList; let last = last; let index = index;\" >\n            <igx-chip *ngIf=\"isChipVisible(index)\"\n                [removable]=\"true\"\n                [tabIndex]=\"-1\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"onChipClicked(item.expression)\"\n                (remove)=\"onChipRemoved($event, item)\">\n                <igx-icon igxPrefix\n                    family=\"imx-icons\"\n                    [name]=\"item.expression.condition.iconName\">\n                </igx-icon>\n                <span #label>\n                    {{filteringService.getChipLabel(item.expression)}}\n                </span>\n            </igx-chip>\n            <span class=\"igx-filtering-chips__connector\" *ngIf=\"!last && isChipVisible(index + 1)\">{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n        </ng-container>\n        <div #moreIcon [ngClass]=\"filteringIndicatorClass()\" (click)=\"onChipClicked()\">\n            <igx-icon>filter_list</igx-icon>\n            <igx-badge [value]=\"moreFiltersCount\"></igx-badge>\n        </div>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #complexFilter>\n    <igx-chip #complexChip [removable]=\"true\" [displayDensity]=\"displayDensity\" (remove)=\"clearFiltering()\" [tabIndex]=\"-1\">\n        <igx-icon igxPrefix>filter_list</igx-icon>\n        <span>{{filteringService.grid.resourceStrings.igx_grid_complex_filter}}</span>\n    </igx-chip>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n", dependencies: [{ kind: "component", type: IgxChipsAreaComponent, selector: "igx-chips-area", inputs: ["width", "height"], outputs: ["reorder", "selectionChange", "moveStart", "moveEnd"] }, { kind: "component", type: IgxChipComponent, selector: "igx-chip", inputs: ["variant", "id", "tabIndex", "data", "draggable", "animateOnRelease", "hideBaseOnDrag", "removable", "removeIcon", "selectable", "selectIcon", "class", "disabled", "selected", "color", "resourceStrings"], outputs: ["selectedChange", "moveStart", "moveEnd", "remove", "chipClick", "selectedChanging", "selectedChanged", "keyDown", "dragEnter", "dragLeave", "dragOver", "dragDrop"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: IgxPrefixDirective, selector: "igx-prefix,[igxPrefix],[igxStart]" }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: IgxBadgeComponent, selector: "igx-badge", inputs: ["id", "type", "value", "icon", "iconSet", "shape"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IgxGridFilteringCellComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-grid-filtering-cell', standalone: true, imports: [IgxChipsAreaComponent, IgxChipComponent, IgxIconComponent, IgxPrefixDirective, NgFor, NgIf, NgClass, IgxBadgeComponent, NgTemplateOutlet], template: "<ng-template #emptyFilter>\n    <igx-chips-area [attr.draggable]=\"false\" class=\"igx-filtering-chips\">\n        <igx-chip #ghostChip [attr.draggable]=\"false\" (click)=\"onChipClicked()\" [displayDensity]=\"displayDensity\" [tabIndex]=\"-1\">\n            <igx-icon [attr.draggable]=\"false\" igxPrefix>filter_list</igx-icon>\n            <span [attr.draggable]=\"false\">{{filteringService.grid.resourceStrings.igx_grid_filter}}</span>\n        </igx-chip>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #defaultFilter>\n    <igx-chips-area #chipsArea class=\"igx-filtering-chips\">\n        <ng-container *ngFor=\"let item of expressionsList; let last = last; let index = index;\" >\n            <igx-chip *ngIf=\"isChipVisible(index)\"\n                [removable]=\"true\"\n                [tabIndex]=\"-1\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"onChipClicked(item.expression)\"\n                (remove)=\"onChipRemoved($event, item)\">\n                <igx-icon igxPrefix\n                    family=\"imx-icons\"\n                    [name]=\"item.expression.condition.iconName\">\n                </igx-icon>\n                <span #label>\n                    {{filteringService.getChipLabel(item.expression)}}\n                </span>\n            </igx-chip>\n            <span class=\"igx-filtering-chips__connector\" *ngIf=\"!last && isChipVisible(index + 1)\">{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n        </ng-container>\n        <div #moreIcon [ngClass]=\"filteringIndicatorClass()\" (click)=\"onChipClicked()\">\n            <igx-icon>filter_list</igx-icon>\n            <igx-badge [value]=\"moreFiltersCount\"></igx-badge>\n        </div>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #complexFilter>\n    <igx-chip #complexChip [removable]=\"true\" [displayDensity]=\"displayDensity\" (remove)=\"clearFiltering()\" [tabIndex]=\"-1\">\n        <igx-icon igxPrefix>filter_list</igx-icon>\n        <span>{{filteringService.grid.resourceStrings.igx_grid_complex_filter}}</span>\n    </igx-chip>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n" }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i1.IgxFilteringService }], propDecorators: { column: [{
                type: Input
            }], emptyFilter: [{
                type: ViewChild,
                args: ['emptyFilter', { read: TemplateRef, static: true }]
            }], defaultFilter: [{
                type: ViewChild,
                args: ['defaultFilter', { read: TemplateRef, static: true }]
            }], complexFilter: [{
                type: ViewChild,
                args: ['complexFilter', { read: TemplateRef, static: true }]
            }], chipsArea: [{
                type: ViewChild,
                args: ['chipsArea', { read: IgxChipsAreaComponent }]
            }], moreIcon: [{
                type: ViewChild,
                args: ['moreIcon', { read: ElementRef }]
            }], ghostChip: [{
                type: ViewChild,
                args: ['ghostChip', { read: IgxChipComponent }]
            }], complexChip: [{
                type: ViewChild,
                args: ['complexChip', { read: IgxChipComponent }]
            }], styleClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC1maWx0ZXJpbmctY2VsbC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvZmlsdGVyaW5nL2Jhc2UvZ3JpZC1maWx0ZXJpbmctY2VsbC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvZmlsdGVyaW5nL2Jhc2UvZ3JpZC1maWx0ZXJpbmctY2VsbC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUgsdUJBQXVCLEVBRXZCLFNBQVMsRUFFVCxVQUFVLEVBQ1YsV0FBVyxFQUNYLEtBQUssRUFFTCxXQUFXLEVBQ1gsU0FBUyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBR3ZCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUV2RCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUM1RSxPQUFPLEVBQXNCLGdCQUFnQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFckYsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDbkUsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDakYsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sOEJBQThCLENBQUM7OztBQUVoRTs7R0FFRztBQVFILE1BQU0sT0FBTyw2QkFBNkI7SUEwQnRDLElBQ1csWUFBWTtRQUNuQixJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDL0Msb0NBQW9DLENBQUMsQ0FBQztZQUN0QywwQkFBMEIsQ0FBQztRQUUvQixRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUNyQyxLQUFLLGNBQWMsQ0FBQyxPQUFPO2dCQUN2QixPQUFPLEdBQUcsT0FBTyxHQUFHLG9DQUFvQyxDQUFDO2dCQUN6RCxNQUFNO1lBQ1YsS0FBSyxjQUFjLENBQUMsSUFBSTtnQkFDcEIsT0FBTyxHQUFHLE9BQU8sR0FBRyxpQ0FBaUMsQ0FBQztnQkFDdEQsTUFBTTtTQUNiO1FBQ0QsT0FBTyxPQUFPLENBQUM7SUFDbkIsQ0FBQztJQU9ELFlBQW1CLEdBQXNCLEVBQVMsZ0JBQXFDO1FBQXBFLFFBQUcsR0FBSCxHQUFHLENBQW1CO1FBQVMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFxQjtRQUpoRixxQkFBZ0IsR0FBRyxDQUFDLENBQUM7UUFFcEIsY0FBUyxHQUFHLG9DQUFvQyxDQUFDO1FBR3JELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzlDLENBQUM7SUFFTSxRQUFRO1FBQ1gsSUFBSSxDQUFDLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRU0sZUFBZTtRQUNsQixJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRU0sU0FBUztRQUNaLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7T0FFRztJQUNJLGFBQWEsQ0FBQyxLQUFhO1FBQzlCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0MsT0FBTyxDQUFDLENBQUMsQ0FBQyxVQUFVLElBQUksVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7T0FFRztJQUNJLG9CQUFvQjtRQUN2QixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMvRSxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRUQsSUFBVyxjQUFjO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxLQUFLLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUNsSSxDQUFDO0lBRUQsSUFBVyxRQUFRO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFO1lBQ3pCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEVBQUU7WUFDaEMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDO1NBQ3pDO1FBQ0QsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQztRQUM1RCxJQUFJLENBQUMsY0FBYyxJQUFJLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ2xFLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztTQUMzQjtRQUNELElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFELE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztTQUM3QjtRQUNELE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQVcsT0FBTztRQUNkLE9BQU8sRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBQyxDQUFDO0lBQzFELENBQUM7SUFFRDs7T0FFRztJQUNJLGFBQWEsQ0FBQyxVQUFpQztRQUNsRCxJQUFJLFVBQVUsRUFBRTtZQUNaLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxLQUFLLFVBQVUsQ0FBQyxDQUFDO1lBQ3ZELENBQUMsQ0FBQyxDQUFDO1NBQ047YUFBTSxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUN4QyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUNsQyxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztZQUM1QixDQUFDLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztTQUM3QztRQUNELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLDZCQUE2QixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDOUYsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ25ELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUM7UUFDaEQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixHQUFHLFVBQVUsQ0FBQztJQUMxRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxhQUFhLENBQUMsU0FBNkIsRUFBRSxJQUFrQjtRQUNsRSxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzlELENBQUM7SUFFRDs7T0FFRztJQUNJLGNBQWM7UUFDakIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVEOztPQUVHO0lBQ0ksdUJBQXVCO1FBQzFCLE9BQU87WUFDSCxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUMxQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsVUFBVSxDQUFDLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1NBQ3pELENBQUM7SUFDTixDQUFDO0lBRU8sZ0JBQWdCLENBQUMsYUFBcUI7UUFDMUMsSUFBSSxhQUFhLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMxRCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDdEIsT0FBTztTQUNWO1FBRUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBRXpFLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBQzVCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRU8sZ0JBQWdCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFTyxvQkFBb0I7UUFDeEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFFMUQsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2YsSUFBSSxDQUFDLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztTQUM3RTtRQUNELElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLENBQUM7UUFFekIsSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNuRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDO1lBQ25FLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQztZQUNsQixNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7WUFDeEUsSUFBSSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7WUFDMUIsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsV0FBVztnQkFDekQsUUFBUSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxhQUFhLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUVwRyxLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRTtnQkFDL0QsSUFBSSxTQUFTLEdBQUcsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxHQUFHLFNBQVMsRUFBRTtvQkFDOUQsU0FBUyxJQUFJLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsQ0FBQztvQkFDbEQsSUFBSSxLQUFLLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTt3QkFDakIsaUJBQWlCLEVBQUUsQ0FBQztxQkFDdkI7eUJBQU07d0JBQ0gsU0FBUyxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7d0JBQzFHLFNBQVMsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO3FCQUM5RztpQkFDSjtxQkFBTTtvQkFDSCxJQUFJLEtBQUssR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLFNBQVMsR0FBRyxhQUFhLEdBQUcsU0FBUyxFQUFFO3dCQUMxRCxpQkFBaUIsRUFBRSxDQUFDO3FCQUN2Qjt5QkFBTSxJQUFJLGlCQUFpQixHQUFHLENBQUMsSUFBSSxTQUFTLEdBQUcsaUJBQWlCLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLFdBQVcsR0FBRyxhQUFhLEdBQUcsU0FBUyxFQUFFO3dCQUNsSCxpQkFBaUIsRUFBRSxDQUFDO3FCQUN2QjtvQkFDRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsaUJBQWlCLENBQUM7b0JBQ3hFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7b0JBQzNFLE1BQU07aUJBQ1Q7YUFDSjtZQUVELEtBQUssSUFBSSxDQUFDLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUNsRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7YUFDN0M7WUFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQzVCO0lBQ0wsQ0FBQzs4R0F2TlEsNkJBQTZCO2tHQUE3Qiw2QkFBNkIsZ1FBSUosV0FBVyx1SEFHVCxXQUFXLHVIQUdYLFdBQVcsK0dBR2YscUJBQXFCLCtGQUd0QixVQUFVLGlHQUdULGdCQUFnQixxR0FHZCxnQkFBZ0IsNkJDekR0RCw2cEVBMkNBLDRDRFZjLHFCQUFxQix5SkFBRSxnQkFBZ0IsMmJBQUUsZ0JBQWdCLDJGQUFFLGtCQUFrQiw4RUFBRSxLQUFLLG1IQUFFLElBQUksNkZBQUUsT0FBTyxvRkFBRSxpQkFBaUIsbUhBQUUsZ0JBQWdCOzsyRkFFekksNkJBQTZCO2tCQVB6QyxTQUFTO3NDQUNXLHVCQUF1QixDQUFDLE1BQU0sWUFDckMseUJBQXlCLGNBRXZCLElBQUksV0FDUCxDQUFDLHFCQUFxQixFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLGtCQUFrQixFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixDQUFDO3dIQUk1SSxNQUFNO3NCQURaLEtBQUs7Z0JBSUksV0FBVztzQkFEcEIsU0FBUzt1QkFBQyxhQUFhLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBSW5ELGFBQWE7c0JBRHRCLFNBQVM7dUJBQUMsZUFBZSxFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUlyRCxhQUFhO3NCQUR0QixTQUFTO3VCQUFDLGVBQWUsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFJckQsU0FBUztzQkFEbEIsU0FBUzt1QkFBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLEVBQUUscUJBQXFCLEVBQUU7Z0JBSTdDLFFBQVE7c0JBRGpCLFNBQVM7dUJBQUMsVUFBVSxFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRTtnQkFJakMsU0FBUztzQkFEbEIsU0FBUzt1QkFBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBSXhDLFdBQVc7c0JBRHBCLFNBQVM7dUJBQUMsYUFBYSxFQUFFLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFO2dCQUt6QyxZQUFZO3NCQUR0QixXQUFXO3VCQUFDLE9BQU8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIERvQ2hlY2ssXG4gICAgRWxlbWVudFJlZixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSUZpbHRlcmluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi8uLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEZpbHRlcmluZ1NlcnZpY2UgfSBmcm9tICcuLi9ncmlkLWZpbHRlcmluZy5zZXJ2aWNlJztcbmltcG9ydCB7IERpc3BsYXlEZW5zaXR5IH0gZnJvbSAnLi4vLi4vLi4vY29yZS9kZW5zaXR5JztcbmltcG9ydCB7IEV4cHJlc3Npb25VSSB9IGZyb20gJy4uL2V4Y2VsLXN0eWxlL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hDaGlwc0FyZWFDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9jaGlwcy9jaGlwcy1hcmVhLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJQmFzZUNoaXBFdmVudEFyZ3MsIElneENoaXBDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9jaGlwcy9jaGlwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb2x1bW5UeXBlIH0gZnJvbSAnLi4vLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEJhZGdlQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vYmFkZ2UvYmFkZ2UuY29tcG9uZW50JztcbmltcG9ydCB7IE5nRm9yLCBOZ0lmLCBOZ0NsYXNzLCBOZ1RlbXBsYXRlT3V0bGV0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IElneFByZWZpeERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvcHJlZml4L3ByZWZpeC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4SWNvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL2ljb24vaWNvbi5jb21wb25lbnQnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgc2VsZWN0b3I6ICdpZ3gtZ3JpZC1maWx0ZXJpbmctY2VsbCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2dyaWQtZmlsdGVyaW5nLWNlbGwuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW0lneENoaXBzQXJlYUNvbXBvbmVudCwgSWd4Q2hpcENvbXBvbmVudCwgSWd4SWNvbkNvbXBvbmVudCwgSWd4UHJlZml4RGlyZWN0aXZlLCBOZ0ZvciwgTmdJZiwgTmdDbGFzcywgSWd4QmFkZ2VDb21wb25lbnQsIE5nVGVtcGxhdGVPdXRsZXRdXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRGaWx0ZXJpbmdDZWxsQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25Jbml0LCBEb0NoZWNrIHtcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjb2x1bW46IENvbHVtblR5cGU7XG5cbiAgICBAVmlld0NoaWxkKCdlbXB0eUZpbHRlcicsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByb3RlY3RlZCBlbXB0eUZpbHRlcjogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBWaWV3Q2hpbGQoJ2RlZmF1bHRGaWx0ZXInLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSlcbiAgICBwcm90ZWN0ZWQgZGVmYXVsdEZpbHRlcjogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBWaWV3Q2hpbGQoJ2NvbXBsZXhGaWx0ZXInLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSlcbiAgICBwcm90ZWN0ZWQgY29tcGxleEZpbHRlcjogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBWaWV3Q2hpbGQoJ2NoaXBzQXJlYScsIHsgcmVhZDogSWd4Q2hpcHNBcmVhQ29tcG9uZW50IH0pXG4gICAgcHJvdGVjdGVkIGNoaXBzQXJlYTogSWd4Q2hpcHNBcmVhQ29tcG9uZW50O1xuXG4gICAgQFZpZXdDaGlsZCgnbW9yZUljb24nLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgICBwcm90ZWN0ZWQgbW9yZUljb246IEVsZW1lbnRSZWY7XG5cbiAgICBAVmlld0NoaWxkKCdnaG9zdENoaXAnLCB7IHJlYWQ6IElneENoaXBDb21wb25lbnQgfSlcbiAgICBwcm90ZWN0ZWQgZ2hvc3RDaGlwOiBJZ3hDaGlwQ29tcG9uZW50O1xuXG4gICAgQFZpZXdDaGlsZCgnY29tcGxleENoaXAnLCB7IHJlYWQ6IElneENoaXBDb21wb25lbnQgfSlcbiAgICBwcm90ZWN0ZWQgY29tcGxleENoaXA6IElneENoaXBDb21wb25lbnQ7XG5cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICAgIHB1YmxpYyBnZXQgc3R5bGVDbGFzc2VzKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBjbGFzc2VzID0gdGhpcy5jb2x1bW4gJiYgdGhpcy5jb2x1bW4uc2VsZWN0ZWQgP1xuICAgICAgICAgICAgJ2lneC1ncmlkX19maWx0ZXJpbmctY2VsbC0tc2VsZWN0ZWQnIDpcbiAgICAgICAgICAgICdpZ3gtZ3JpZF9fZmlsdGVyaW5nLWNlbGwnO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5jb2x1bW4uZ3JpZC5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21wYWN0OlxuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzICsgJyBpZ3gtZ3JpZF9fZmlsdGVyaW5nLWNlbGwtLWNvbXBhY3QnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb3N5OlxuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzICsgJyBpZ3gtZ3JpZF9fZmlsdGVyaW5nLWNlbGwtLWNvc3knO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgIH1cblxuICAgIHB1YmxpYyBleHByZXNzaW9uc0xpc3Q6IEV4cHJlc3Npb25VSVtdO1xuICAgIHB1YmxpYyBtb3JlRmlsdGVyc0NvdW50ID0gMDtcblxuICAgIHByaXZhdGUgYmFzZUNsYXNzID0gJ2lneC1ncmlkX19maWx0ZXJpbmctY2VsbC1pbmRpY2F0b3InO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHB1YmxpYyBmaWx0ZXJpbmdTZXJ2aWNlOiBJZ3hGaWx0ZXJpbmdTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyaW5nU2VydmljZS5zdWJzY3JpYmVUb0V2ZW50cygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5maWx0ZXJpbmdTZXJ2aWNlLmNvbHVtblRvTW9yZUljb25IaWRkZW4uc2V0KHRoaXMuY29sdW1uLmZpZWxkLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbHRlckNlbGxBcmVhKCk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nRG9DaGVjaygpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGaWx0ZXJDZWxsQXJlYSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBhIGNoaXAgd2l0aCBhIGdpdmVuIGluZGV4IGlzIHZpc2libGUgb3Igbm90LlxuICAgICAqL1xuICAgIHB1YmxpYyBpc0NoaXBWaXNpYmxlKGluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbnNMaXN0W2luZGV4XTtcbiAgICAgICAgcmV0dXJuICEhKGV4cHJlc3Npb24gJiYgZXhwcmVzc2lvbi5pc1Zpc2libGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGZpbHRlcmluZyBjZWxsIGFyZWEuXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZUZpbHRlckNlbGxBcmVhKCkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zTGlzdCA9IHRoaXMuZmlsdGVyaW5nU2VydmljZS5nZXRFeHByZXNzaW9ucyh0aGlzLmNvbHVtbi5maWVsZCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJsZUZpbHRlcnMoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGRpc3BsYXlEZW5zaXR5KCk6IERpc3BsYXlEZW5zaXR5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uLmdyaWQuZGlzcGxheURlbnNpdHkgPT09IERpc3BsYXlEZW5zaXR5LmNvbWZvcnRhYmxlID8gRGlzcGxheURlbnNpdHkuY29zeSA6IHRoaXMuY29sdW1uLmdyaWQuZGlzcGxheURlbnNpdHk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCB0ZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbi5maWx0ZXJhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2x1bW4uZmlsdGVyQ2VsbFRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW4uZmlsdGVyQ2VsbFRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25UcmVlID0gdGhpcy5jb2x1bW4uZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlO1xuICAgICAgICBpZiAoIWV4cHJlc3Npb25UcmVlIHx8IGV4cHJlc3Npb25UcmVlLmZpbHRlcmluZ09wZXJhbmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlGaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyaW5nU2VydmljZS5pc0ZpbHRlckNvbXBsZXgodGhpcy5jb2x1bW4uZmllbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV4RmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRGaWx0ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29udGV4dCBwYXNzZWQgdG8gdGhlIGZpbHRlciB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hHcmlkRmlsdGVyaW5nQ2VsbENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHsgJGltcGxpY2l0OiB0aGlzLmNvbHVtbiwgY29sdW1uOiB0aGlzLmNvbHVtbn07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hpcCBjbGlja2VkIGV2ZW50IGhhbmRsZXIuXG4gICAgICovXG4gICAgcHVibGljIG9uQ2hpcENsaWNrZWQoZXhwcmVzc2lvbj86IElGaWx0ZXJpbmdFeHByZXNzaW9uKSB7XG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zTGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5pc1NlbGVjdGVkID0gKGl0ZW0uZXhwcmVzc2lvbiA9PT0gZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmV4cHJlc3Npb25zTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zTGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnNMaXN0WzBdLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyaW5nU2VydmljZS5ncmlkLm5hdmlnYXRpb24ucGVyZm9ybUhvcml6b250YWxTY3JvbGxUb0NlbGwodGhpcy5jb2x1bW4udmlzaWJsZUluZGV4KTtcbiAgICAgICAgdGhpcy5maWx0ZXJpbmdTZXJ2aWNlLmZpbHRlcmVkQ29sdW1uID0gdGhpcy5jb2x1bW47XG4gICAgICAgIHRoaXMuZmlsdGVyaW5nU2VydmljZS5pc0ZpbHRlclJvd1Zpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpbHRlcmluZ1NlcnZpY2Uuc2VsZWN0ZWRFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGlwIHJlbW92ZWQgZXZlbnQgaGFuZGxlci5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25DaGlwUmVtb3ZlZChldmVudEFyZ3M6IElCYXNlQ2hpcEV2ZW50QXJncywgaXRlbTogRXhwcmVzc2lvblVJKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGluZGV4VG9SZW1vdmUgPSB0aGlzLmV4cHJlc3Npb25zTGlzdC5pbmRleE9mKGl0ZW0pO1xuICAgICAgICB0aGlzLnJlbW92ZUV4cHJlc3Npb24oaW5kZXhUb1JlbW92ZSk7XG4gICAgICAgIHRoaXMuZmlsdGVyaW5nU2VydmljZS5ncmlkLnRoZWFkUm93Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGZpbHRlcmluZy5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXJGaWx0ZXJpbmcoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmlsdGVyaW5nU2VydmljZS5jbGVhckZpbHRlcih0aGlzLmNvbHVtbi5maWVsZCk7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXJpbmcgaW5kaWNhdG9yIGNsYXNzLlxuICAgICAqL1xuICAgIHB1YmxpYyBmaWx0ZXJpbmdJbmRpY2F0b3JDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFt0aGlzLmJhc2VDbGFzc106ICF0aGlzLmlzTW9yZUljb25IaWRkZW4oKSxcbiAgICAgICAgICAgIFtgJHt0aGlzLmJhc2VDbGFzc30tLWhpZGRlbmBdOiB0aGlzLmlzTW9yZUljb25IaWRkZW4oKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVtb3ZlRXhwcmVzc2lvbihpbmRleFRvUmVtb3ZlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKGluZGV4VG9SZW1vdmUgPT09IDAgJiYgdGhpcy5leHByZXNzaW9uc0xpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyRmlsdGVyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbHRlcmluZ1NlcnZpY2UucmVtb3ZlRXhwcmVzc2lvbih0aGlzLmNvbHVtbi5maWVsZCwgaW5kZXhUb1JlbW92ZSk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmxlRmlsdGVycygpO1xuICAgICAgICB0aGlzLmZpbHRlcmluZ1NlcnZpY2UuZmlsdGVySW50ZXJuYWwodGhpcy5jb2x1bW4uZmllbGQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNNb3JlSWNvbkhpZGRlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyaW5nU2VydmljZS5jb2x1bW5Ub01vcmVJY29uSGlkZGVuLmdldCh0aGlzLmNvbHVtbi5maWVsZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVWaXNpYmxlRmlsdGVycygpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uc0xpc3QuZm9yRWFjaCgoZXgpID0+IGV4LmlzVmlzaWJsZSA9IHRydWUpO1xuXG4gICAgICAgIGlmICh0aGlzLm1vcmVJY29uKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmluZ1NlcnZpY2UuY29sdW1uVG9Nb3JlSWNvbkhpZGRlbi5zZXQodGhpcy5jb2x1bW4uZmllbGQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcblxuICAgICAgICBpZiAodGhpcy5jaGlwc0FyZWEgJiYgdGhpcy5leHByZXNzaW9uc0xpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgYXJlYVdpZHRoID0gdGhpcy5jaGlwc0FyZWEuZWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgbGV0IHZpZXdXaWR0aCA9IDA7XG4gICAgICAgICAgICBjb25zdCBjaGlwc0FyZWFFbGVtZW50cyA9IHRoaXMuY2hpcHNBcmVhLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgIGxldCB2aXNpYmxlQ2hpcHNDb3VudCA9IDA7XG4gICAgICAgICAgICBjb25zdCBtb3JlSWNvbldpZHRoID0gdGhpcy5tb3JlSWNvbi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC1cbiAgICAgICAgICAgICAgICBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubW9yZUljb24ubmF0aXZlRWxlbWVudClbJ21hcmdpbi1sZWZ0J10sIDEwKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNoaXBzQXJlYUVsZW1lbnRzLmxlbmd0aCAtIDE7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmlld1dpZHRoICsgY2hpcHNBcmVhRWxlbWVudHNbaW5kZXhdLm9mZnNldFdpZHRoIDwgYXJlYVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdXaWR0aCArPSBjaGlwc0FyZWFFbGVtZW50c1tpbmRleF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGVDaGlwc0NvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3V2lkdGggKz0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjaGlwc0FyZWFFbGVtZW50c1tpbmRleF0pWydtYXJnaW4tbGVmdCddLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3V2lkdGggKz0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjaGlwc0FyZWFFbGVtZW50c1tpbmRleF0pWydtYXJnaW4tcmlnaHQnXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiAhPT0gMCAmJiB2aWV3V2lkdGggKyBtb3JlSWNvbldpZHRoID4gYXJlYVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlQ2hpcHNDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpc2libGVDaGlwc0NvdW50ID4gMCAmJiB2aWV3V2lkdGggLSBjaGlwc0FyZWFFbGVtZW50c1tpbmRleCAtIDFdLm9mZnNldFdpZHRoICsgbW9yZUljb25XaWR0aCA+IGFyZWFXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUNoaXBzQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vcmVGaWx0ZXJzQ291bnQgPSB0aGlzLmV4cHJlc3Npb25zTGlzdC5sZW5ndGggLSB2aXNpYmxlQ2hpcHNDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJpbmdTZXJ2aWNlLmNvbHVtblRvTW9yZUljb25IaWRkZW4uc2V0KHRoaXMuY29sdW1uLmZpZWxkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHZpc2libGVDaGlwc0NvdW50OyBpIDwgdGhpcy5leHByZXNzaW9uc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zTGlzdFtpXS5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIjxuZy10ZW1wbGF0ZSAjZW1wdHlGaWx0ZXI+XG4gICAgPGlneC1jaGlwcy1hcmVhIFthdHRyLmRyYWdnYWJsZV09XCJmYWxzZVwiIGNsYXNzPVwiaWd4LWZpbHRlcmluZy1jaGlwc1wiPlxuICAgICAgICA8aWd4LWNoaXAgI2dob3N0Q2hpcCBbYXR0ci5kcmFnZ2FibGVdPVwiZmFsc2VcIiAoY2xpY2spPVwib25DaGlwQ2xpY2tlZCgpXCIgW2Rpc3BsYXlEZW5zaXR5XT1cImRpc3BsYXlEZW5zaXR5XCIgW3RhYkluZGV4XT1cIi0xXCI+XG4gICAgICAgICAgICA8aWd4LWljb24gW2F0dHIuZHJhZ2dhYmxlXT1cImZhbHNlXCIgaWd4UHJlZml4PmZpbHRlcl9saXN0PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgIDxzcGFuIFthdHRyLmRyYWdnYWJsZV09XCJmYWxzZVwiPnt7ZmlsdGVyaW5nU2VydmljZS5ncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9maWx0ZXJ9fTwvc3Bhbj5cbiAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICA8L2lneC1jaGlwcy1hcmVhPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0RmlsdGVyPlxuICAgIDxpZ3gtY2hpcHMtYXJlYSAjY2hpcHNBcmVhIGNsYXNzPVwiaWd4LWZpbHRlcmluZy1jaGlwc1wiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBpdGVtIG9mIGV4cHJlc3Npb25zTGlzdDsgbGV0IGxhc3QgPSBsYXN0OyBsZXQgaW5kZXggPSBpbmRleDtcIiA+XG4gICAgICAgICAgICA8aWd4LWNoaXAgKm5nSWY9XCJpc0NoaXBWaXNpYmxlKGluZGV4KVwiXG4gICAgICAgICAgICAgICAgW3JlbW92YWJsZV09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBbdGFiSW5kZXhdPVwiLTFcIlxuICAgICAgICAgICAgICAgIFtkaXNwbGF5RGVuc2l0eV09XCJkaXNwbGF5RGVuc2l0eVwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uQ2hpcENsaWNrZWQoaXRlbS5leHByZXNzaW9uKVwiXG4gICAgICAgICAgICAgICAgKHJlbW92ZSk9XCJvbkNoaXBSZW1vdmVkKCRldmVudCwgaXRlbSlcIj5cbiAgICAgICAgICAgICAgICA8aWd4LWljb24gaWd4UHJlZml4XG4gICAgICAgICAgICAgICAgICAgIGZhbWlseT1cImlteC1pY29uc1wiXG4gICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cIml0ZW0uZXhwcmVzc2lvbi5jb25kaXRpb24uaWNvbk5hbWVcIj5cbiAgICAgICAgICAgICAgICA8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgIDxzcGFuICNsYWJlbD5cbiAgICAgICAgICAgICAgICAgICAge3tmaWx0ZXJpbmdTZXJ2aWNlLmdldENoaXBMYWJlbChpdGVtLmV4cHJlc3Npb24pfX1cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtZmlsdGVyaW5nLWNoaXBzX19jb25uZWN0b3JcIiAqbmdJZj1cIiFsYXN0ICYmIGlzQ2hpcFZpc2libGUoaW5kZXggKyAxKVwiPnt7ZmlsdGVyaW5nU2VydmljZS5nZXRPcGVyYXRvckFzU3RyaW5nKGl0ZW0uYWZ0ZXJPcGVyYXRvcil9fTwvc3Bhbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxkaXYgI21vcmVJY29uIFtuZ0NsYXNzXT1cImZpbHRlcmluZ0luZGljYXRvckNsYXNzKClcIiAoY2xpY2spPVwib25DaGlwQ2xpY2tlZCgpXCI+XG4gICAgICAgICAgICA8aWd4LWljb24+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICAgICAgPGlneC1iYWRnZSBbdmFsdWVdPVwibW9yZUZpbHRlcnNDb3VudFwiPjwvaWd4LWJhZGdlPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2lneC1jaGlwcy1hcmVhPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNjb21wbGV4RmlsdGVyPlxuICAgIDxpZ3gtY2hpcCAjY29tcGxleENoaXAgW3JlbW92YWJsZV09XCJ0cnVlXCIgW2Rpc3BsYXlEZW5zaXR5XT1cImRpc3BsYXlEZW5zaXR5XCIgKHJlbW92ZSk9XCJjbGVhckZpbHRlcmluZygpXCIgW3RhYkluZGV4XT1cIi0xXCI+XG4gICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXg+ZmlsdGVyX2xpc3Q8L2lneC1pY29uPlxuICAgICAgICA8c3Bhbj57e2ZpbHRlcmluZ1NlcnZpY2UuZ3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfY29tcGxleF9maWx0ZXJ9fTwvc3Bhbj5cbiAgICA8L2lneC1jaGlwPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRlbXBsYXRlOyBjb250ZXh0OiBjb250ZXh0XCI+PC9uZy1jb250YWluZXI+XG4iXX0=