"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const UpdateChanges_1 = require("../common/UpdateChanges");
// use bare specifier to escape the schematics encapsulation for the dynamic import:
const import_helper_js_1 = require("igniteui-angular/migrations/common/import-helper.js");
const tsUtils_1 = require("../common/tsUtils");
const util_1 = require("../common/util");
const version = '17.0.0';
exports.default = () => (host, context) => __awaiter(void 0, void 0, void 0, function* () {
    context.logger.info(`Applying migration for Ignite UI for Angular to version ${version}`);
    const { HtmlParser } = yield (0, import_helper_js_1.nativeImport)('@angular/compiler');
    const update = new UpdateChanges_1.UpdateChanges(__dirname, host, context);
    const changes = new Map();
    const prop = ['type'];
    const elevated = ['elevated'];
    const applyChanges = () => {
        for (const [path, change] of changes.entries()) {
            let buffer = host.read(path).toString();
            change.sort((c, c1) => c.position - c1.position)
                .reverse()
                .forEach(c => buffer = c.apply(buffer));
            host.overwrite(path, buffer);
        }
    };
    const addChange = (path, change) => {
        if (changes.has(path)) {
            changes.get(path).push(change);
        }
        else {
            changes.set(path, [change]);
        }
    };
    for (const path of update.templateFiles) {
        const cardComponents = (0, util_1.findElementNodes)((0, util_1.parseFile)(new HtmlParser(), host, path), 'igx-card');
        cardComponents
            .filter(node => (0, util_1.hasAttribute)(node, prop) && !(0, util_1.hasAttribute)(node, elevated))
            .map(node => (0, util_1.getSourceOffset)(node))
            .forEach(offset => {
            const { startTag, file, node } = offset;
            const { name, value } = (0, util_1.getAttribute)(node, prop)[0];
            const repTxt = file.content.substring(startTag.start, startTag.end - 1);
            const property = `${name}="${value}"`;
            if (value === 'outlined') {
                const removePropTxt = repTxt.replace(property, '').trimEnd();
                addChange(file.url, new util_1.FileChange(startTag.start, removePropTxt, repTxt, 'replace'));
            }
            else {
                const removePropTxt = repTxt.replace(property, `elevated`);
                addChange(file.url, new util_1.FileChange(startTag.start, removePropTxt, repTxt, 'replace'));
            }
        });
        cardComponents
            .filter(node => !(0, util_1.hasAttribute)(node, prop) && !(0, util_1.hasAttribute)(node, elevated))
            .map(node => (0, util_1.getSourceOffset)(node))
            .forEach(offset => {
            const { startTag, file } = offset;
            const repTxt = file.content.substring(startTag.start, startTag.end - 1);
            const removePropTxt = repTxt.concat(' ', `elevated`);
            addChange(file.url, new util_1.FileChange(startTag.start, removePropTxt, repTxt, 'replace'));
        });
    }
    // Not able to import * as animations from ../../animations due to ESM error - migrations are commonjs, while they should be ESM.
    var animationsExports = ["IAnimationParams", "AnimationUtil", "EaseIn", "EaseInOut", "EaseOut", "fadeIn", "fadeOut",
        "flipTop", "flipRight", "flipBottom", "flipLeft", "flipHorFwd", "flipHorBck", "flipVerFwd", "flipVerBck",
        "rotateInCenter", "rotateInTop", "rotateInRight", "rotateInLeft", "rotateInBottom", "rotateInTr", "rotateInBr",
        "rotateInBl", "rotateInTl", "rotateInDiagonal1", "rotateInDiagonal2", "rotateInHor", "rotateInVer", "rotateOutCenter",
        "rotateOutTop", "rotateOutRight", "rotateOutLeft", "rotateOutBottom", "rotateOutTr", "rotateOutBr", "rotateOutBl",
        "rotateOutTl", "rotateOutDiagonal1", "rotateOutDiagonal2", "rotateOutHor", "rotateOutVer",
        "scaleInTop", "scaleInRight", "scaleInBottom", "scaleInLeft",
        "scaleInCenter", "scaleInTr", "scaleInBr", "scaleInBl", "scaleInTl", "scaleInVerTop", "scaleInVerBottom",
        "scaleInVerCenter", "scaleInHorCenter", "scaleInHorLeft", "scaleInHorRight", "scaleOutTop", "scaleOutRight",
        "scaleOutBottom", "scaleOutLeft", "scaleOutCenter", "scaleOutTr", "scaleOutBr", "scaleOutBl", "scaleOutTl",
        "scaleOutVerTop", "scaleOutVerBottom", "scaleOutVerCenter", "scaleOutHorCenter", "scaleOutHorLeft", "scaleOutHorRight",
        "slideInTop", "slideInRight", "slideInBottom", "slideInLeft", "slideInTr", "slideInBr", "slideInBl", "slideInTl",
        "slideOutTop", "slideOutBottom", "slideOutRight", "slideOutLeft", "slideOutTr", "slideOutBr", "slideOutBl", "slideOutTl",
        "swingInTopFwd", "swingInRightFwd", "swingInLeftFwd", "swingInBottomFwd", "swingInTopBck", "swingInRightBck", "swingInBottomBck",
        "swingInLeftBck", "swingOutTopFwd", "swingOutRightFwd", "swingOutBottomFwd", "swingOutLefttFwd", "swingOutTopBck", "swingOutRightBck",
        "swingOutBottomBck", "swingOutLeftBck", "growVerIn", "growVerOut", "shakeHor", "shakeVer", "shakeTop", "shakeBottom", "shakeRight",
        "shakeLeft", "shakeCenter", "shakeTr", "shakeBr", "shakeBl", "shakeTl", "pulsateFwd", "pulsateBck", "heartbeat", "blink"];
    update.tsFiles.forEach((filePath) => {
        var animationsInFile = [];
        var fileContent = host.read(filePath).toString();
        const source = ts.createSourceFile('', fileContent, ts.ScriptTarget.Latest, true);
        const igImports = source.statements.filter(tsUtils_1.namedImportFilter);
        // Find all animations imported from 'igniteui-angular' and delete them.
        for (const igImport of igImports) {
            const start = igImport.getStart();
            const end = igImport.getEnd();
            const igImportContent = fileContent.substring(start, end);
            animationsExports.forEach(anime => {
                let match;
                const animeSearchTerm = new RegExp(`(?<=\\{)\\s*${anime}[\\s,]|[\\s,]\\s*${anime}`, 'g');
                while ((match = animeSearchTerm.exec(igImportContent)) !== null) {
                    addChange(filePath, new util_1.FileChange(start + match.index, '', match[0], 'replace'));
                    animationsInFile.push(anime);
                }
            });
        }
        // Build new import for all the animations from 'igniteui-angular/animations'.
        // Add the new import at the end of all imports.
        if (animationsInFile.length > 0) {
            const lastImport = igImports.reduce((a, b) => a.getEnd() > b.getEnd() ? a : b);
            const newAnimeImport = `\nimport { ${animationsInFile.sort().join(', ')} } from '${(lastImport === null || lastImport === void 0 ? void 0 : lastImport.moduleSpecifier).text}/animations';`;
            addChange(filePath, new util_1.FileChange(lastImport === null || lastImport === void 0 ? void 0 : lastImport.getEnd(), newAnimeImport, '', 'insert'));
        }
    });
    applyChanges();
    update.applyChanges();
});
