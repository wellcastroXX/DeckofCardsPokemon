"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// use bare specifier to escape the schematics encapsulation for the dynamic import:
const import_helper_js_1 = require("igniteui-angular/migrations/common/import-helper.js");
const UpdateChanges_1 = require("../common/UpdateChanges");
const util_1 = require("../common/util");
const version = '15.1.0';
exports.default = (options) => (host, context) => __awaiter(void 0, void 0, void 0, function* () {
    context.logger.info(`Applying migration for Ignite UI for Angular to version ${version}`);
    const { HtmlParser } = yield (0, import_helper_js_1.nativeImport)('@angular/compiler');
    const update = new UpdateChanges_1.UpdateChanges(__dirname, host, context);
    const cardsToMigrate = new Set();
    const CARD_ACTIONS = ['igx-card-actions'];
    const prop = ['igxButton'];
    const changes = new Map();
    const applyChanges = () => {
        for (const [path, change] of changes.entries()) {
            let buffer = host.read(path).toString();
            change.sort((c, c1) => c.position - c1.position)
                .reverse()
                .forEach(c => buffer = c.apply(buffer));
            host.overwrite(path, buffer);
        }
    };
    const addChange = (path, change) => {
        if (changes.has(path)) {
            changes.get(path).push(change);
        }
        else {
            changes.set(path, [change]);
        }
    };
    const getChildren = (parent, buttons, icons) => {
        const cardButtons = parent.children.filter(btn => btn.attrs !== undefined && (0, util_1.hasAttribute)(btn, prop));
        const cardIcons = parent.children.filter(btn => btn.name === 'igx-icon');
        buttons.push(...cardButtons);
        icons.push(...cardIcons);
    };
    for (const path of update.templateFiles) {
        cardsToMigrate.clear();
        const cardActions = (0, util_1.findElementNodes)((0, util_1.parseFile)(new HtmlParser(), host, path), CARD_ACTIONS);
        cardActions.forEach(card => {
            const card_action_elem = card;
            const buttons = [];
            const icons = [];
            getChildren(card_action_elem, buttons, icons);
            icons.map(node => (0, util_1.getSourceOffset)(node))
                .forEach(offset => {
                const { startTag, file, node } = offset;
                const end = (0, util_1.getAttribute)(node, 'igxEnd')[0];
                if (!end) {
                    addChange(file.url, new util_1.FileChange(startTag.end - 1, ' igxEnd'));
                }
            });
            buttons.map(node => (0, util_1.getSourceOffset)(node))
                .forEach(offset => {
                const { startTag, file, node } = offset;
                const { value } = (0, util_1.getAttribute)(node, prop)[0];
                const start = (0, util_1.getAttribute)(node, 'igxStart')[0];
                const end = (0, util_1.getAttribute)(node, 'igxEnd')[0];
                if (!start && value !== 'icon') {
                    addChange(file.url, new util_1.FileChange(startTag.end - 1, ' igxStart'));
                }
                if (!end && value === 'icon') {
                    addChange(file.url, new util_1.FileChange(startTag.end - 1, ' igxEnd'));
                }
            });
        });
    }
    update.shouldInvokeLS = options['shouldInvokeLS'];
    update.addValueTransform('roundShape_is_deprecated', (args) => {
        args.bindingType = UpdateChanges_1.InputPropertyType.STRING;
        switch (args.value) {
            case 'true':
                args.value = 'circle';
                break;
            case 'false':
                args.value = 'square';
                break;
            default:
                args.value += ` ? 'circle' : 'square' `;
        }
    });
    applyChanges();
    update.applyChanges();
});
