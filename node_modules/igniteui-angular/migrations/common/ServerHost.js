"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerHost = void 0;
const pathFs = require("path");
const ts = require("typescript/lib/tsserverlibrary");
const tsUtils_1 = require("./tsUtils");
/**
 * Language server host is responsible for **most** of the FS operations / checks
 * Angular's Ivy LS sometimes bypasses these, calling path methods instead of tsLsHost operations
 */
class ServerHost {
    constructor(host) {
        this.host = host;
        this.args = ts.sys.args;
        this.newLine = ts.sys.newLine;
        this.useCaseSensitiveFileNames = ts.sys.useCaseSensitiveFileNames;
    }
    /**
     * Read a file's content from the Virtual Tree
     * If file does not exist in virtual tree, check in physical FS
     */
    readFile(path, encoding) {
        let content;
        // ensure the path is relative, so it can be found in the Tree, reflecting latest state
        path = pathFs.relative(this.getCurrentDirectory(), path);
        try {
            content = this.host.read(path).toString(encoding);
        }
        finally {
            // eslint-disable-next-line no-unsafe-finally
            return content || ts.sys.readFile(path, encoding);
        }
    }
    getFileSize(path) {
        return ts.sys.getFileSize(path);
    }
    //#region Watchers
    // Atm we do not need to have file or dir watchers that access the actual FS
    // as we are only working with NG's virtual FS
    // Prior to https://github.com/microsoft/TypeScript/pull/49990 we were more or less required
    // to add a watcher since it threw an error otherwise
    watchFile(_path, _callback, _pollingInterval) {
        // return ts.sys.watchFile(path, callback, pollingInterval);
        return { close: () => { } };
    }
    watchDirectory(_path, _callback, _recursive) {
        // return ts.sys.watchDirectory(path, callback, recursive);
        return { close: () => { } };
    }
    //#endregion
    resolvePath(path) {
        return ts.sys.resolvePath(path);
    }
    /**
     * Checks for file in Virtual Tree w/ relative path
     * If file does not exist in virtual tree, check in physical FS
     */
    fileExists(path) {
        // check for file in Tree, as schematics might need for check
        path = pathFs.relative(this.getCurrentDirectory(), path);
        let flag = false;
        try {
            // Tree.exists throws on invalid paths instead of returning false
            flag = this.host.exists(path);
        }
        finally {
            // eslint-disable-next-line no-unsafe-finally
            return flag || ts.sys.fileExists(path);
        }
    }
    directoryExists(path) {
        let exists;
        path = pathFs.relative(this.getCurrentDirectory(), path);
        try {
            exists = this.host.getDir(path) !== void 0;
        }
        finally {
            // eslint-disable-next-line no-unsafe-finally
            return exists || ts.sys.directoryExists(path);
        }
    }
    getExecutingFilePath() {
        return ts.sys.getExecutingFilePath();
    }
    getCurrentDirectory() {
        // both TS and NG lang serves work with absolute paths
        // we provide cwd instead of tree root so paths can be resolved to absolute ones
        return process.cwd();
    }
    /**
     * Get all subdirs of a directory from the Tree mapped to absolute paths
     */
    getDirectories(path) {
        // check directory contents in Tree (w/ relative paths)
        path = pathFs.relative(this.getCurrentDirectory(), path);
        // return directory contents w/ absolute paths for LS
        return this.host.getDir(path).subdirs.map(e => pathFs.resolve(path, e));
    }
    /**
     * Get all files of a directory from the Tree mapped to absolute paths
     */
    readDirectory(path) {
        // check directory contents in Tree (w/ relative paths)
        path = pathFs.relative(this.getCurrentDirectory(), path);
        // return directory contents w/ absolute paths for LS
        return this.host.getDir(path).subfiles.map(e => pathFs.resolve(path, e));
    }
    require(initialPath, moduleName) {
        try {
            const paths = [initialPath];
            if (moduleName === tsUtils_1.CUSTOM_TS_PLUGIN_NAME) {
                moduleName = tsUtils_1.CUSTOM_TS_PLUGIN_PATH;
                paths.push(__dirname);
            }
            const modulePath = require.resolve(moduleName, { paths });
            return {
                module: require(modulePath),
                error: undefined,
            };
        }
        catch (e) {
            return {
                module: undefined,
                error: e,
            };
        }
    }
    gc() {
        global.gc();
    }
    trace(_s) { }
    getModifiedTime(path) {
        return ts.sys.getModifiedTime(path);
    }
    realpath(path) {
        return ts.sys.realpath(path);
    }
    createSHA256Hash(data) {
        return ts.sys.createSHA256Hash(data);
    }
    write(data) {
        ts.sys.write(data);
    }
    writeOutputIsTTY() {
        return ts.sys.writeOutputIsTTY();
    }
    writeFile(path, data, writeByteOrderMark) {
        return ts.sys.writeFile(path, data, writeByteOrderMark);
    }
    createDirectory(path) {
        return ts.sys.createDirectory(path);
    }
    setModifiedTime(path, time) {
        return ts.sys.setModifiedTime(path, time);
    }
    deleteFile(path) {
        return ts.sys.deleteFile(path);
    }
    createHash(data) {
        return ts.sys.createHash(data);
    }
    getMemoryUsage() {
        return ts.sys.getMemoryUsage();
    }
    exit(exitCode) {
        return ts.sys.exit(exitCode);
    }
    setTimeout(callback, ms, ...args) {
        return ts.sys.setTimeout(callback, ms, ...args);
    }
    clearTimeout(timeoutId) {
        return ts.sys.clearTimeout(timeoutId);
    }
    clearScreen() {
        return ts.sys.clearScreen();
    }
    base64decode(input) {
        return ts.sys.base64decode(input);
    }
    base64encode(input) {
        return ts.sys.base64encode(input);
    }
    setImmediate(callback, ...args) {
        return setImmediate(callback, ...args);
    }
    clearImmediate(timeoutId) {
        return clearImmediate(timeoutId);
    }
}
exports.ServerHost = ServerHost;
